<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>lyyljs`s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java">
<meta property="og:type" content="website">
<meta property="og:title" content="lyyljs&#96;s blog">
<meta property="og:url" content="http://lyyljs.site/page/2/index.html">
<meta property="og:site_name" content="lyyljs&#96;s blog">
<meta property="og:description" content="java">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lyyljs">
<meta property="article:tag" content="开发者">
<meta property="article:tag" content="程序猿">
<meta property="article:tag" content="程序媛">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="代码">
<meta property="article:tag" content="Developer">
<meta property="article:tag" content="Programmer">
<meta property="article:tag" content="Coder">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="lyyljs`s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lyyljs`s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lyyljs.site"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-打包应用到docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/%E6%89%93%E5%8C%85%E5%BA%94%E7%94%A8%E5%88%B0docker/" class="article-date">
  <time datetime="2019-04-03T17:26:00.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/%E6%89%93%E5%8C%85%E5%BA%94%E7%94%A8%E5%88%B0docker/">打包应用到docker</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="使用maven打包"><a href="#使用maven打包" class="headerlink" title="使用maven打包"></a>使用maven打包</h4><p>使用eureka项目作示例。采用copy class文件的方式。</p>
<p>1.添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">	...</span><br><span class="line">	&lt;docker.image.prefix&gt;lyyljs&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   	&lt;build&gt;</span><br><span class="line">	&lt;plugins&gt;</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;plugin&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">           	&lt;artifactId&gt;dockerfile-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">           	&lt;version&gt;1.4.9&lt;&#x2F;version&gt;</span><br><span class="line">           	&lt;configuration&gt;</span><br><span class="line">               	&lt;repository&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;repository&gt;</span><br><span class="line">           	&lt;&#x2F;configuration&gt;</span><br><span class="line"></span><br><span class="line">		&lt;&#x2F;plugin&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">               &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">               &lt;artifactId&gt;maven-dependency-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">               &lt;executions&gt;</span><br><span class="line">                   &lt;execution&gt;</span><br><span class="line">                       &lt;id&gt;unpack&lt;&#x2F;id&gt;</span><br><span class="line">                       &lt;phase&gt;package&lt;&#x2F;phase&gt;</span><br><span class="line">                       &lt;goals&gt;</span><br><span class="line">                           &lt;goal&gt;unpack&lt;&#x2F;goal&gt;</span><br><span class="line">                       &lt;&#x2F;goals&gt;</span><br><span class="line">                       &lt;configuration&gt;</span><br><span class="line">                           &lt;artifactItems&gt;</span><br><span class="line">                               &lt;artifactItem&gt;</span><br><span class="line">                                   &lt;groupId&gt;$&#123;project.groupId&#125;&lt;&#x2F;groupId&gt;</span><br><span class="line">                                   &lt;artifactId&gt;$&#123;project.artifactId&#125;&lt;&#x2F;artifactId&gt;</span><br><span class="line">                                   &lt;version&gt;$&#123;project.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">                               &lt;&#x2F;artifactItem&gt;</span><br><span class="line">                           &lt;&#x2F;artifactItems&gt;</span><br><span class="line">                       &lt;&#x2F;configuration&gt;</span><br><span class="line">                   &lt;&#x2F;execution&gt;</span><br><span class="line">               &lt;&#x2F;executions&gt;</span><br><span class="line">           &lt;&#x2F;plugin&gt;</span><br><span class="line">           </span><br><span class="line">	&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure>

<p>2.添加Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8-jdk-alpine</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ARG DEPENDENCY&#x3D;target&#x2F;dependency</span><br><span class="line">COPY $&#123;DEPENDENCY&#125;&#x2F;BOOT-INF&#x2F;lib &#x2F;app&#x2F;lib</span><br><span class="line">COPY $&#123;DEPENDENCY&#125;&#x2F;META-INF &#x2F;app&#x2F;META-INF</span><br><span class="line">COPY $&#123;DEPENDENCY&#125;&#x2F;BOOT-INF&#x2F;classes &#x2F;app</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-cp&quot;,&quot;app:app&#x2F;lib&#x2F;*&quot;,&quot;lyyljs.cloud.eureka.EurekaApplication&quot;]%</span><br></pre></td></tr></table></figure>

<p>3.mvn打包docker镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;mvnw install dockerfile:build</span><br></pre></td></tr></table></figure>

<p>或推送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;mvnw dockerfile:push</span><br></pre></td></tr></table></figure>

<p>4.run it</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:8000 -d lyyljs&#x2F;eureka</span><br></pre></td></tr></table></figure>

<p>访问localhost:8000，可以看到eureka已经启动起来了。</p>
<hr>
<p><a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">Spring Boot with Docker</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/04/03/%E6%89%93%E5%8C%85%E5%BA%94%E7%94%A8%E5%88%B0docker/" data-id="ckaqo6uzk001t28o6cgn37je5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-cloud实践-六-gateway" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/spring-cloud%E5%AE%9E%E8%B7%B5-%E5%85%AD-gateway/" class="article-date">
  <time datetime="2019-04-03T11:47:33.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/spring-cloud%E5%AE%9E%E8%B7%B5-%E5%85%AD-gateway/">spring cloud实践(六) gateway</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是API网关"><a href="#什么是API网关" class="headerlink" title="什么是API网关"></a>什么是API网关</h4><p>API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。<br>API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。</p>
<h4 id="常见API网关"><a href="#常见API网关" class="headerlink" title="常见API网关"></a>常见API网关</h4><ul>
<li>Nginx</li>
<li>OpenResty</li>
<li>Kong</li>
<li>ZUUL</li>
<li>Spring Cloud Gateway</li>
</ul>
<h4 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h4><h5 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h5><ul>
<li><p>Route(路由): 这是网关的基本构建块。它由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配。</p>
</li>
<li><p>Predicate(断言): 这是一个 Java 8 的 Predicate。输入类型是一个 (Spring Framework)ServerWebExchange。我们可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。</p>
</li>
<li><p>Filter(过滤器): 这是由工厂产出的(Spring Framework)GatewayFilter的实例，我们可以使用它修改请求和响应。</p>
</li>
</ul>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p><img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-gateway/master/docs/src/main/asciidoc/images/spring_cloud_gateway_diagram.png" alt="spring_cloud_gateway_diagram"></p>
<p>客户端向 Spring Cloud Gateway 发出请求。如果 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑。</p>
<h5 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h5><p>在一个Spring Boot项目中引入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8020</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-gateway</span><br></pre></td></tr></table></figure>

<h5 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h5><p>Spring Cloud Gateway 是通过 Spring WebFlux 的 HandlerMapping 做为底层支持来匹配到转发路由，Spring Cloud Gateway 内置了很多 Predicates 工厂，这些 Predicates 工厂通过不同的 HTTP 请求参数来匹配，多个 Predicates 工厂可以组合使用。</p>
<h6 id="时间匹配"><a href="#时间匹配" class="headerlink" title="时间匹配"></a>时间匹配</h6><ul>
<li>After Route Predicate Factory</li>
</ul>
<p>在 application.yml 中配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: after_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - After&#x3D;2019-04-01T00:00:00.000+08:00[Asia&#x2F;Shanghai]</span><br></pre></td></tr></table></figure>
<p>该断言指定只有在19-04-01以后的请求才转发到lyyljs.site。这里比较的时间是ZonedDateTime类。</p>
<ul>
<li>Before Route Predicate Factory</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: after_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Before&#x3D;2019-04-01T00:00:00.000+08:00[Asia&#x2F;Shanghai]</span><br></pre></td></tr></table></figure>
<p>该配置指定在19-04-01之前的请求转发到指定网址。</p>
<ul>
<li>Between Route Predicate Factory</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: after_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Between&#x3D;2019-04-01T00:00:00.000+08:00[Asia&#x2F;Shanghai], 2019-05-01T00:00:00.000+08:00[Asia&#x2F;Shanghai]</span><br></pre></td></tr></table></figure>
<p>该断言指定在4月1日与5月1日之间的请求转发到指定地址。</p>
<h6 id="通过cookie匹配"><a href="#通过cookie匹配" class="headerlink" title="通过cookie匹配"></a>通过cookie匹配</h6><p>Cookie Route Predicate Factory接收两个参数， cookie name 和 正则表达式，路由规则会通过获取对应的 cookie 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: cookie_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Cookie&#x3D;chocolate, ch.p</span><br></pre></td></tr></table></figure>

<p>该断言会匹配cookie名为chocolate，其值与所给正则ch.p匹配。<br>使用 curl <a href="http://localhost:8020" target="_blank" rel="noopener">http://localhost:8020</a> –cookie “chocolate=chap” 测试，拉去到页面代码则匹配上，去掉cookie则404。</p>
<h6 id="通过Header匹配"><a href="#通过Header匹配" class="headerlink" title="通过Header匹配"></a>通过Header匹配</h6><p>同 Cookie Route Predicate Factory，Header Route Predicate Factory同样接收两个参数，name和对应value值的正则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: header_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Header&#x3D;X-Request-Id, \d+</span><br></pre></td></tr></table></figure>

<p>curl 进行测试 curl <a href="http://localhost:8020" target="_blank" rel="noopener">http://localhost:8020</a> -H “X-Request-Id:123”；返回页面代码则成功，去掉Header则返回404。</p>
<h6 id="通过Host匹配"><a href="#通过Host匹配" class="headerlink" title="通过Host匹配"></a>通过Host匹配</h6><p>Host Route Predicate Factory 仅接收一个参数：一个host name 模式列表，这个模式是Ant风格并以 . 号作为分隔符。它使用此参数去匹配请求中的 Host header。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: host_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Host&#x3D;**.google.com,**.github.com</span><br></pre></td></tr></table></figure>

<p>该断言匹配请求中是否包含Host Header 如<a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>, translate.google.com等。</p>
<p>使用 curl <a href="http://localhost:8020" target="_blank" rel="noopener">http://localhost:8020</a>  -H “Host: <a href="http://www.google.com&quot;进行测试。" target="_blank" rel="noopener">www.google.com&quot;进行测试。</a></p>
<h6 id="通过请求方式匹配"><a href="#通过请求方式匹配" class="headerlink" title="通过请求方式匹配"></a>通过请求方式匹配</h6><p>Method Route Predicate Factory 接收 HTTP 请求方式(GET,POST,PUT,DELETE…)作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: method_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Method&#x3D;POST</span><br></pre></td></tr></table></figure>

<p>使用 curl -X POST <a href="http://localhost:8020" target="_blank" rel="noopener">http://localhost:8020</a> 测试。</p>
<h6 id="通过请求路径匹配"><a href="#通过请求路径匹配" class="headerlink" title="通过请求路径匹配"></a>通过请求路径匹配</h6><p>Path Route Predicate Factory 接收两个参数：一个路径匹配列表和一个可选的尾随分隔符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: host_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;foo&#x2F;&#123;segment&#125;,&#x2F;bar&#x2F;&#123;segment&#125;</span><br></pre></td></tr></table></figure>

<p>该路由匹配请求路径如/foo/1 ， /foo/bar ， /bar/baz。</p>
<p>URI模版参数如例子中的segment会存储起来以供后续Filter使用，可以通过以下代码获取该值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; uriVariables &#x3D; ServerWebExchangeUtils.getPathPredicateVariables(exchange);</span><br><span class="line"></span><br><span class="line">String segment &#x3D; uriVariables.get(&quot;segment&quot;);</span><br></pre></td></tr></table></figure>

<h6 id="通过请求参数匹配"><a href="#通过请求参数匹配" class="headerlink" title="通过请求参数匹配"></a>通过请求参数匹配</h6><p>Query Route Predicate Factory 接收两个参数：param 和可选的其值正则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: query_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Query&#x3D;baz</span><br></pre></td></tr></table></figure>

<p>这条路由会匹配含参数baz的请求， 如 <a href="http://localhost:8020?baz=1" target="_blank" rel="noopener">http://localhost:8020?baz=1</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: query_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - Query&#x3D;foo, ba.</span><br></pre></td></tr></table></figure>

<p>这条路由会匹配参数名为foo，其值匹配正则ba.的请求，如 <a href="http://localhost:8020?foo=bar" target="_blank" rel="noopener">http://localhost:8020?foo=bar</a> 。</p>
<h6 id="通过请求ip地址匹配"><a href="#通过请求ip地址匹配" class="headerlink" title="通过请求ip地址匹配"></a>通过请求ip地址匹配</h6><p>RemoteAddr Route Predicate Factory 接收一个CIDR地址的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: remoteaddr_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;lyyljs.site</span><br><span class="line">        predicates:</span><br><span class="line">        - RemoteAddr&#x3D;192.168.1.1&#x2F;24</span><br></pre></td></tr></table></figure>

<p>这条路由会匹配来自 ip 为 192.168.1.1-254的请求。</p>
<h5 id="GatewayFilter-Factories"><a href="#GatewayFilter-Factories" class="headerlink" title="GatewayFilter Factories"></a>GatewayFilter Factories</h5><p>Gateway 内置了许多Filter。</p>
<p>由生命周期Filter 可分为两类，发出代理请求前的pre Filter 和 收到回应后的 post Filter。可参照前文工作流程图。</p>
<p>由应用范围Filter 可分为应用于单个或单组路由上的 GatewayFilter 和 应用于全局的 GlobalFilter。</p>
<p>截止2.1.0.release，Gateway 内置了 24 种Gateway Filter Factory 和 9 种Global Filter，详细可参见<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/multi/multi__gatewayfilter_factories.html" target="_blank" rel="noopener">GatewayFilter Factories</a> 和 <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/multi/multi__global_filters.html" target="_blank" rel="noopener">Global Filters</a>。</p>
<p>这里使用 RewritePath GatewayFilter Factory 来快速上手 Filter的使用。</p>
<h6 id="RewritePath-GatewayFilter-Factory"><a href="#RewritePath-GatewayFilter-Factory" class="headerlink" title="RewritePath GatewayFilter Factory"></a>RewritePath GatewayFilter Factory</h6><p>RewritePath GatewayFilter Factory 接收一个路径的正则参数和一个替换的参数。这里使用Java正则来重写请求路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: rewritepath_route</span><br><span class="line">        uri: http:&#x2F;&#x2F;localhost:9001</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;foo&#x2F;**</span><br><span class="line">        filters:</span><br><span class="line">        - RewritePath&#x3D;&#x2F;foo&#x2F;(?&lt;segment&gt;.*), &#x2F;hello&#x2F;$\&#123;segment&#125;</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://localhost:8020/foo/lyyljs" target="_blank" rel="noopener">http://localhost:8020/foo/lyyljs</a>, 路径将重写为 <a href="http://localhost:9001/hello/lyyljs。" target="_blank" rel="noopener">http://localhost:9001/hello/lyyljs。</a></p>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><h5 id="注册中心与负载均衡"><a href="#注册中心与负载均衡" class="headerlink" title="注册中心与负载均衡"></a>注册中心与负载均衡</h5><p>在微服务集群中，不可能每次手动指定单个实例。我们需要从注册中心自动获取。</p>
<ul>
<li>添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">   port: 8020</span><br><span class="line">   register:</span><br><span class="line">    port1: 8000</span><br><span class="line">    port2: 8001</span><br><span class="line">    port3: 8002</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: rewritepath_route</span><br><span class="line">        uri: lb:&#x2F;&#x2F;spring-cloud-consumer # 使用 lb:&#x2F;&#x2F;service 来提供负载均衡</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;foo&#x2F;**</span><br><span class="line">        filters:</span><br><span class="line">        - RewritePath&#x3D;&#x2F;foo&#x2F;(?&lt;segment&gt;.*), &#x2F;hello&#x2F;$\&#123;segment&#125;</span><br></pre></td></tr></table></figure>

<p>重启，</p>
<p>代理规则：/serviceId/(?<remaining>.*),会转换为/${remaining}。如访问<a href="http://localhost:8020/SPRING-CLOUD-CONSUMER/hello/lyyljs会经过负载均衡访问spring-cloud-consumer服务的/hello/lyyljs。" target="_blank" rel="noopener">http://localhost:8020/SPRING-CLOUD-CONSUMER/hello/lyyljs会经过负载均衡访问spring-cloud-consumer服务的/hello/lyyljs。</a></p>
<p>在重写路径规则下，访问<a href="http://localhost:8020/foo/lyyljs可获得正常响应信息。" target="_blank" rel="noopener">http://localhost:8020/foo/lyyljs可获得正常响应信息。</a></p>
<h5 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h5><p>使用 Retry GatewayFilter Factory 来进行重试。<br>参数列表</p>
<ul>
<li>retries 重试次数</li>
<li>statuses 什么响应码时重试，参见 org.springframework.http.HttpStatus</li>
<li>methods 指定哪些方法的请求需要进行重试逻辑，参见 org.springframework.http.HttpMethod；默认 GET</li>
<li>series 哪列状态码才进行重试，参见 org.springframework.http.HttpStatus.Series；默认是 SERVER_ERROR，即状态码为5xx时。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: rewritepath_route</span><br><span class="line">        uri: lb:&#x2F;&#x2F;spring-cloud-consumer</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;foo&#x2F;**</span><br><span class="line">        filters:</span><br><span class="line">        - RewritePath&#x3D;&#x2F;foo&#x2F;(?&lt;segment&gt;.*), &#x2F;hello&#x2F;$\&#123;segment&#125;</span><br><span class="line">        - name: Retry</span><br><span class="line">          args:</span><br><span class="line">            retries: 3</span><br><span class="line">            statuses: BAD_GATEWAY</span><br></pre></td></tr></table></figure>

<h5 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h5><p>Spring Cloud Gateway 同样可以通过使用 Hystrix 来进行熔断以及降级。</p>
<ul>
<li>添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加fallback方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;fallback&quot;)</span><br><span class="line">  public Mono&lt;String&gt; fallback() &#123;</span><br><span class="line">      return Mono.just(&quot;msg: fallback&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加配置</li>
</ul>
<p>通过配置使用 Hystrix GatewayFilter Factory 来启用 Hystrix。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-gateway</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: fallbacktest</span><br><span class="line">        uri: lb:&#x2F;&#x2F;spring-cloud-consumer</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;sleep</span><br><span class="line">        filters:</span><br><span class="line">        - name: Hystrix</span><br><span class="line">          args:</span><br><span class="line">            name: sleepfail</span><br><span class="line">            fallbackUri: forward:&#x2F;fallback</span><br><span class="line"></span><br><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    default:</span><br><span class="line">      circuitBreaker:</span><br><span class="line">        requestVolumeThreshold: 3</span><br><span class="line">      execution:</span><br><span class="line">        timeout:</span><br><span class="line">          enabled: true</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 10</span><br></pre></td></tr></table></figure>

<ul>
<li>启动测试</li>
</ul>
<p>访问<a href="http://localhost:8020/sleep，得到fallback信息。" target="_blank" rel="noopener">http://localhost:8020/sleep，得到fallback信息。</a></p>
<h5 id="限速"><a href="#限速" class="headerlink" title="限速"></a>限速</h5><p>可以使用 RequestRateLimiter GatewayFilter Factory 来进行限速。</p>
<p>RequestRateLimiter使用RateLimiter实现是否允许继续执行当前请求。如果不允许继续执行，则返回HTTP 429 - Too Many Requests （默认情况下）。</p>
<p>Redis RateLimiter 基于 <a href="https://stripe.com/blog/rate-limiters" target="_blank" rel="noopener">Stripe</a> 实现，使用的是桶令牌算法。</p>
<p>使用以下步骤快速添加一个限速策略。</p>
<ul>
<li>添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加限流键的解析器</li>
</ul>
<p>这里根据host address进行限流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">KeyResolver hostAddrKeyResolver() &#123;</span><br><span class="line">    return exchange -&gt; Mono.just(</span><br><span class="line">        exchange.getRequest()</span><br><span class="line">        .getRemoteAddress()</span><br><span class="line">        .getAddress().getHostAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加配置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-gateway</span><br><span class="line">  redis:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 6379</span><br><span class="line">    pass: 123456</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      discovery:</span><br><span class="line">        locator:</span><br><span class="line">          enabled: true</span><br><span class="line">      routes:</span><br><span class="line">      - id: fallbacktest</span><br><span class="line">        uri: lb:&#x2F;&#x2F;spring-cloud-consumer</span><br><span class="line">        predicates:</span><br><span class="line">        - Path&#x3D;&#x2F;sleep</span><br><span class="line">        filters:</span><br><span class="line">        - name: RequestRateLimiter</span><br><span class="line">          args:</span><br><span class="line">            redis-rate-limter.replenishRate: 1 #允许用户每秒处理多少个请求;令牌桶的填充速率。</span><br><span class="line">            redis-rate-limiter.burstCapacity: 2 # 令牌桶的容量，允许在一秒钟内完成的最大请求数</span><br><span class="line">            key-resolver: &quot;#&#123;@addrKeyResolver&#125;&quot; # 用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#&#123;@beanName&#125;从 Spring 容器中获取 Bean 对象</span><br></pre></td></tr></table></figure>

<ul>
<li>启动测试</li>
</ul>
<p>访问<a href="http://localhost:8020/sleep，正常返回。频繁刷新则会失败。" target="_blank" rel="noopener">http://localhost:8020/sleep，正常返回。频繁刷新则会失败。</a></p>
<hr>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://blog.csdn.net/ityouknow/article/details/83508748" target="_blank" rel="noopener">API网关性能比较：NGINX vs. ZUUL vs. Spring Cloud Gateway vs. Linkerd(未)</a></li>
<li><a href="https://www.jianshu.com/p/a19e24a6a747" target="_blank" rel="noopener">纠错帖：Zuul &amp; Spring Cloud Gateway &amp; Linkerd性能对比
</a></li>
<li><a href="https://github.com/spencergibb/spring-cloud-gateway-bench" target="_blank" rel="noopener">Spring Cloud Gateway Benchmark</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html" target="_blank" rel="noopener">Spring Cloud Gateway Document</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/04/03/spring-cloud%E5%AE%9E%E8%B7%B5-%E5%85%AD-gateway/" data-id="ckaqo6uz5001928o658qga0s1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-cloud实践-五-config" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/spring-cloud%E5%AE%9E%E8%B7%B5-%E4%BA%94-config/" class="article-date">
  <time datetime="2019-04-01T15:22:53.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/spring-cloud%E5%AE%9E%E8%B7%B5-%E4%BA%94-config/">spring cloud实践(五) config</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在项目多了以后，我们需要一个配置中心来统一管理配置文件，spring cloud config应运而生。</p>
<h4 id="spring-cloud-config"><a href="#spring-cloud-config" class="headerlink" title="spring cloud config"></a>spring cloud config</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>在git上新建文件夹repo_configs；新增配置文件</p>
<ul>
<li>fooservice-dev.yml</li>
<li>fooservice-pro.yml</li>
<li>fooservice-test.yml</li>
</ul>
<p>内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello: </span><br><span class="line">   msg: hello dev&#x2F;pro&#x2F;test</span><br></pre></td></tr></table></figure>

<h5 id="spring-cloud-config-server"><a href="#spring-cloud-config-server" class="headerlink" title="spring cloud config server"></a>spring cloud config server</h5><p>新建项目config.center</p>
<ul>
<li>添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8011</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-config-center</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      server:</span><br><span class="line">        git:</span><br><span class="line">          #uri: git@github.com:lyyljs&#x2F;eureka.git  # 配置git仓库的地址</span><br><span class="line">          uri: https:&#x2F;&#x2F;github.com&#x2F;lyyljs&#x2F;eureka.git</span><br><span class="line">          search-paths: repo_configs   # git仓库地址下的相对地址，可以配置多个，用,分割。</span><br><span class="line">          username: lyyljs # git 用户名</span><br><span class="line">          password:  # git 密码 使用https协议时使用</span><br><span class="line">#          ignoreLocalSshSettings: true # 是否忽略默认的ssh配置，默认会使用~&#x2F;.ssh&#x2F;known_hosts，etc&#x2F;ssh&#x2F;ssh_config  </span><br><span class="line">#          hostKey: id_eclipse_rsa # 使用自定义的 hostKey</span><br><span class="line">#          hostKeyAlgorithm: ssh-rsa # 自定义的算法</span><br><span class="line">#          privateKey: # 私钥内容</span><br><span class="line">          #knownHostsFile: # knownHost文件位置</span><br></pre></td></tr></table></figure>

<ul>
<li>启动类添加注解 @EnableConfigServer</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableConfigServer</span><br><span class="line">public class ConfigCenterApplication &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>启动查看抓取是否成功<br><img src="/images/cloud/config_web_content.jpg" alt="config_server_load_test"></p>
</li>
<li><p>路径转换规则</p>
</li>
</ul>
<p>仓库中的配置文件会被转换成web接口，访问可以参照以下的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#123;application&#125;&#x2F;&#123;profile&#125;[&#x2F;&#123;label&#125;]</span><br><span class="line">&#x2F;&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">&#x2F;&#123;label&#125;&#x2F;&#123;application&#125;-&#123;profile&#125;.yml</span><br><span class="line">&#x2F;&#123;application&#125;-&#123;profile&#125;.properties</span><br><span class="line">&#x2F;&#123;label&#125;&#x2F;&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>

<h5 id="spring-cloud-config-client"><a href="#spring-cloud-config-client" class="headerlink" title="spring cloud config client"></a>spring cloud config client</h5><p>修改producer项目</p>
<ul>
<li><p>添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-config-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加配置文件</p>
</li>
</ul>
<p>需要添加 bootstrap.yml ， spring cloud config 默认会从中读取相关信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">     config:</span><br><span class="line">        name: fooservice # 参照转换规则 &#123;application&#125;</span><br><span class="line">        profile: dev # 参照转换规则 &#123;profile&#125;</span><br><span class="line">        uri: http:&#x2F;&#x2F;localhost:8011&#x2F; # 配置中心的具体地址</span><br><span class="line">        label: master # git分支</span><br><span class="line">     	discovery:</span><br><span class="line">         enabled: false # 是否使用发现服务如eureka来定位config center，默认false</span><br><span class="line">         #serviceId: configserver  # 定义该服务id，默认configcenter</span><br></pre></td></tr></table></figure>

<ul>
<li>注解</li>
</ul>
<p>无需添加额外注解</p>
<ul>
<li>新增接口以测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;hello.msg&#125;&quot;)</span><br><span class="line">private String helloMsg;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;&#x2F;say&#x2F;hello&quot;)</span><br><span class="line">public String sayHello() &#123;</span><br><span class="line">	return helloMsg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<p><img src="/images/cloud/config_load_test.jpg" alt="config_load_test"></p>
<h4 id="spring-cloud-config-高可用"><a href="#spring-cloud-config-高可用" class="headerlink" title="spring cloud config 高可用"></a>spring cloud config 高可用</h4><p>为 spring cloud config server 集群使用注册中心 eureka</p>
<h5 id="spring-cloud-config-server-1"><a href="#spring-cloud-config-server-1" class="headerlink" title="spring cloud config server"></a>spring cloud config server</h5><ul>
<li>添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8011</span><br><span class="line">  register:</span><br><span class="line">    port1: 8000</span><br><span class="line">    port2: 8001</span><br><span class="line">    port3: 8002</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为启动类添加注解 @EnableDiscoveryClient</p>
</li>
<li><p>启动，在eureka控制台查看，可以看到config center已经注册到了eureka</p>
</li>
</ul>
<p><img src="/images/cloud/configCenterWithEureka.jpg" alt="configCenterWithEureka"></p>
<h5 id="spring-cloud-config-client-1"><a href="#spring-cloud-config-client-1" class="headerlink" title="spring cloud config client"></a>spring cloud config client</h5><ul>
<li>配置文件</li>
</ul>
<p>修改 bootstrap.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-producer</span><br><span class="line">  cloud:</span><br><span class="line">     config:</span><br><span class="line">        name: fooservice # 参照规则 &#123;application&#125;</span><br><span class="line">        profile: dev # 参照规则 &#123;profile&#125;</span><br><span class="line">        #uri: http:&#x2F;&#x2F;localhost:8011&#x2F; # 配置中心的具体地址</span><br><span class="line">        label: master # git分支</span><br><span class="line">        discovery:</span><br><span class="line">         enabled: true # 是否使用发现服务如eureka来定位config center，默认false</span><br><span class="line">         serviceId: spring-cloud-config-center  # 定义该服务id，默认configcenter</span><br><span class="line">         </span><br><span class="line">server:</span><br><span class="line">  #port: 9000</span><br><span class="line">  #port: 8999</span><br><span class="line">  port: 8998</span><br><span class="line">  register:</span><br><span class="line">    port1: 8000</span><br><span class="line">    port2: 8001</span><br><span class="line">    port3: 8002</span><br><span class="line">         </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>enruka配置等从 application.yml 移至 bootstrap.yml</p>
<ul>
<li>启动验证</li>
</ul>
<p><img src="/images/cloud/config_load_test.jpg" alt="config_load_test"></p>
<h4 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h4><p>在启动producer后，如果更改了配置文件，producer内仍然是启动时的值，现在改造producer让它更改配置文件后刷新。</p>
<ul>
<li>添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>暴露refresh接口</li>
</ul>
<p>在application.yml中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">   endpoints:</span><br><span class="line">      web:</span><br><span class="line">         exposure:</span><br><span class="line">            include: refresh</span><br></pre></td></tr></table></figure>

<ul>
<li>添加需要refresh的类</li>
</ul>
<p>在 HelloController 上添加注解 @RefreshScope</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RefreshScope</span><br><span class="line">@RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>启动验证</p>
<ul>
<li>访问 <a href="http://localhost:8998/hello/say/hello" target="_blank" rel="noopener">http://localhost:8998/hello/say/hello</a> ， 显示内容为 hello dev；</li>
<li>更新 git 文件 fooservice-dev.yml , 内容修改为 hello dev 1</li>
<li>Post 访问 <a href="http://localhost:8998/actuator/refresh（" target="_blank" rel="noopener">http://localhost:8998/actuator/refresh（</a> eg：curl -X POST <a href="http://localhost:8998/actuator/refresh）" target="_blank" rel="noopener">http://localhost:8998/actuator/refresh）</a></li>
<li>再次访问 <a href="http://localhost:8998/hello/say/hello，" target="_blank" rel="noopener">http://localhost:8998/hello/say/hello，</a> 内容已更改为 hello dev 1</li>
</ul>
<p><img src="/images/cloud/refresh_config.jpg" alt="refresh_config"></p>
</li>
</ul>
<h4 id="spring-cloud-bus"><a href="#spring-cloud-bus" class="headerlink" title="spring cloud bus"></a>spring cloud bus</h4><p>在更新配置后，如果有多个项目，每个项目都得访问一次refresh接口。spring cloud bus 可以让我们从这个重复的劳动中解放出来。</p>
<p>spring cloud bus需要mq的支持，mq需要支持acmq协议或者使用kafka。</p>
<p>这里使用rabbit mq。</p>
<h5 id="对应用进行改造"><a href="#对应用进行改造" class="headerlink" title="对应用进行改造"></a>对应用进行改造</h5><ul>
<li>添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  		&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">  		&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加rabbit mq配置</li>
</ul>
<p>在application.yml中添加mq配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">   rabbitmq:</span><br><span class="line">    host: localhost</span><br><span class="line">    port: 5672</span><br><span class="line">    username: guest</span><br><span class="line">    password: guest</span><br></pre></td></tr></table></figure>

<h5 id="对config-server改造"><a href="#对config-server改造" class="headerlink" title="对config server改造"></a>对config server改造</h5><ul>
<li>添加依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  		&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">  		&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件</li>
</ul>
<p>暴露bus-refresh接口，添加mq配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">   endpoints:</span><br><span class="line">      web:</span><br><span class="line">         exposure:</span><br><span class="line">            include: bus-refresh</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-config-center</span><br><span class="line">  rabbitmq:</span><br><span class="line">     host: localhost</span><br><span class="line">     port: 5672</span><br><span class="line">     username: guest</span><br><span class="line">     password: guest</span><br></pre></td></tr></table></figure>

<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><ul>
<li><p>启动config center，并分别使用8998，8999端口启动producer；</p>
</li>
<li><p>访问 <a href="http://localhost:8998/hello/say/hello，http://localhost:8999/hello/say/hello；显示信息" target="_blank" rel="noopener">http://localhost:8998/hello/say/hello，http://localhost:8999/hello/say/hello；显示信息</a> hello dev 1；</p>
</li>
<li><p>更新git上的配置文件，内容为 hello dev bus update；</p>
</li>
<li><p>curl -X POST <a href="http://localhost:8011/actuator/bus-refresh" target="_blank" rel="noopener">http://localhost:8011/actuator/bus-refresh</a> 手动触发bus事件（如果配置了git的wenbook则自动触发）</p>
</li>
<li><p>再次访问 <a href="http://localhost:8998/hello/say/hello，http://localhost:8999/hello/say/hello；显示信息" target="_blank" rel="noopener">http://localhost:8998/hello/say/hello，http://localhost:8999/hello/say/hello；显示信息</a> hello dev bus update，成功更新配置</p>
</li>
</ul>
<p><img src="/images/cloud/config_bus_update.jpg" alt="bus_refresh_config"></p>
<hr>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-config/2.1.0.RELEASE/single/spring-cloud-config.html#_spring_cloud_config_client" target="_blank" rel="noopener">spring cloud config文档</a></p>
</li>
<li><p><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-bus/2.1.0.RELEASE/single/spring-cloud-bus.html" target="_blank" rel="noopener">spring cloud bus文档</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/04/01/spring-cloud%E5%AE%9E%E8%B7%B5-%E4%BA%94-config/" data-id="ckaqo6uzb001h28o66uhu2guz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-cloud实践-四-hystrix" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/30/spring-cloud%E5%AE%9E%E8%B7%B5-%E5%9B%9B-hystrix/" class="article-date">
  <time datetime="2019-03-30T18:24:00.000Z" itemprop="datePublished">2019-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/30/spring-cloud%E5%AE%9E%E8%B7%B5-%E5%9B%9B-hystrix/">spring cloud实践(四) hystrix</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hystrix为我们提供了资源隔离，熔断降级的功能。</p>
<h4 id="降级测试"><a href="#降级测试" class="headerlink" title="降级测试"></a>降级测试</h4><ul>
<li>依赖</li>
</ul>
<p>因使用了 Feign ，其本身依赖与 Hystrix，这里便不需修改依赖文件；否则添加依赖。</p>
<ul>
<li>配置文件</li>
</ul>
<p>修改配置文件，启用 Hystrix，这里为了测试将 timeout 时间修改较小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  threadpool:</span><br><span class="line">    hello:	# 对hello服务进行配置</span><br><span class="line">      coreSize: 20 # 修改其核心线程熟练为20</span><br><span class="line">  command:</span><br><span class="line">    hello:</span><br><span class="line">      circuitBreaker:</span><br><span class="line">        requestVolumeThreshold: 20 # 修改阈值为20，测试熔断可修改更小</span><br><span class="line">      execution:</span><br><span class="line">        timeout:</span><br><span class="line">          enabled: true # 执行超时开启</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 1000 # 线程超时设定为 1000</span><br><span class="line"></span><br><span class="line">feign:</span><br><span class="line">  hystrix:</span><br><span class="line">    enabled: true # 开启 hystrix</span><br></pre></td></tr></table></figure>

<ul>
<li>添加并配置降级方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class HelloServiceHystrix implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String sleep() &#123;</span><br><span class="line">		return &quot;sleep failed&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在注解中指定降级类，失败时会去执行同名方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name &#x3D; &quot;spring-cloud-producer&quot;,</span><br><span class="line">				path &#x3D; &quot;&#x2F;hello&quot;,</span><br><span class="line">				fallback &#x3D; HelloServiceHystrix.class)</span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试</li>
</ul>
<p>开启consumer, enreka, producer(可不开启)，访问 <a href="http://localhost:9001/sleep。" target="_blank" rel="noopener">http://localhost:9001/sleep。</a></p>
<p><img src="/images/cloud/fallbacktest.jpg" alt="fallbacktest"></p>
<p>看到这里不是抛出的错误信息而是我们在降级方法中返回的信息。</p>
<h4 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h4><p>hystrix 的相关信息(健康度)可以通过 spring boot actuator 暴露出来，然后通过 hystrix dashboard 可视化查看监控信息。</p>
<ul>
<li>开启 actuator, 暴露 hystrix.stream</li>
</ul>
<p>在依赖文件中添加相关组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">      	&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">  	&lt;&#x2F;dependency&gt;</span><br><span class="line">  	&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加 spring-cloud-starter-netflix-hystrix 是为了添加 hystrix-metrics-event-stream 启用监控。</p>
<p>然后修改配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">management:</span><br><span class="line">   endpoints:</span><br><span class="line">      web:</span><br><span class="line">         exposure:</span><br><span class="line">            include: hystrix.stream</span><br></pre></td></tr></table></figure>
<p>将 相关信息 加入 actuator 的 endpoints 暴露出来。</p>
<p>最后在启动类增加注解 @EnableCircuitBreaker 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">@EnableCircuitBreaker</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ConsumerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目，访问任意接口后再访问 /actuator/hystrix.stream 查看。</p>
<p><img src="/images/cloud/hystrix_stream.jpg" alt="hystrix_stream"></p>
<ul>
<li>通过 Dashboard 查看 Hystrix Stream</li>
</ul>
<p>新建项目hystrix.dashboard，并添加依赖</p>
<p>依赖文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;2.1.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line">	&lt;groupId&gt;lyyljs.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;hystrix.dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;name&gt;hystrix.dashboard&lt;&#x2F;name&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">		&lt;spring-cloud.version&gt;Greenwich.SR1&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>配置服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: hystrix-dashboard</span><br><span class="line">server:</span><br><span class="line">  port: 8010</span><br></pre></td></tr></table></figure>

<p>在启动类添加注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(Application.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动，访问<a href="http://localhost:8010/hystrix。" target="_blank" rel="noopener">http://localhost:8010/hystrix。</a></p>
<p><img src="/images/cloud/hystrix_dashboard_console.png" alt="hystrix_dashboard"></p>
<p>填写要hystrix.stream的地址，设定delay,title，进入监控。</p>
<p><img src="/images/cloud/hystrix_stream_monitor.jpg" alt="hystrix_stream_monitor"></p>
<p>具体含义参考wiki:<br><img src="https://raw.githubusercontent.com/wiki/Netflix/Hystrix/images/dashboard-annoted-circuit-640.png" alt="dashboard-annoted-circuit"></p>
<h4 id="Turbine"><a href="#Turbine" class="headerlink" title="Turbine"></a>Turbine</h4><p>对op来说，我们更希望能监控整个系统的数据。Turbine 将 hystrix stream 聚合为 turbine stream 从而可以展示整个系统的状况，并且支持eureka自动发现。</p>
<p>修改项目hystrix.dashboard</p>
<ul>
<li><p>添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: hystrix-dashboard</span><br><span class="line">server:</span><br><span class="line">  port: 8010</span><br><span class="line">  register:</span><br><span class="line">    port1: 8000</span><br><span class="line">    port2: 8001</span><br><span class="line">    port3: 8002</span><br><span class="line">    </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;</span><br><span class="line"></span><br><span class="line">turbine:</span><br><span class="line">   aggregator:</span><br><span class="line">      clusterConfig: default # 指定聚合哪些集群，多个使用&quot;,&quot;分割，默认为default。可使用http:&#x2F;&#x2F;...&#x2F;turbine.stream?cluster&#x3D;&#123;clusterConfig之一&#125;访问</span><br><span class="line">   appConfig: spring-cloud-consumer # 配置Eureka中的serviceId列表，表明监控哪些服务</span><br><span class="line">   clusterNameExpression: &quot;&#39;default&#39;&quot;</span><br><span class="line">     # 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称</span><br><span class="line">     # 2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default</span><br><span class="line">     # 3. 当clusterNameExpression: metadata[&#39;cluster&#39;]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC</span><br></pre></td></tr></table></figure>

<ul>
<li>在启动类添加注解 @EnableTurbine</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">@EnableTurbine</span><br><span class="line">public class Application &#123;</span><br></pre></td></tr></table></figure>

<p>启动，访问 <a href="http://localhost:8010/turbine.stream" target="_blank" rel="noopener">http://localhost:8010/turbine.stream</a> 查看聚合信息</p>
<p><img src="/images/cloud/turbine_stream.png" alt="turbine_stream"></p>
<p>将turbine.stream地址填写在hystrix dashboard中，则可在 hystrix dashboard 中查看可视化信息</p>
<p><img src="/images/cloud/turbine_stream_monitor.jpg" alt="turbine_stream_monitor"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/30/spring-cloud%E5%AE%9E%E8%B7%B5-%E5%9B%9B-hystrix/" data-id="ckaqo6uz7001c28o6dh1sfvek" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-服务容错-二-熔断，降级，限流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99-%E4%BA%8C-%E7%86%94%E6%96%AD%EF%BC%8C%E9%99%8D%E7%BA%A7%EF%BC%8C%E9%99%90%E6%B5%81/" class="article-date">
  <time datetime="2019-03-29T11:38:00.000Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99-%E4%BA%8C-%E7%86%94%E6%96%AD%EF%BC%8C%E9%99%8D%E7%BA%A7%EF%BC%8C%E9%99%90%E6%B5%81/">服务容错(二) 熔断降级</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p>当某个服务持续不可用时，我们不希望继续调用它造成其他服务卡住不可用；此时超时机制并不能改善该状况，会导致整个调用链时间增长且增大负载，而重试机制更会恶化该状况，此时就需要熔断了。</p>
<p>熔断在服务持续不可用时，从消费者的可用服务提供者的列表中将该服务提供者标记为短路状态，在调用时忽略该提供者以避免上述提及状况。</p>
<p>降级则是在服务提供者不可用时进行本地操作调用。</p>
<h5 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h5><p>Dubbo本身并未提供熔断机制，仅提供简单的降级操作，通过配置mock值：</p>
<ul>
<li>return =&gt; return null</li>
<li>fail =&gt; default</li>
<li>force =&gt; default</li>
<li>fail:throw/return foo =&gt; throw/return foo</li>
<li>force:throw/return foo =&gt; throw/return foo</li>
<li>fail/force:className =&gt; className::method()</li>
</ul>
<p>这里的返回foo可以是对应的json字符串，true，false，null，数字，字符串…</p>
<p>其中 <strong>default</strong> 会去寻找 <strong>fooServiceMock</strong>类 下的同名方法来执行。如果指定了类，则执行对应类的同名方法。</p>
<p>其实现在<strong>org.apache.dubbo.rpc.cluster.support.wrapper</strong>包下的<strong>MockClusterInvoker</strong>类中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class MockClusterInvoker&lt;T&gt; implements Invoker&lt;T&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">	public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        Result result &#x3D; null;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从配置中获取mock参数值</span><br><span class="line">        String value &#x3D; directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();</span><br><span class="line">        &#x2F;&#x2F; 服务提供者未设定或设定为false则直接进行rpc调用</span><br><span class="line">        if (value.length() &#x3D;&#x3D; 0 || value.equalsIgnoreCase(&quot;false&quot;)) &#123;</span><br><span class="line">            &#x2F;&#x2F;no mock</span><br><span class="line">            result &#x3D; this.invoker.invoke(invocation);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 服务提供者设定为强制使用本地mock</span><br><span class="line">        &#125; else if (value.startsWith(&quot;force&quot;)) &#123;</span><br><span class="line">            if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(&quot;force-mock: &quot; + invocation.getMethodName() + &quot; force-mock enabled , url : &quot; + directory.getUrl());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;force:direct mock</span><br><span class="line">            result &#x3D; doMockInvoke(invocation, null);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 正常调用，在失败后才降级</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;fail-mock</span><br><span class="line">            try &#123;</span><br><span class="line">                result &#x3D; this.invoker.invoke(invocation);</span><br><span class="line">            &#125; catch (RpcException e) &#123;</span><br><span class="line">                if (e.isBiz()) &#123;</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(&quot;fail-mock: &quot; + invocation.getMethodName() + &quot; fail-mock enabled , url : &quot; + directory.getUrl(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 失败后的降级调用</span><br><span class="line">                &#x2F;&#x2F; 寻找对应的mockInvoker调用invoke</span><br><span class="line">                result &#x3D; doMockInvoke(invocation, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mock进行调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">final public class MockInvoker&lt;T&gt; implements Invoker&lt;T&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">	public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    	&#x2F;&#x2F; 获取url中mock属性</span><br><span class="line">        String mock &#x3D; getUrl().getParameter(invocation.getMethodName() + &quot;.&quot; + Constants.MOCK_KEY);</span><br><span class="line">        if (invocation instanceof RpcInvocation) &#123;</span><br><span class="line">            ((RpcInvocation) invocation).setInvoker(this);</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isBlank(mock)) &#123;</span><br><span class="line">            mock &#x3D; getUrl().getParameter(Constants.MOCK_KEY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (StringUtils.isBlank(mock)) &#123;</span><br><span class="line">            throw new RpcException(new IllegalAccessException(&quot;mock can not be null. url :&quot; + url));</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 解析并修正mock参数</span><br><span class="line">        &#x2F;&#x2F; 将fail&#x2F;force去掉，如果未设置参数则改为default&#x2F;null etc</span><br><span class="line">        &#x2F;&#x2F; eg. fail:throw&#x2F;return foo &#x3D;&gt; throw&#x2F;return foo</span><br><span class="line">        mock &#x3D; normalizeMock(URL.decode(mock));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; return行为</span><br><span class="line">        if (mock.startsWith(Constants.RETURN_PREFIX)) &#123;</span><br><span class="line">            mock &#x3D; mock.substring(Constants.RETURN_PREFIX.length()).trim();</span><br><span class="line">            &#x2F;&#x2F; 将mock字符串解析为对应方法的返回值类型并返回</span><br><span class="line">            try &#123;</span><br><span class="line">                Type[] returnTypes &#x3D; RpcUtils.getReturnTypes(invocation);</span><br><span class="line">                Object value &#x3D; parseMockValue(mock, returnTypes);</span><br><span class="line">                return new RpcResult(value);</span><br><span class="line">            &#125; catch (Exception ew) &#123;</span><br><span class="line">                throw new RpcException(&quot;mock return invoke error. method :&quot; + invocation.getMethodName()</span><br><span class="line">                        + &quot;, mock:&quot; + mock + &quot;, url: &quot; + url, ew);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 抛出行为</span><br><span class="line">        &#125; else if (mock.startsWith(Constants.THROW_PREFIX)) &#123;</span><br><span class="line">            mock &#x3D; mock.substring(Constants.THROW_PREFIX.length()).trim();</span><br><span class="line">            &#x2F;&#x2F; mock空时抛出默认异常信息</span><br><span class="line">            if (StringUtils.isBlank(mock)) &#123;</span><br><span class="line">                throw new RpcException(&quot;mocked exception for service degradation.&quot;);</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; user customized class</span><br><span class="line">            	&#x2F;&#x2F; mock作为类名，获取该异常类进行抛出</span><br><span class="line">                &#x2F;&#x2F; 如果throws缓存小于1000（硬编码）则将该异常类缓存</span><br><span class="line">                Throwable t &#x3D; getThrowable(mock);</span><br><span class="line">                throw new RpcException(RpcException.BIZ_EXCEPTION, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行自定义类</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;impl mock</span><br><span class="line">            try &#123;</span><br><span class="line">            	&#x2F;&#x2F; 如果mock为default或空，则寻找fooServiceMock类下的同名方法，否则寻找类名为mock的同名方法</span><br><span class="line">                &#x2F;&#x2F; 如果mocks缓存数量小于10000（硬编码）还会将该mockInvoker进行缓存</span><br><span class="line">                Invoker&lt;T&gt; invoker &#x3D; getInvoker(mock);</span><br><span class="line">                return invoker.invoke(invocation);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                throw new RpcException(&quot;Failed to create mock implementation class &quot; + mock, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>Hystrix 是 Netflix 公司为解决分布式服务容错所提供的一个组件，它也提供了熔断降级的功能。</p>
<h5 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h5><p><img src="/images/cloud/hystrix-command-flow-chart.png" alt="hystrix-command-flow-chart"></p>
<p>上图是 Hystrix 的流程图，当发起一个请求时：</p>
<p>1.构建一个 Command </p>
<p>构建 Command 对象，把依赖调用封装进 run 方法中；它可以是 HystrixCommand 来处理单个响应，或使用 HystrixObservableCommand 来处理一系列的观察事件（参见RxJava）。但事实上，HystrixCommand 最终仍然是通过 Observable 来实现的。</p>
<p>2.调用方法执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">K             value   &#x3D; command.execute(); &#x2F;&#x2F; 阻塞</span><br><span class="line">Future&lt;K&gt;     fValue  &#x3D; command.queue();	&#x2F;&#x2F; 异步</span><br><span class="line">Observable&lt;K&gt; ohValue &#x3D; command.observe();         &#x2F;&#x2F;hot observable 参见RxJava</span><br><span class="line">Observable&lt;K&gt; ocValue &#x3D; command.toObservable();    &#x2F;&#x2F;cold observable 参见RxJava</span><br></pre></td></tr></table></figure>

<p>3.查询本地缓存</p>
<p>如果该 Command 的本地缓存开启，则查询本地缓存，如命中则直接返回。</p>
<p>4.短路状态查询</p>
<p>如果短路，则直接跳到第8步，进行降级操作。</p>
<p>5.容量查询</p>
<p>查询线程池/队列/信号量是否有足够的资源执行 Command ，如无，则跳至 8 ，进行降级操作。</p>
<p>6.执行 Command</p>
<p>执行操作，如果执行失败或超时，则跳至 8 ，进行降级操作。</p>
<p>7.结果反馈</p>
<p>将5，6的执行结果反馈，计入状态统计。如果达到熔断指标则将服务短路。</p>
<p>8.降级</p>
<p>执行降级操作，如果没有降级方法或降级方法执行失败，则抛出错误。</p>
<p>9.返回结果</p>
<h5 id="熔断机制"><a href="#熔断机制" class="headerlink" title="熔断机制"></a>熔断机制</h5><p>下面的图展示了HystrixCommand和HystrixObservableCommand如何与HystrixCircuitBroker进行交互。</p>
<p><img src="/images/cloud/circuit-breaker.png" alt="circuit-breaker.png"></p>
<p>短路逻辑如下：</p>
<ol>
<li><p>请求满足了一定的阈值（HystrixCommandProperties.circuitBreakerRequestVolumeThreshold()）</p>
</li>
<li><p>错误发生所占的百分比超过了设定的错误发生的阈值（HystrixCommandProperties.circuitBreakerErrorThresholdPercentage()）</p>
</li>
<li><p>短路器状态由CLOSE转为OPEN</p>
</li>
<li><p>当短路器状态转为OPEN，则熔断所有的请求</p>
</li>
<li><p>一定时间之后HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()，下一个的请求会被通过（Half Open），如果该请求执行失败，回路器会在睡眠窗口期间返回OPEN；如果该请求成功，重置为CLOSE，重新从1开始判断。</p>
</li>
</ol>
<p>代码其实现如下：</p>
<p>在hystrix-core项目中，<strong>AbstractCommand</strong>类下首先与短路器进行交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">private Observable&lt;R&gt; applyHystrixSemantics(final AbstractCommand&lt;R&gt; _cmd) &#123;</span><br><span class="line">       &#x2F;&#x2F; mark that we&#39;re starting execution on the ExecutionHook</span><br><span class="line">       &#x2F;&#x2F; if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent</span><br><span class="line">       executionHook.onStart(_cmd);</span><br><span class="line"></span><br><span class="line">       &#x2F;* determine if we&#39;re allowed to execute *&#x2F;</span><br><span class="line">       &#x2F;&#x2F; 短路器是否允许请求，参见流程图右上</span><br><span class="line">       &#x2F;&#x2F; 即是否短路</span><br><span class="line">       if (circuitBreaker.allowRequest()) &#123;</span><br><span class="line">       	&#x2F;&#x2F; 获取信号量</span><br><span class="line">           final TryableSemaphore executionSemaphore &#x3D; getExecutionSemaphore();</span><br><span class="line">           final AtomicBoolean semaphoreHasBeenReleased &#x3D; new AtomicBoolean(false);</span><br><span class="line">           final Action0 singleSemaphoreRelease &#x3D; new Action0() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void call() &#123;</span><br><span class="line">                   if (semaphoreHasBeenReleased.compareAndSet(false, true)) &#123;</span><br><span class="line">                       executionSemaphore.release();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">           final Action1&lt;Throwable&gt; markExceptionThrown &#x3D; new Action1&lt;Throwable&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void call(Throwable t) &#123;</span><br><span class="line">                   eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 尝试获取信号量</span><br><span class="line">           if (executionSemaphore.tryAcquire()) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;* used to track userThreadExecutionTime *&#x2F;</span><br><span class="line">                   executionResult &#x3D; executionResult.setInvocationStartTime(System.currentTimeMillis());</span><br><span class="line">                   &#x2F;&#x2F; 执行命令，并添加相应处理</span><br><span class="line">                   return executeCommandAndObserve(_cmd)</span><br><span class="line">                           .doOnError(markExceptionThrown)</span><br><span class="line">                           .doOnTerminate(singleSemaphoreRelease)</span><br><span class="line">                           .doOnUnsubscribe(singleSemaphoreRelease);</span><br><span class="line">               &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                   return Observable.error(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">           	&#x2F;&#x2F; 获取信号量失败，则进行降级处理</span><br><span class="line">               return handleSemaphoreRejectionViaFallback();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">       	&#x2F;&#x2F; 处于短路状态，进行降级处理</span><br><span class="line">           return handleShortCircuitViaFallback();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">       private Observable&lt;R&gt; executeCommandAndObserve(final AbstractCommand&lt;R&gt; _cmd) &#123;</span><br><span class="line">       final HystrixRequestContext currentRequestContext &#x3D; HystrixRequestContext.getContextForCurrentThread();</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 成功回调，重置短路状态</span><br><span class="line">       final Action0 markOnCompleted &#x3D; new Action0() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void call() &#123;</span><br><span class="line">               if (!commandIsScalar()) &#123;</span><br><span class="line">                   long latency &#x3D; System.currentTimeMillis() - executionResult.getStartTimestamp();</span><br><span class="line">                   eventNotifier.markCommandExecution(getCommandKey(), properties.executionIsolationStrategy().get(), (int) latency, executionResult.getOrderedList());</span><br><span class="line">                   eventNotifier.markEvent(HystrixEventType.SUCCESS, commandKey);</span><br><span class="line">                   executionResult &#x3D; executionResult.addEvent((int) latency, HystrixEventType.SUCCESS);</span><br><span class="line">                   circuitBreaker.markSuccess();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 失败回调，对Exception进行相应处理</span><br><span class="line">       &#x2F;&#x2F; 在handler里，则会进行降级操作(Fallback)</span><br><span class="line">       final Func1&lt;Throwable, Observable&lt;R&gt;&gt; handleFallback &#x3D; new Func1&lt;Throwable, Observable&lt;R&gt;&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Observable&lt;R&gt; call(Throwable t) &#123;</span><br><span class="line">               Exception e &#x3D; getExceptionFromThrowable(t);</span><br><span class="line">               executionResult &#x3D; executionResult.setExecutionException(e);</span><br><span class="line">               if (e instanceof RejectedExecutionException) &#123;</span><br><span class="line">                   return handleThreadPoolRejectionViaFallback(e);</span><br><span class="line">               &#125; else if (t instanceof HystrixTimeoutException) &#123;</span><br><span class="line">                   return handleTimeoutViaFallback();</span><br><span class="line">               &#125; else if (t instanceof HystrixBadRequestException) &#123;</span><br><span class="line">                   return handleBadRequestByEmittingError(e);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   &#x2F;*</span><br><span class="line">                    * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.</span><br><span class="line">                    *&#x2F;</span><br><span class="line">                   if (e instanceof HystrixBadRequestException) &#123;</span><br><span class="line">                       eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);</span><br><span class="line">                       return Observable.error(e);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   return handleFailureViaFallback(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       </span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       Observable&lt;R&gt; execution;</span><br><span class="line">       &#x2F;&#x2F; 是否开启超时设定，是则添加超时操作</span><br><span class="line">       &#x2F;&#x2F; executeCommandWithSpecifiedIsolation：</span><br><span class="line">       &#x2F;&#x2F; 线程隔离，状态判断etc...</span><br><span class="line">       if (properties.executionTimeoutEnabled().get()) &#123;</span><br><span class="line">           execution &#x3D; executeCommandWithSpecifiedIsolation(_cmd)</span><br><span class="line">                   .lift(new HystrixObservableTimeoutOperator&lt;R&gt;(_cmd));</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           execution &#x3D; executeCommandWithSpecifiedIsolation(_cmd);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return execution.doOnNext(markEmits)</span><br><span class="line">               .doOnCompleted(markOnCompleted)</span><br><span class="line">               .onErrorResumeNext(handleFallback)</span><br><span class="line">               .doOnEach(setRequestContext);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>再来看短路器 HystrixCircuitBreaker，这是个接口，其实现为HystrixCircuitBreakerImpl。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">private final HystrixCommandProperties properties;</span><br><span class="line">      private final HystrixCommandMetrics metrics;</span><br><span class="line"></span><br><span class="line">      &#x2F;* track whether this circuit is open&#x2F;closed at any given point in time (default to false&#x3D;&#x3D;closed) *&#x2F;</span><br><span class="line">      private AtomicBoolean circuitOpen &#x3D; new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line">      &#x2F;* when the circuit was marked open or was last allowed to try a &#39;singleTest&#39; *&#x2F;</span><br><span class="line">      private AtomicLong circuitOpenedOrLastTestedTime &#x3D; new AtomicLong();</span><br><span class="line">      </span><br><span class="line">      &#x2F;**</span><br><span class="line">      * 执行成功</span><br><span class="line">      * 在短路器打开时，将其关闭，并重置计数流</span><br><span class="line">      *&#x2F;</span><br><span class="line">      public void markSuccess() &#123;</span><br><span class="line">          if (circuitOpen.get()) &#123;</span><br><span class="line">              if (circuitOpen.compareAndSet(true, false)) &#123;</span><br><span class="line">                  &#x2F;&#x2F;win the thread race to reset metrics</span><br><span class="line">                  &#x2F;&#x2F;Unsubscribe from the current stream to reset the health counts stream.  This only affects the health counts view,</span><br><span class="line">                  &#x2F;&#x2F;and all other metric consumers are unaffected by the reset</span><br><span class="line">                  metrics.resetStream();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 判断是否允许请求（短路）</span><br><span class="line">      public boolean allowRequest() &#123;</span><br><span class="line">      	&#x2F;&#x2F; 配置文件强制打开短路器，则拒绝所有请求</span><br><span class="line">          if (properties.circuitBreakerForceOpen().get()) &#123;</span><br><span class="line">              &#x2F;&#x2F; properties have asked us to force the circuit open so we will allow NO requests</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 配置文件强制关闭短路器，但仍然调用isOpen()方法进行统计</span><br><span class="line">          if (properties.circuitBreakerForceClosed().get()) &#123;</span><br><span class="line">              &#x2F;&#x2F; we still want to allow isOpen() to perform it&#39;s calculations so we simulate normal behavior</span><br><span class="line">              isOpen();</span><br><span class="line">              &#x2F;&#x2F; properties have asked us to ignore errors so we will ignore the results of isOpen and just allow all traffic through</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line">          return !isOpen() || allowSingleTest();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      public boolean isOpen() &#123;</span><br><span class="line">      	&#x2F;&#x2F; 获取短路器状态，如果打开则直接返回</span><br><span class="line">          if (circuitOpen.get()) &#123;</span><br><span class="line">              &#x2F;&#x2F; if we&#39;re open we immediately return true and don&#39;t bother attempting to &#39;close&#39; ourself as that is left to allowSingleTest and a subsequent successful test to close</span><br><span class="line">              return true;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; we&#39;re closed, so let&#39;s see if errors have made us so we should trip the circuit open</span><br><span class="line">          &#x2F;&#x2F; 获取计数器</span><br><span class="line">          HealthCounts health &#x3D; metrics.getHealthCounts();</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; check if we are past the statisticalWindowVolumeThreshold</span><br><span class="line">          &#x2F;&#x2F; 检查请求总数是否大于阈值</span><br><span class="line">          if (health.getTotalRequests() &lt; properties.circuitBreakerRequestVolumeThreshold().get()) &#123;</span><br><span class="line">              &#x2F;&#x2F; we are not past the minimum volume threshold for the statisticalWindow so we&#39;ll return false immediately and not calculate anything</span><br><span class="line">              return false;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F; 请求总数已大于阈值</span><br><span class="line">          &#x2F;&#x2F; 则检查错误百分比是否大于阈值</span><br><span class="line">          if (health.getErrorPercentage() &lt; properties.circuitBreakerErrorThresholdPercentage().get()) &#123;</span><br><span class="line">              return false;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">          	&#x2F;&#x2F; 两者都大于阈值，则将开关打开</span><br><span class="line">              &#x2F;&#x2F; our failure rate is too high, trip the circuit</span><br><span class="line">              if (circuitOpen.compareAndSet(false, true)) &#123;</span><br><span class="line">                  &#x2F;&#x2F; if the previousValue was false then we want to set the currentTime</span><br><span class="line">                  circuitOpenedOrLastTestedTime.set(System.currentTimeMillis());</span><br><span class="line">                  return true;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">              	&#x2F;&#x2F; 开关打开失败（可能其他线程打开了），但阈值仍然是超过的，所以仍然返回true</span><br><span class="line">                  &#x2F;&#x2F; How could previousValue be true? If another thread was going through this code at the same time a race-condition could have</span><br><span class="line">                  &#x2F;&#x2F; caused another thread to set it to true already even though we were in the process of doing the same</span><br><span class="line">                  &#x2F;&#x2F; In this case, we know the circuit is open, so let the other thread set the currentTime and report back that the circuit is open</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;**</span><br><span class="line">      * 是否允许单个请求进行测试（half-open）</span><br><span class="line">      * 在短路一段时间（超过睡眠窗口时间）后，允许一个请求来尝试以判断连通状态</span><br><span class="line">      *&#x2F;</span><br><span class="line">      public boolean allowSingleTest() &#123;</span><br><span class="line">      	&#x2F;&#x2F; 短路器打开时间或上次测试连通时间</span><br><span class="line">          long timeCircuitOpenedOrWasLastTested &#x3D; circuitOpenedOrLastTestedTime.get();</span><br><span class="line">          &#x2F;&#x2F; 1) if the circuit is open</span><br><span class="line">          &#x2F;&#x2F; 2) and it&#39;s been longer than &#39;sleepWindow&#39; since we opened the circuit</span><br><span class="line">          if (circuitOpen.get() &amp;&amp; System.currentTimeMillis() &gt; timeCircuitOpenedOrWasLastTested + properties.circuitBreakerSleepWindowInMilliseconds().get()) &#123;</span><br><span class="line">              &#x2F;&#x2F; We push the &#39;circuitOpenedTime&#39; ahead by &#39;sleepWindow&#39; since we have allowed one request to try.</span><br><span class="line">              &#x2F;&#x2F; If it succeeds the circuit will be closed, otherwise another singleTest will be allowed at the end of the &#39;sleepWindow&#39;.</span><br><span class="line">              &#x2F;&#x2F; 尝试更新测试时间</span><br><span class="line">              if (circuitOpenedOrLastTestedTime.compareAndSet(timeCircuitOpenedOrWasLastTested, System.currentTimeMillis())) &#123;</span><br><span class="line">                  &#x2F;&#x2F; if this returns true that means we set the time so we&#39;ll return true to allow the singleTest</span><br><span class="line">                  &#x2F;&#x2F; if it returned false it means another thread raced us and allowed the singleTest before we did</span><br><span class="line">                  return true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/29/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99-%E4%BA%8C-%E7%86%94%E6%96%AD%EF%BC%8C%E9%99%8D%E7%BA%A7%EF%BC%8C%E9%99%90%E6%B5%81/" data-id="ckaqo6uzv002b28o6cv9s0urs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-spring-cloud实践-三-ribbon" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/18/spring-cloud%E5%AE%9E%E8%B7%B5-%E4%B8%89-ribbon/" class="article-date">
  <time datetime="2019-03-18T16:18:00.000Z" itemprop="datePublished">2019-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/18/spring-cloud%E5%AE%9E%E8%B7%B5-%E4%B8%89-ribbon/">spring cloud实践(三) ribbon</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Ribbon为我们提供了软负载均衡以及一定的容错处理。关于Ribbon的负载均衡与重试机制可参见<a href="/2019/03/13/客户端负载均衡/">客户端负载均衡</a>以及<a href="/2019/03/16/服务容错-一-重试/">服务容错(一) 重试</a>。</p>
<p>现在来实践一下：</p>
<ol>
<li>服务端</li>
</ol>
<p>在服务端添加接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;&#x2F;sleep&quot;)</span><br><span class="line">    public String sleep()&#123;</span><br><span class="line">    	try &#123;</span><br><span class="line">    		int time &#x3D; ThreadLocalRandom.current().nextInt(6000);</span><br><span class="line">    		log.info(&quot;call in will sleep: &#123;&#125;&quot;, time);</span><br><span class="line">			Thread.sleep(time);</span><br><span class="line">			return &quot;port:&quot; + config.getPort() + &quot; sleep &quot; + time;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    	return &quot;port:&quot; + config.getPort() + &quot; sleep failed&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里随机休眠了一段时间(小于6 s)，并记录。然后启动三次本项目，端口分别配置在8998, 8999, 9000。</p>
<ol start="2">
<li>消费端</li>
</ol>
<p>首先对消费端进行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    hello:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 60000</span><br><span class="line">            </span><br><span class="line">spring-cloud-producer:</span><br><span class="line">  ribbon:</span><br><span class="line">    #NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList</span><br><span class="line">    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</span><br><span class="line">    ConnectTimeout: 1000 # 请求连接的超时时间</span><br><span class="line">    ReadTimeout: 1000 # 请求处理的超时时间</span><br><span class="line">    MaxTotalHttpConnections: 500 # 最大总连接数</span><br><span class="line">    MaxConnectionsPerHost: 100 # 单机连接最大数目</span><br><span class="line">    # 重试相关</span><br><span class="line">    MaxAutoRetries: 1 # 对当前实例的重试次数</span><br><span class="line">    MaxAutoRetriesNextServer: 3 # 切换实例的重试次数</span><br><span class="line">    OkToRetryOnAllOperations: true # 对所有操作请求都进行重试</span><br></pre></td></tr></table></figure>

<p>因这里使用了Feign，所以在接口类新增方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name &#x3D; &quot;spring-cloud-producer&quot;,</span><br><span class="line">				path &#x3D; &quot;&#x2F;hello&quot;)</span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">	...</span><br><span class="line">	@RequestMapping(value &#x3D; &quot;&#x2F;sleep&quot;)</span><br><span class="line">	public String sleep();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Controller新增:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ConsumerController &#123;</span><br><span class="line">	...</span><br><span class="line">    @RequestMapping(&quot;&#x2F;sleep&quot;)</span><br><span class="line">    public String sleep()&#123;</span><br><span class="line">    	return helloService.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试</li>
</ol>
<p>启动消费者，访问 <a href="http://localhost:9001/sleep。" target="_blank" rel="noopener">http://localhost:9001/sleep。</a></p>
<p><img src="/images/cloud/ribbon-test-web.png" alt="ribbon-test-web"></p>
<p>注：这里结果是不确定的因为使用了随机数。</p>
<p>然后看console：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------------&lt;端口号为9000的日志&gt;-------------------------------</span><br><span class="line">2019-03-18 16:05:10.462  INFO 11088 --- [nio-9000-exec-1] l.c.producer.controller.HelloController  : call in will sleep: 5837</span><br><span class="line">2019-03-18 16:05:11.484  INFO 11088 --- [nio-9000-exec-3] l.c.producer.controller.HelloController  : call in will sleep: 2306</span><br><span class="line">---------------------&lt;端口号为8999的日志&gt;-------------------------------</span><br><span class="line">2019-03-18 16:05:12.484  INFO 11488 --- [nio-8999-exec-8] l.c.producer.controller.HelloController  : call in will sleep: 3657</span><br><span class="line">2019-03-18 16:05:13.489  INFO 11488 --- [nio-8999-exec-5] l.c.producer.controller.HelloController  : call in will sleep: 3588</span><br><span class="line">---------------------&lt;端口号为8998的日志&gt;--------------------------------</span><br><span class="line">2019-03-18 16:05:14.491  INFO 12036 --- [nio-8998-exec-7] l.c.producer.controller.HelloController  : call in will sleep: 27</span><br></pre></td></tr></table></figure>

<p>在端口号为9000，和8999分别尝试了两次，然后再8998成功获取到数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/18/spring-cloud%E5%AE%9E%E8%B7%B5-%E4%B8%89-ribbon/" data-id="ckaqo6uyz001028o67hnl0pp8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-服务容错-一-重试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/16/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99-%E4%B8%80-%E9%87%8D%E8%AF%95/" class="article-date">
  <time datetime="2019-03-16T15:32:00.000Z" itemprop="datePublished">2019-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/16/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99-%E4%B8%80-%E9%87%8D%E8%AF%95/">服务容错(一) 重试</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当服务调用失败时，如果是幂等性操作，我们可能需要进行重试。</p>
<h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><p>Dubbo重试策略有:</p>
<ul>
<li>Failover Cluster 当出现失败，重试其它服务器。</li>
<li>Failfast Cluster 只发起一次调用，失败立即报错，通常用于非幂等性的操作。</li>
<li>Failsafe Cluster 出现异常时，直接忽略，通常用于写入审计日志等操作。</li>
<li>Failback Cluster 后台记录失败请求，定时重发，通常用于消息通知操作。</li>
</ul>
<p>它们的实现都在<strong>dubbo-cluster</strong>下的<strong>org.apache.dubbo.rpc.cluster.support</strong>包中(Dubbo-2.7.0 从2.7开始，dubbo正式将包名全部从alibaba迁至了apache下)。</p>
<p>包下分别有<strong>XXXCluster</strong>和<strong>XXXClusterInvoker</strong>，Cluster是返回了一个ClusterInvoker对象，所以实际是调用了ClusterInvoker。ClusterInvoker都继承了<strong>AbstractClusterInvoker</strong>，AbstractClusterInvoker做了一些基础的实现(列举Invoker，负载均衡 etc..)，而**    protected abstract Result doInvoke(Invocation invocation, List&lt;Invoker<T>&gt; invokers,<br>                                       LoadBalance loadbalance) throws RpcException;**则是待实现方法。</p>
<p>接着依次来看其实现：</p>
<ul>
<li>FailoverClusterInvoker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class FailoverClusterInvoker&lt;T&gt; extends AbstractClusterInvoker&lt;T&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">    	&#x2F;&#x2F; 服务提供者列表</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; copyInvokers &#x3D; invokers;</span><br><span class="line">        &#x2F;&#x2F; 检查服务提供者列表是否为空</span><br><span class="line">        checkInvokers(copyInvokers, invocation);</span><br><span class="line">        String methodName &#x3D; RpcUtils.getMethodName(invocation);</span><br><span class="line">        &#x2F;&#x2F; 从url中获取重试次数 len是总调用次数 &#x3D; 重试次数 + 1</span><br><span class="line">        int len &#x3D; getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;</span><br><span class="line">        if (len &lt;&#x3D; 0) &#123;</span><br><span class="line">            len &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; retry loop.</span><br><span class="line">        RpcException le &#x3D; null; &#x2F;&#x2F; last exception.</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invoked &#x3D; new ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); &#x2F;&#x2F; invoked invokers.</span><br><span class="line">        Set&lt;String&gt; providers &#x3D; new HashSet&lt;String&gt;(len);</span><br><span class="line">        &#x2F;&#x2F; 循环调用，出错重试</span><br><span class="line">        for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 每次重试前刷新服务提供者列表以防止过期服务提供者在其中</span><br><span class="line">            if (i &gt; 0) &#123;</span><br><span class="line">                checkWhetherDestroyed();</span><br><span class="line">                copyInvokers &#x3D; list(invocation);</span><br><span class="line">                &#x2F;&#x2F; check again</span><br><span class="line">                checkInvokers(copyInvokers, invocation);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 负载均衡选择invoker</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">            &#x2F;&#x2F; 添加到 invoker 到 invoked 列表中</span><br><span class="line">            invoked.add(invoker);</span><br><span class="line">            &#x2F;&#x2F; 设置 invoked 到 RPC 上下文中</span><br><span class="line">            RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">            try &#123;</span><br><span class="line">            	&#x2F;&#x2F; 调用目标 Invoker 的 invoke 方法</span><br><span class="line">                Result result &#x3D; invoker.invoke(invocation);</span><br><span class="line">                &#x2F;&#x2F; 记录上一次调用出错信息</span><br><span class="line">                if (le !&#x3D; null &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(...);</span><br><span class="line">                &#125;</span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch (RpcException e) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 业务错误则抛出 不应继续调用</span><br><span class="line">                if (e.isBiz()) &#123; &#x2F;&#x2F; biz exception.</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125;</span><br><span class="line">                le &#x3D; e;</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 记录本次调用的错误信息</span><br><span class="line">                le &#x3D; new RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">            	&#x2F;&#x2F; 记录调用地址(被调用的服务提供者),用于log</span><br><span class="line">                providers.add(invoker.getUrl().getAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#x2F;&#x2F; for end</span><br><span class="line">        &#x2F;&#x2F; 循环调用全部失败</span><br><span class="line">        throw new RpcException(le.getCode(), ...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>FailfastClusterInvoker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class FailfastClusterInvoker&lt;T&gt; extends AbstractClusterInvoker&lt;T&gt; &#123;</span><br><span class="line">	...</span><br><span class="line">    public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, null);</span><br><span class="line">        &#x2F;&#x2F; 调用一次并返回结果</span><br><span class="line">        try &#123;</span><br><span class="line">            return invoker.invoke(invocation);</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (e instanceof RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; &#x2F;&#x2F; biz exception.</span><br><span class="line">                throw (RpcException) e;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new RpcException(...);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>FailsafeClusterInvoker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           checkInvokers(invokers, invocation);</span><br><span class="line">           Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, null);</span><br><span class="line">           return invoker.invoke(invocation);</span><br><span class="line">       &#125; catch (Throwable e) &#123;</span><br><span class="line">           logger.error(&quot;Failsafe ignore exception: &quot; + e.getMessage(), e);</span><br><span class="line">           return new RpcResult(); &#x2F;&#x2F; ignore</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>FailbackClusterInvoker</li>
</ul>
<p>首先看doInvoke方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">    Invoker&lt;T&gt; invoker &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F; 检查列表非空</span><br><span class="line">        checkInvokers(invokers, invocation);</span><br><span class="line">        &#x2F;&#x2F; 负载均衡选择</span><br><span class="line">        invoker &#x3D; select(loadbalance, invocation, invokers, null);</span><br><span class="line">        &#x2F;&#x2F; 调用</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        logger.error(&quot;Failback to invoke method &quot; + invocation.getMethodName() + &quot;, wait for retry in background. Ignored exception: &quot;</span><br><span class="line">                + e.getMessage() + &quot;, &quot;, e);</span><br><span class="line">        &#x2F;&#x2F; 将该调用失败任务添加进任务列表定时执行</span><br><span class="line">        addFailed(loadbalance, invocation, invokers, invoker);</span><br><span class="line">        return new RpcResult(); &#x2F;&#x2F; ignore</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着看addFailed方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">private volatile Timer failTimer;</span><br><span class="line">   ...</span><br><span class="line">   private void addFailed(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, Invoker&lt;T&gt; lastInvoker) &#123;</span><br><span class="line">   	&#x2F;&#x2F; 双重检查构建单例HashedWheelTimer，关于HashedWheelTimer参考文末链接</span><br><span class="line">       &#x2F;&#x2F; dubbo实现在org.apache.dubbo.common.time包下</span><br><span class="line">       if (failTimer &#x3D;&#x3D; null) &#123;</span><br><span class="line">           synchronized (this) &#123;</span><br><span class="line">               if (failTimer &#x3D;&#x3D; null) &#123;</span><br><span class="line">               	&#x2F;&#x2F; NamedThreadFactory生产&quot;failback-cluster-timer&quot;前缀名，true为守护线程</span><br><span class="line">                   &#x2F;&#x2F; tickDuration &#x3D; 1, the time unit of the tickDuration &#x3D; TimeUnit.SECONDS</span><br><span class="line">                   &#x2F;&#x2F; the size of the wheel&#x3D;32, </span><br><span class="line">                   &#x2F;&#x2F; maximum number of pending timeouts&#x3D;failbackTasks，</span><br><span class="line">                   &#x2F;&#x2F; 超过maximum number调用会抛出RejectedExecutionException</span><br><span class="line">                   failTimer &#x3D; new HashedWheelTimer(</span><br><span class="line">                           new NamedThreadFactory(&quot;failback-cluster-timer&quot;, true),</span><br><span class="line">                           1,</span><br><span class="line">                           TimeUnit.SECONDS, 32, failbackTasks);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 重试任务，当重试次数未超过重试上限retries的时候会进行调用操作，</span><br><span class="line">       &#x2F;&#x2F; 如果调用失败且为超过重试上限时将重试次数+1并将该任务新设超时加入到Timer中</span><br><span class="line">       RetryTimerTask retryTimerTask &#x3D; new RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD);</span><br><span class="line">       try &#123;</span><br><span class="line">       	&#x2F;&#x2F; 将重试任务放入队列</span><br><span class="line">           failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);</span><br><span class="line">       &#125; catch (Throwable e) &#123;</span><br><span class="line">           logger.error(&quot;Failback background works error,invocation-&gt;&quot; + invocation + &quot;, exception: &quot; + e.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><p>首先，因Ribbon在spring cloud中是由Hystrix包装调用的，所以在配置超时时Hystrix的超时要大于Ribbon的超时。如Ribbon每次超时为 1 s，超时后重试的次数为 2， 则Hystrix的超时时间应该设为大于 3 s的值。</p>
<p>同时，在使用了Feign的情况下，应禁用掉Feign的重试机制，当前版本默认是禁用的。</p>
<p>然后再来看ribbon重试，ribbon通过三个参数控制重试:</p>
<ul>
<li>maxAutoRetries 对当前服务器的重试次数</li>
<li>maxAutoRetriesNextServer 切换服务器的重试次数</li>
<li>okToRetryOnAllOperations 对所有操作请求都进行重试</li>
</ul>
<p>一个配置文件示例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    myusers-service:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: 6500 # hystrix超时配置</span><br><span class="line"></span><br><span class="line">myusers-service:</span><br><span class="line">  ribbon:</span><br><span class="line">    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList</span><br><span class="line">    listOfServers: http:&#x2F;&#x2F;example1.com,http:&#x2F;&#x2F;example2.com</span><br><span class="line">    ConnectTimeout: 1000 # 请求连接的超时时间</span><br><span class="line">    ReadTimeout: 3000 # 请求处理的超时时间</span><br><span class="line">    MaxTotalHttpConnections: 500 # 最大总连接数</span><br><span class="line">    MaxConnectionsPerHost: 100 # 单机连接最大数目</span><br><span class="line">    </span><br><span class="line">    # 重试相关</span><br><span class="line">    maxAutoRetries: 1 # 对当前实例的重试次数</span><br><span class="line">    maxAutoRetriesNextServer: 2 # 切换实例的重试次数</span><br><span class="line">    okToRetryOnAllOperations: false # 对所有操作请求都进行重试</span><br></pre></td></tr></table></figure>

<p>从官方示例来看，Ribbon执行请求的入口在ribbon-loadbalancer下AbstractLoadBalancerAwareClient的executeWithLoadBalancer方法(Ribbon-2.3.0)，需要注意的是这里使用了RxJava</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException &#123;</span><br><span class="line">	&#x2F;&#x2F; 由请求和请求配置构建command</span><br><span class="line">    LoadBalancerCommand&lt;T&gt; command &#x3D; buildLoadBalancerCommand(request, requestConfig);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    	&#x2F;&#x2F; 返回执行结果</span><br><span class="line">        return command.submit(</span><br><span class="line">            new ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                    URI finalUri &#x3D; reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                    S requestForServer &#x3D; (S) request.replaceUri(finalUri);</span><br><span class="line">                    try &#123;</span><br><span class="line">                    	&#x2F;&#x2F; 执行网络请求，由子类实现</span><br><span class="line">                        return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));</span><br><span class="line">                    &#125; </span><br><span class="line">                    catch (Exception e) &#123;</span><br><span class="line">                        return Observable.error(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .toBlocking()</span><br><span class="line">            .single();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Throwable t &#x3D; e.getCause();</span><br><span class="line">        if (t instanceof ClientException) &#123;</span><br><span class="line">            throw (ClientException) t;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new ClientException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跳转至LoadBalancerCommand</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   &#x2F;&#x2F; 重试handler 保存了重试信息</span><br><span class="line">   private final RetryHandler retryHandler;</span><br><span class="line">   &#x2F;&#x2F; 执行信息 保存了服务器信息 以及已经尝试连接当前服务器次数以及历史服务器次数</span><br><span class="line">   private volatile ExecutionInfo executionInfo;</span><br><span class="line">   &#x2F;&#x2F; 服务器信息 host:port</span><br><span class="line">   private final Server server;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听调用，保存了历史执行内容 监听列表 etc..</span><br><span class="line">   private final ExecutionContextListenerInvoker&lt;?, T&gt; listenerInvoker;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   public Observable&lt;T&gt; submit(final ServerOperation&lt;T&gt; operation) &#123;</span><br><span class="line">   	&#x2F;&#x2F; 执行内容信息上下文，同ExecutionInfo，属性非final</span><br><span class="line">       final ExecutionInfoContext context &#x3D; new ExecutionInfoContext();</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 执行监听器在行为开始时的动作</span><br><span class="line">       if (listenerInvoker !&#x3D; null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               listenerInvoker.onExecutionStart();</span><br><span class="line">           &#125; catch (AbortExecutionException e) &#123;</span><br><span class="line">               return Observable.error(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 同一实例的最大重试次数</span><br><span class="line">       final int maxRetrysSame &#x3D; retryHandler.getMaxRetriesOnSameServer();</span><br><span class="line">       &#x2F;&#x2F; 切换实例的重试次数</span><br><span class="line">       final int maxRetrysNext &#x3D; retryHandler.getMaxRetriesOnNextServer();</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; Use the load balancer</span><br><span class="line">       Observable&lt;T&gt; o &#x3D; </span><br><span class="line">               (server &#x3D;&#x3D; null ? selectServer() : Observable.just(server))</span><br><span class="line">               .concatMap(new Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   &#x2F;&#x2F; Called for each server being selected</span><br><span class="line">                   public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                   	&#x2F;&#x2F; 设定当前服务器信息，重置单机尝试次数，增加切换次数</span><br><span class="line">                       context.setServer(server);</span><br><span class="line">                       final ServerStats stats &#x3D; loadBalancerContext.getServerStats(server);</span><br><span class="line">                       </span><br><span class="line">                       &#x2F;&#x2F; Called for each attempt and retry</span><br><span class="line">                       Observable&lt;T&gt; o &#x3D; Observable</span><br><span class="line">                               .just(server)</span><br><span class="line">                               .concatMap(new Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">                                   @Override</span><br><span class="line">                                   public Observable&lt;T&gt; call(final Server server) &#123;</span><br><span class="line">                                       &#x2F;&#x2F; 增加本服务器的调用次数</span><br><span class="line">                                       context.incAttemptCount();</span><br><span class="line">                                       loadBalancerContext.noteOpenConnection(stats);</span><br><span class="line">                                       </span><br><span class="line">                                       if (listenerInvoker !&#x3D; null) &#123;</span><br><span class="line">                                           try &#123;</span><br><span class="line">                                               listenerInvoker.onStartWithServer(context.toExecutionInfo());</span><br><span class="line">                                           &#125; catch (AbortExecutionException e) &#123;</span><br><span class="line">                                               return Observable.error(e);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                       </span><br><span class="line">                                       final Stopwatch tracer &#x3D; loadBalancerContext.getExecuteTracer().start();</span><br><span class="line">                                       </span><br><span class="line">                                       return operation.call(server).doOnEach(new Observer&lt;T&gt;() &#123;</span><br><span class="line">                                           private T entity;</span><br><span class="line">                                           @Override</span><br><span class="line">                                           public void onCompleted() &#123;</span><br><span class="line">                                               recordStats(tracer, stats, entity, null);</span><br><span class="line">                                               &#x2F;&#x2F; TODO: What to do if onNext or onError are never called?</span><br><span class="line">                                           &#125;</span><br><span class="line"></span><br><span class="line">                                           @Override</span><br><span class="line">                                           public void onError(Throwable e) &#123;</span><br><span class="line">                                               recordStats(tracer, stats, null, e);</span><br><span class="line">                                               logger.debug(&quot;Got error &#123;&#125; when executed on server &#123;&#125;&quot;, e, server);</span><br><span class="line">                                               if (listenerInvoker !&#x3D; null) &#123;</span><br><span class="line">                                                   listenerInvoker.onExceptionWithServer(e, context.toExecutionInfo());</span><br><span class="line">                                               &#125;</span><br><span class="line">                                           &#125;</span><br><span class="line"></span><br><span class="line">                                           @Override</span><br><span class="line">                                           public void onNext(T entity) &#123;</span><br><span class="line">                                               this.entity &#x3D; entity;</span><br><span class="line">                                               if (listenerInvoker !&#x3D; null) &#123;</span><br><span class="line">                                                   listenerInvoker.onExecutionSuccess(entity, context.toExecutionInfo());</span><br><span class="line">                                               &#125;</span><br><span class="line">                                           &#125;                            </span><br><span class="line">                                           </span><br><span class="line">                                           private void recordStats(Stopwatch tracer, ServerStats stats, Object entity, Throwable exception) &#123;</span><br><span class="line">                                               tracer.stop();</span><br><span class="line">                                               loadBalancerContext.noteRequestCompletion(stats, entity, exception, tracer.getDuration(TimeUnit.MILLISECONDS), retryHandler);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;);</span><br><span class="line">                                   &#125;&#x2F;&#x2F; 里层 call end</span><br><span class="line">                               &#125;);&#x2F;&#x2F; 里层 Observable&lt;T&gt; o &#x3D; ... end</span><br><span class="line">                       </span><br><span class="line">                       &#x2F;&#x2F; 如果最大重试单台服务器次数大于0，onError时进行maxRetrysSame次重试</span><br><span class="line">                       &#x2F;&#x2F; 重试条件:</span><br><span class="line">                       &#x2F;&#x2F; 1.非AbortExecutionException错误</span><br><span class="line">                       &#x2F;&#x2F; 2.重试次数不能大于maxRetrysSame</span><br><span class="line">                       &#x2F;&#x2F; 3.判断是否是打开retry开关</span><br><span class="line">                       &#x2F;&#x2F; 4.如果是同一服务器则判断错误是否为可重试的错误，非同一服务器直接返回true</span><br><span class="line">                       if (maxRetrysSame &gt; 0) </span><br><span class="line">                           o &#x3D; o.retry(retryPolicy(maxRetrysSame, true));</span><br><span class="line">                       return o;</span><br><span class="line">                   &#125;&#x2F;&#x2F; 外层 call end</span><br><span class="line">               &#125;);&#x2F;&#x2F; 外层 Observable&lt;T&gt; o &#x3D; ... end</span><br><span class="line">           </span><br><span class="line">       &#x2F;&#x2F; 可重试其他服务器</span><br><span class="line">       if (maxRetrysNext &gt; 0 &amp;&amp; server &#x3D;&#x3D; null) </span><br><span class="line">           o &#x3D; o.retry(retryPolicy(maxRetrysNext, false));</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 调用全部失败处理</span><br><span class="line">       return o.onErrorResumeNext(new Func1&lt;Throwable, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Observable&lt;T&gt; call(Throwable e) &#123;</span><br><span class="line">               if (context.getAttemptCount() &gt; 0) &#123;</span><br><span class="line">                   if (maxRetrysNext &gt; 0 &amp;&amp; context.getServerAttemptCount() &#x3D;&#x3D; (maxRetrysNext + 1)) &#123;</span><br><span class="line">                       e &#x3D; new ClientException(ClientException.ErrorType.NUMBEROF_RETRIES_NEXTSERVER_EXCEEDED,</span><br><span class="line">                               &quot;Number of retries on next server exceeded max &quot; + maxRetrysNext</span><br><span class="line">                               + &quot; retries, while making a call for: &quot; + context.getServer(), e);</span><br><span class="line">                   &#125;</span><br><span class="line">                   else if (maxRetrysSame &gt; 0 &amp;&amp; context.getAttemptCount() &#x3D;&#x3D; (maxRetrysSame + 1)) &#123;</span><br><span class="line">                       e &#x3D; new ClientException(ClientException.ErrorType.NUMBEROF_RETRIES_EXEEDED,</span><br><span class="line">                               &quot;Number of retries exceeded max &quot; + maxRetrysSame</span><br><span class="line">                               + &quot; retries, while making a call for: &quot; + context.getServer(), e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (listenerInvoker !&#x3D; null) &#123;</span><br><span class="line">                   listenerInvoker.onExecutionFailed(e, context.toFinalExecutionInfo());</span><br><span class="line">               &#125;</span><br><span class="line">               return Observable.error(e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><a href="https://chuansongme.com/n/1650380646616" target="_blank" rel="noopener">10w定时任务，如何高效触发超时</a></p>
</li>
<li><p><a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf" target="_blank" rel="noopener">Hashed and Hierarchical Timing Wheels: Data Structures<br>for the Efficient Implementation of a Timer Facility 
</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/16/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99-%E4%B8%80-%E9%87%8D%E8%AF%95/" data-id="ckaqo6uzr002328o624c1233o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-客户端负载均衡" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="article-date">
  <time datetime="2019-03-13T14:54:00.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">客户端负载均衡</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h4><p>负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。<a href="https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">负载均衡</a></p>
<h4 id="常用负载均衡策略"><a href="#常用负载均衡策略" class="headerlink" title="常用负载均衡策略"></a>常用负载均衡策略</h4><ul>
<li>轮询/加权轮询</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;轮询是指将请求轮流分配给每台服务器，当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法。但现实中不能保证每台服务器性能均相近，此时出现的就是加权轮询，将请求按权重分配进行轮询以调控每台服务器的负载。</p>
<ul>
<li>随机(按权重)</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;按权重设置随机概率，调用量较少的时候在一个截面上碰撞的概率高(请求集中在一台服务器上)，但调用量越大分配越均匀(越接近设定的权重比)。</p>
<ul>
<li>最少活跃/加权最少活跃</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;最少活跃指服务提供者当前任务数(当前的活跃调用数)最少；加权则是在其过程中进行按权重分配，如活跃数相同的两个服务提供者，则按权(随机)分配。</p>
<ul>
<li>哈希/一致性哈希</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;将请求按一定规则哈希将请求分配到对应的服务器上；一致哈希是一种特殊的哈希算法。<br>在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中 K 是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p>
<ul>
<li>响应速度</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;根据服务提供者的响应速度来选择。</p>
<h4 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h4><h5 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h5><p>Dubbo的负载均衡代码在dubbo-cluster下com.alibaba.dubbo.rpc.cluster.loadbalance包中(Dubbo 2.6.6)。实现了四种负载均衡策略：一致性哈希，最少活跃，随机，加权轮询。</p>
<h6 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h6><p>dubbo服务在预热期间权重是计算出来的，这个值随着启动时间越长会越接近自定义的权重值，预热期过后才等于自定义权重值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int calculateWarmupWeight(int uptime, int warmup, int weight) &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算权重，下面代码逻辑上形似于 (uptime &#x2F; warmup) * weight。</span><br><span class="line">    &#x2F;&#x2F; 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight</span><br><span class="line">    int ww &#x3D; (int) ((float) uptime &#x2F; ((float) warmup &#x2F; (float) weight));</span><br><span class="line">    return ww &lt; 1 ? 1 : (ww &gt; weight ? weight : ww);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> private static final class ConsistentHashSelector&lt;T&gt; &#123;</span><br><span class="line"> 	&#x2F;&#x2F; 虚拟节点</span><br><span class="line">     private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">     &#x2F;&#x2F; 虚拟节点数量</span><br><span class="line">     private final int replicaNumber;</span><br><span class="line">     &#x2F;&#x2F; 用于检查实际节点是否有变化(上下线等)</span><br><span class="line">     private final int identityHashCode;</span><br><span class="line">     &#x2F;&#x2F; 用于参数定位</span><br><span class="line">     private final int[] argumentIndex;</span><br><span class="line"></span><br><span class="line">     ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123;</span><br><span class="line">         this.virtualInvokers &#x3D; new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">         this.identityHashCode &#x3D; identityHashCode;</span><br><span class="line">         URL url &#x3D; invokers.get(0).getUrl();</span><br><span class="line">         &#x2F;&#x2F; 获取虚拟节点数，默认为160</span><br><span class="line">         this.replicaNumber &#x3D; url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);</span><br><span class="line">         &#x2F;&#x2F; 获取参与 hash 计算的参数下标值，默认对第一个参数进行 hash 运算</span><br><span class="line">         String[] index &#x3D; Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));</span><br><span class="line">         argumentIndex &#x3D; new int[index.length];</span><br><span class="line">         for (int i &#x3D; 0; i &lt; index.length; i++) &#123;</span><br><span class="line">             argumentIndex[i] &#x3D; Integer.parseInt(index[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 分散到环上</span><br><span class="line">         for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">             String address &#x3D; invoker.getUrl().getAddress();</span><br><span class="line">             for (int i &#x3D; 0; i &lt; replicaNumber &#x2F; 4; i++) &#123;</span><br><span class="line">             	&#x2F;&#x2F; 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span><br><span class="line">                 byte[] digest &#x3D; md5(address + i);</span><br><span class="line">                 &#x2F;&#x2F; 对 digest 每4字节进行hash</span><br><span class="line">                 for (int h &#x3D; 0; h &lt; 4; h++) &#123;</span><br><span class="line">                     long m &#x3D; hash(digest, h);</span><br><span class="line">                     virtualInvokers.put(m, invoker);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">     	&#x2F;&#x2F; long hash是传入参数md5的hash</span><br><span class="line">     	&#x2F;&#x2F; 查找第一个节点值大于或等于当前 hash 的 Invoker</span><br><span class="line">         Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry &#x3D; virtualInvokers.tailMap(hash, true).firstEntry();</span><br><span class="line">         &#x2F;&#x2F; null说明在末尾，则取首个节点</span><br><span class="line">         if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">             entry &#x3D; virtualInvokers.firstEntry();</span><br><span class="line">         &#125;</span><br><span class="line">         return entry.getValue();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="加权最少活跃"><a href="#加权最少活跃" class="headerlink" title="加权最少活跃"></a>加权最少活跃</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size();</span><br><span class="line">        &#x2F;&#x2F; 最小的活跃数值(最小的任务数量)</span><br><span class="line">        int leastActive &#x3D; -1;</span><br><span class="line">        &#x2F;&#x2F; 具有相同最小活跃数的服务者提供者数量</span><br><span class="line">        int leastCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;具有相同最小活跃数的提供者在列表中的下标</span><br><span class="line">        int[] leastIndexs &#x3D; new int[length]; </span><br><span class="line">        &#x2F;&#x2F; 所有最小活跃的提供者的权重和</span><br><span class="line">        int totalWeight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 第一个最小活跃数的提供者权重值</span><br><span class="line">        int firstWeight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 多个最小活跃时，每个权重是否相等</span><br><span class="line">        boolean sameWeight &#x3D; true;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; invokers.get(i);</span><br><span class="line">            int active &#x3D; RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            &#x2F;&#x2F; 获取权重，如果是预热期则是预热权重</span><br><span class="line">            int afterWarmup &#x3D; getWeight(invoker, invocation);</span><br><span class="line">            &#x2F;&#x2F; 发现比当前有更小活跃的提供者，重置记录值</span><br><span class="line">            if (leastActive &#x3D;&#x3D; -1 || active &lt; leastActive) &#123; </span><br><span class="line">                leastActive &#x3D; active;</span><br><span class="line">                leastCount &#x3D; 1;</span><br><span class="line">                leastIndexs[0] &#x3D; i;</span><br><span class="line">                totalWeight &#x3D; afterWarmup; </span><br><span class="line">                firstWeight &#x3D; afterWarmup;</span><br><span class="line">                sameWeight &#x3D; true;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F; 发现和当前最小活跃数相等的提供者，更新记录值</span><br><span class="line">            &#125; else if (active &#x3D;&#x3D; leastActive) &#123; </span><br><span class="line">                leastIndexs[leastCount++] &#x3D; i;</span><br><span class="line">                totalWeight +&#x3D; afterWarmup; </span><br><span class="line">                if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                        &amp;&amp; afterWarmup !&#x3D; firstWeight) &#123;</span><br><span class="line">                    sameWeight &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 刚好仅有一个最小活跃</span><br><span class="line">        if (leastCount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return invokers.get(leastIndexs[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果有多个最小活跃，且权重不相等，则按权分配</span><br><span class="line">        if (!sameWeight &amp;&amp; totalWeight &gt; 0) &#123;</span><br><span class="line">            int offsetWeight &#x3D; random.nextInt(totalWeight) + 1;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; leastCount; i++) &#123;</span><br><span class="line">                int leastIndex &#x3D; leastIndexs[i];</span><br><span class="line">                offsetWeight -&#x3D; getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">                if (offsetWeight &lt;&#x3D; 0)</span><br><span class="line">                    return invokers.get(leastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 多个最小活跃权重相等，随机返回一个</span><br><span class="line">        return invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size();</span><br><span class="line">        int totalWeight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 所有服务提供者的权重是否相等</span><br><span class="line">        boolean sameWeight &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 计算总权重，并判断所有服务提供者的权重是否相等</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            totalWeight +&#x3D; weight;</span><br><span class="line">            if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                    &amp;&amp; weight !&#x3D; getWeight(invokers.get(i - 1), invocation)) &#123;</span><br><span class="line">                sameWeight &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 权重不均等按权随机</span><br><span class="line">        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            int offset &#x3D; random.nextInt(totalWeight);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">                offset -&#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">                if (offset &lt; 0) &#123;</span><br><span class="line">                    return invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 权重均等时随机返回一个</span><br><span class="line">        return invokers.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h6><p>这里加权轮询算法实现类似nginx的加权轮询，对于每个节点有两个属性，我们配置的weight和用于轮询的current weight。current weight初始为0。对于每次请求：</p>
<ol>
<li>遍历集群中的所有可用提供者，使每个提供者的currentWeight += weight, 并统计出权重总和 totalWeight。</li>
<li>选取currentWeight最大的提供者处理本次请求。</li>
<li>对于本次选定的提供者进行currentWeight -= totalWeight。</li>
</ol>
<p>来看一个权重配置为[A: 3, B: 2, C: 1]的例子。初始currentWeight数组为[0, 0, 0]，totalWeight = 6</p>
<table>
<thead>
<tr>
<th align="center">请求编号</th>
<th align="center">currentWeight 数组</th>
<th align="center">选择结果</th>
<th align="center">选择结果后currentWeight 数组</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">[3, 2, 1]</td>
<td align="center">A</td>
<td align="center">[-3, 2, 1]</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">[0, 4, 2]</td>
<td align="center">B</td>
<td align="center">[0, -2, 2]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">[3, 0, 3]</td>
<td align="center">A</td>
<td align="center">[-3, 0, 3]</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">[0, 2, 4]</td>
<td align="center">C</td>
<td align="center">[0, 2, -2]</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">[3, 4, -1]</td>
<td align="center">B</td>
<td align="center">[3, -2, -1]</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">[6, 0, 0]</td>
<td align="center">A</td>
<td align="center">[0, 0, 0]</td>
</tr>
</tbody></table>
<p>这种策略避免了同一时间有大量请求集中到同一台机器上并实现轮询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">   protected static class WeightedRoundRobin &#123;</span><br><span class="line">       private int weight;</span><br><span class="line">       &#x2F;&#x2F; currentWeight</span><br><span class="line">       private AtomicLong current &#x3D; new AtomicLong(0);</span><br><span class="line">       &#x2F;&#x2F; 更新currentWeight时间戳</span><br><span class="line">       private long lastUpdate;</span><br><span class="line">       public int getWeight() &#123;</span><br><span class="line">           return weight;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setWeight(int weight) &#123;</span><br><span class="line">           this.weight &#x3D; weight;</span><br><span class="line">           current.set(0);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; currentWeight +&#x3D; weight</span><br><span class="line">       public long increaseCurrent() &#123;</span><br><span class="line">           return current.addAndGet(weight);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; currentWeight -&#x3D; totalWeight</span><br><span class="line">       public void sel(int total) &#123;</span><br><span class="line">           current.addAndGet(-1 * total);</span><br><span class="line">       &#125;</span><br><span class="line">       public long getLastUpdate() &#123;</span><br><span class="line">           return lastUpdate;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setLastUpdate(long lastUpdate) &#123;</span><br><span class="line">           this.lastUpdate &#x3D; lastUpdate;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123;&quot;服务名.方法名&quot;: &#123;&quot;url(服务提供者)&quot;: WeightedRoundRobin&#125;&#125;</span><br><span class="line">   private ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap &#x3D; new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">   &#x2F;&#x2F; 更新锁，用于移除过期节点</span><br><span class="line">   private AtomicBoolean updateLock &#x3D; new AtomicBoolean();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">   	&#x2F;&#x2F; 第一层索引 &quot;服务名.方法名&quot;</span><br><span class="line">       String key &#x3D; invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();</span><br><span class="line">       &#x2F;&#x2F; 获取&#123;&quot;url(服务提供者)&quot;: WeightedRoundRobin&#125; 不存在就创建</span><br><span class="line">       ConcurrentMap&lt;String, WeightedRoundRobin&gt; map &#x3D; methodWeightMap.get(key);</span><br><span class="line">       if (map &#x3D;&#x3D; null) &#123;</span><br><span class="line">           methodWeightMap.putIfAbsent(key, new ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;());</span><br><span class="line">           map &#x3D; methodWeightMap.get(key);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       int totalWeight &#x3D; 0;</span><br><span class="line">       &#x2F;&#x2F; 当前currentWeight最大值</span><br><span class="line">       long maxCurrent &#x3D; Long.MIN_VALUE;</span><br><span class="line">       long now &#x3D; System.currentTimeMillis();</span><br><span class="line">       Invoker&lt;T&gt; selectedInvoker &#x3D; null;</span><br><span class="line">       WeightedRoundRobin selectedWRR &#x3D; null;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 遍历服务提供者 currentWeight+&#x3D;weight 统计totalWeight 查找currentWeight最大的节点 </span><br><span class="line">       for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">       	&#x2F;&#x2F; 根据服务提供者找到对应的WeightedRoundRobin</span><br><span class="line">           String identifyString &#x3D; invoker.getUrl().toIdentityString();</span><br><span class="line">           WeightedRoundRobin weightedRoundRobin &#x3D; map.get(identifyString);</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 获取权重(带预热机制)</span><br><span class="line">           int weight &#x3D; getWeight(invoker, invocation);</span><br><span class="line">           if (weight &lt; 0) &#123;</span><br><span class="line">               weight &#x3D; 0;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 如果不存在对应的weightedRoundRobin则新建</span><br><span class="line">           if (weightedRoundRobin &#x3D;&#x3D; null) &#123;</span><br><span class="line">               weightedRoundRobin &#x3D; new WeightedRoundRobin();</span><br><span class="line">               weightedRoundRobin.setWeight(weight);</span><br><span class="line">               map.putIfAbsent(identifyString, weightedRoundRobin);</span><br><span class="line">               weightedRoundRobin &#x3D; map.get(identifyString);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; weight有更新，则重置weight与currentWeight</span><br><span class="line">           if (weight !&#x3D; weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">               &#x2F;&#x2F;weight changed</span><br><span class="line">               weightedRoundRobin.setWeight(weight);</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; currentWeight +&#x3D; weight</span><br><span class="line">           long cur &#x3D; weightedRoundRobin.increaseCurrent();</span><br><span class="line">           weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">           &#x2F;&#x2F; 如果大于当前currentWeight节点，则替换</span><br><span class="line">           if (cur &gt; maxCurrent) &#123;</span><br><span class="line">               maxCurrent &#x3D; cur;</span><br><span class="line">               selectedInvoker &#x3D; invoker;</span><br><span class="line">               selectedWRR &#x3D; weightedRoundRobin;</span><br><span class="line">           &#125;</span><br><span class="line">           totalWeight +&#x3D; weight;</span><br><span class="line">       &#125; &#x2F;&#x2F; for end</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 服务提供者数量与历史数量不一致，需移除过期的节点</span><br><span class="line">       if (!updateLock.get() &amp;&amp; invokers.size() !&#x3D; map.size()) &#123;</span><br><span class="line">           if (updateLock.compareAndSet(false, true)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F; copy -&gt; modify -&gt; update reference</span><br><span class="line">                   ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap &#x3D; new ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;();</span><br><span class="line">                   newMap.putAll(map);</span><br><span class="line">                   Iterator&lt;Entry&lt;String, WeightedRoundRobin&gt;&gt; it &#x3D; newMap.entrySet().iterator();</span><br><span class="line">                   while (it.hasNext()) &#123;</span><br><span class="line">                       Entry&lt;String, WeightedRoundRobin&gt; item &#x3D; it.next();</span><br><span class="line">                       if (now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD) &#123;</span><br><span class="line">                           it.remove();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   methodWeightMap.put(key, newMap);</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   updateLock.set(false);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; currentWeight -&#x3D; totalWeight</span><br><span class="line">       if (selectedInvoker !&#x3D; null) &#123;</span><br><span class="line">           selectedWRR.sel(totalWeight);</span><br><span class="line">           return selectedInvoker;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; should not happen here</span><br><span class="line">       return invokers.get(0);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h5><h6 id="ribbon负载均衡组件"><a href="#ribbon负载均衡组件" class="headerlink" title="ribbon负载均衡组件"></a>ribbon负载均衡组件</h6><ul>
<li>Rule 决定采用哪个服务提供者。</li>
<li>Ping 用于确认服务提供者存活。</li>
<li>ServerList 静态或动态的地址列表，如果是动态则后台会定时刷新过滤该列表。</li>
</ul>
<h6 id="使用配置文件配置"><a href="#使用配置文件配置" class="headerlink" title="使用配置文件配置"></a>使用配置文件配置</h6><ul>
<li>&lt;clientName&gt;.ribbon.NFLoadBalancerClassName: Should implement ILoadBalancer</li>
<li>&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName: Should implement IRule</li>
<li>&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName: Should implement IPing</li>
<li>&lt;clientName&gt;.ribbon.NIWSServerListClassName: Should implement ServerList</li>
<li>&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName: Should implement ServerListFilter</li>
</ul>
<p>示例: 为user服务设定负载均衡策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users:</span><br><span class="line">  ribbon:</span><br><span class="line">    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h5><h6 id="RoundRobinRule-轮询"><a href="#RoundRobinRule-轮询" class="headerlink" title="RoundRobinRule(轮询)"></a>RoundRobinRule(轮询)</h6><p>简单轮询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;下一个服务提供者在列表中的位置</span><br><span class="line">   private AtomicInteger nextServerCyclicCounter;</span><br><span class="line">   </span><br><span class="line">   public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">       if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">           log.warn(&quot;no load balancer&quot;);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 选取的服务提供者</span><br><span class="line">       Server server &#x3D; null;</span><br><span class="line">       &#x2F;&#x2F; 重试计数</span><br><span class="line">       int count &#x3D; 0;</span><br><span class="line">       &#x2F;&#x2F; 轮询</span><br><span class="line">       while (server &#x3D;&#x3D; null &amp;&amp; count++ &lt; 10) &#123;</span><br><span class="line">           List&lt;Server&gt; reachableServers &#x3D; lb.getReachableServers();</span><br><span class="line">           &#x2F;&#x2F; 所有服务提供者</span><br><span class="line">           List&lt;Server&gt; allServers &#x3D; lb.getAllServers();</span><br><span class="line">           &#x2F;&#x2F; 可用的服务提供者数量</span><br><span class="line">           int upCount &#x3D; reachableServers.size();</span><br><span class="line">           &#x2F;&#x2F; 所有服务提供者数量</span><br><span class="line">           int serverCount &#x3D; allServers.size();</span><br><span class="line"></span><br><span class="line">           if ((upCount &#x3D;&#x3D; 0) || (serverCount &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">               log.warn(&quot;No up servers available from load balancer: &quot; + lb);</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; nextServerIndex &#x3D; (nextServerIndex + 1) % total </span><br><span class="line">           int nextServerIndex &#x3D; incrementAndGetModulo(serverCount);</span><br><span class="line">           server &#x3D; allServers.get(nextServerIndex);</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 如果提供者因某些原因(如down)从列表中移除了，则让步一段时间后再重新选取</span><br><span class="line">           if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;* Transient. *&#x2F;</span><br><span class="line">               Thread.yield();</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 服务提供者存活且可提供服务则返回</span><br><span class="line">           if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">               return (server);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; Next.</span><br><span class="line">           server &#x3D; null;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 重试次数过多</span><br><span class="line">       if (count &gt;&#x3D; 10) &#123;</span><br><span class="line">           log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;</span><br><span class="line">                   + lb);</span><br><span class="line">       &#125;</span><br><span class="line">       return server;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h6 id="AvailabilityFilteringRule-可用服务轮询"><a href="#AvailabilityFilteringRule-可用服务轮询" class="headerlink" title="AvailabilityFilteringRule(可用服务轮询)"></a>AvailabilityFilteringRule(可用服务轮询)</h6><p>在简单轮询策略基础上，对服务提供者做可用性过滤:</p>
<ol>
<li><p>在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。</p>
</li>
<li><p>并发数过高的服务器。如果一个服务器的并发连接数过高(默认Integer.MAX_INT)，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。</p>
</li>
</ol>
<p>相关配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 重试次数</span><br><span class="line">niws.loadbalancer.&lt;clientName&gt;.connectionFailureCountThreshold</span><br><span class="line"></span><br><span class="line"># 短路状态持续时长</span><br><span class="line">niws.loadbalancer.&lt;clientName&gt;.circuitTripMaxTimeoutSeconds</span><br><span class="line"></span><br><span class="line"># 并发连接数</span><br><span class="line">&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</span><br></pre></td></tr></table></figure>
<p><img src="/images/cloud/AvailabilityFilteringRuleUML.png" alt="AvailabilityFilteringRuleUML"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ClientConfigEnabledRoundRobinRule extends AbstractLoadBalancerRule &#123;</span><br><span class="line">	&#x2F;&#x2F;默认简单轮询</span><br><span class="line">    RoundRobinRule roundRobinRule &#x3D; new RoundRobinRule();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initWithNiwsConfig(IClientConfig clientConfig) &#123;</span><br><span class="line">        roundRobinRule &#x3D; new RoundRobinRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLoadBalancer(ILoadBalancer lb) &#123;</span><br><span class="line">    	super.setLoadBalancer(lb);</span><br><span class="line">    	roundRobinRule.setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class PredicateBasedRule extends ClientConfigEnabledRoundRobinRule &#123;</span><br><span class="line">	&#x2F;&#x2F; 提供了一些过滤方法的抽象类，基于google guava</span><br><span class="line">    public abstract AbstractServerPredicate getPredicate();</span><br><span class="line">        </span><br><span class="line">    @Override</span><br><span class="line">    public Server choose(Object key) &#123;</span><br><span class="line">        ILoadBalancer lb &#x3D; getLoadBalancer();</span><br><span class="line">        &#x2F;&#x2F; 遍历所有服务提供者并过滤出符合条件的进行轮询选取(先过滤，再选取)</span><br><span class="line">        Optional&lt;Server&gt; server &#x3D; getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">        if (server.isPresent()) &#123;</span><br><span class="line">            return server.get();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AvailabilityFilteringRule extends PredicateBasedRule &#123;   </span><br><span class="line">    public AvailabilityFilteringRule() &#123;</span><br><span class="line">    	super();</span><br><span class="line">        &#x2F;&#x2F; 判断条件 CompositePredicate 组合过滤条件</span><br><span class="line">        &#x2F;&#x2F; AvailabilityPredicate类 实际上这里的判断条件</span><br><span class="line">    	predicate &#x3D; CompositePredicate.withPredicate(new AvailabilityPredicate(this, null))</span><br><span class="line">                .addFallbackPredicate(AbstractServerPredicate.alwaysTrue())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    &#x2F;&#x2F; 这里相比PredicateBasedRule会少一次服务器列表遍历</span><br><span class="line">    public Server choose(Object key) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 重试次数</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 直接轮询选取</span><br><span class="line">        Server server &#x3D; roundRobinRule.choose(key);</span><br><span class="line">        while (count++ &lt;&#x3D; 10) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 符合条件则返回</span><br><span class="line">            if (predicate.apply(new PredicateKey(server))) &#123;</span><br><span class="line">                return server;</span><br><span class="line">            &#125;</span><br><span class="line">            server &#x3D; roundRobinRule.choose(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return super.choose(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class AvailabilityPredicate extends  AbstractServerPredicate &#123;</span><br><span class="line">	...</span><br><span class="line">    @Override</span><br><span class="line">    public boolean apply(@Nullable PredicateKey input) &#123;</span><br><span class="line">        LoadBalancerStats stats &#x3D; getLBStats();</span><br><span class="line">        if (stats &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return !shouldSkipServer(stats.getSingleServerStat(input.getServer()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private boolean shouldSkipServer(ServerStats stats) &#123;        </span><br><span class="line">    	&#x2F;&#x2F;短路状态判断以及并发数量判断</span><br><span class="line">        if ((CIRCUIT_BREAKER_FILTERING.get() &amp;&amp; stats.isCircuitBreakerTripped()) </span><br><span class="line">                || stats.getActiveRequestsCount() &gt;&#x3D; activeConnectionsLimit.get()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="WeightedResponseTimeRule-响应时长作为权重的随机选择"><a href="#WeightedResponseTimeRule-响应时长作为权重的随机选择" class="headerlink" title="WeightedResponseTimeRule(响应时长作为权重的随机选择)"></a>WeightedResponseTimeRule(响应时长作为权重的随机选择)</h6><p>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。权重定时刷新(默认30s)。<br>对于每次请求:</p>
<ol>
<li>遍历服务提供者列表，计算出平均响应时间总和totalResponseTime += avgResponseTime</li>
<li>再次遍历服务提供者列表，获得当前提供者的权重weight = totalResponseTime - avgResponseTime，并记录下列表累计权重和用于随机accumulatedWeights[i] = accumulatedWeights[i - 1] + weight</li>
<li>生成随机数并进行选取，失败的情况下会回退至简单轮询</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">public class WeightedResponseTimeRule extends RoundRobinRule &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 累积权重存放，[0]存放了服务器[0]的权重，[1]存放了服务器[0]到[1]的权重和</span><br><span class="line">    &#x2F;&#x2F; [n]则存放了服务器[0]到[n]的权重和</span><br><span class="line">	private volatile List&lt;Double&gt; accumulatedWeights &#x3D; new ArrayList&lt;Double&gt;();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 更新权重用的Timer</span><br><span class="line">    protected Timer serverWeightTimer &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 更新权重锁</span><br><span class="line">    protected AtomicBoolean serverWeightAssignmentInProgress &#x3D; new AtomicBoolean(false);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化维护权重任务</span><br><span class="line">    void initialize(ILoadBalancer lb) &#123;        </span><br><span class="line">        if (serverWeightTimer !&#x3D; null) &#123;</span><br><span class="line">            serverWeightTimer.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        serverWeightTimer &#x3D; new Timer(&quot;NFLoadBalancer-serverWeightTimer-&quot;</span><br><span class="line">                + name, true);</span><br><span class="line">        &#x2F;&#x2F; 启动维护权重任务 </span><br><span class="line">        &#x2F;&#x2F; DynamicServerWeightTask里执行了 new ServerWeight().maintainWeights()</span><br><span class="line">        &#x2F;&#x2F; serverWeightTaskTimerInterval 默认30 * 1000</span><br><span class="line">        serverWeightTimer.schedule(new DynamicServerWeightTask(), 0,</span><br><span class="line">                serverWeightTaskTimerInterval);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 初始化权重值</span><br><span class="line">        ServerWeight sw &#x3D; new ServerWeight();</span><br><span class="line">        sw.maintainWeights();</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                logger</span><br><span class="line">                        .info(&quot;Stopping NFLoadBalancer-serverWeightTimer-&quot;</span><br><span class="line">                                + name);</span><br><span class="line">                serverWeightTimer.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class ServerWeight &#123;</span><br><span class="line">    	&#x2F;&#x2F; 维护权重</span><br><span class="line">        public void maintainWeights() &#123;</span><br><span class="line">            ILoadBalancer lb &#x3D; getLoadBalancer();</span><br><span class="line">            if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 获取锁</span><br><span class="line">            if (!serverWeightAssignmentInProgress.compareAndSet(false,  true))  &#123;</span><br><span class="line">                return; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">                logger.info(&quot;Weight adjusting job started&quot;);</span><br><span class="line">                AbstractLoadBalancer nlb &#x3D; (AbstractLoadBalancer) lb;</span><br><span class="line">                LoadBalancerStats stats &#x3D; nlb.getLoadBalancerStats();</span><br><span class="line">                if (stats &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; no statistics, nothing to do</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 所有服务提供者的响应时间和</span><br><span class="line">                double totalResponseTime &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 获取所有提供者平均响应时间和</span><br><span class="line">                for (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; this will automatically load the stats if not in cache</span><br><span class="line">                    ServerStats ss &#x3D; stats.getSingleServerStat(server);</span><br><span class="line">                    totalResponseTime +&#x3D; ss.getResponseTimeAvg();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 累积权重</span><br><span class="line">                Double weightSoFar &#x3D; 0.0;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; create new list and hot swap the reference</span><br><span class="line">                &#x2F;&#x2F; 累积权重存放 accumulatedWeights</span><br><span class="line">                List&lt;Double&gt; finalWeights &#x3D; new ArrayList&lt;Double&gt;();</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 获取提供者的权重以及累积权重</span><br><span class="line">                for (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">                    ServerStats ss &#x3D; stats.getSingleServerStat(server);</span><br><span class="line">                    double weight &#x3D; totalResponseTime - ss.getResponseTimeAvg();</span><br><span class="line">                    weightSoFar +&#x3D; weight;</span><br><span class="line">                    finalWeights.add(weightSoFar);   </span><br><span class="line">                &#125;</span><br><span class="line">                setWeights(finalWeights);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;Error calculating server weights&quot;, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                serverWeightAssignmentInProgress.set(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">    public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">        if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Server server &#x3D; null;</span><br><span class="line"></span><br><span class="line">        while (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; get hold of the current reference in case it is changed from the other thread</span><br><span class="line">            List&lt;Double&gt; currentWeights &#x3D; accumulatedWeights;</span><br><span class="line">            if (Thread.interrupted()) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Server&gt; allList &#x3D; lb.getAllServers();</span><br><span class="line"></span><br><span class="line">            int serverCount &#x3D; allList.size();</span><br><span class="line"></span><br><span class="line">            if (serverCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int serverIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取所有服务器权重和</span><br><span class="line">            double maxTotalWeight &#x3D; currentWeights.size() &#x3D;&#x3D; 0 ? 0 : currentWeights.get(currentWeights.size() - 1); </span><br><span class="line">            &#x2F;&#x2F; 权重值过期或未初始化时回退至简单轮询</span><br><span class="line">            if (maxTotalWeight &lt; 0.001d || serverCount !&#x3D; currentWeights.size()) &#123;</span><br><span class="line">                server &#x3D;  super.choose(getLoadBalancer(), key);</span><br><span class="line">                if(server &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return server;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	&#x2F;&#x2F; 生成随机数并进行选取服务提供者</span><br><span class="line">                &#x2F;&#x2F; generate a random weight between 0 (inclusive) to maxTotalWeight (exclusive)</span><br><span class="line">                double randomWeight &#x3D; random.nextDouble() * maxTotalWeight;</span><br><span class="line">                &#x2F;&#x2F; pick the server index based on the randomIndex</span><br><span class="line">                int n &#x3D; 0;</span><br><span class="line">                for (Double d : currentWeights) &#123;</span><br><span class="line">                    if (d &gt;&#x3D; randomWeight) &#123;</span><br><span class="line">                        serverIndex &#x3D; n;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                server &#x3D; allList.get(serverIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;* Transient. *&#x2F;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (server.isAlive()) &#123;</span><br><span class="line">                return (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Next.</span><br><span class="line">            server &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        return server;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wiki上提到的规则是以上三种，下面是wiki上并未提及但Ribbon已实现的一些规则。</p>
<h6 id="BestAvailableRule-最佳可用"><a href="#BestAvailableRule-最佳可用" class="headerlink" title="BestAvailableRule(最佳可用)"></a>BestAvailableRule(最佳可用)</h6><p>忽略短路的提供者，然后选择并发数(最少活跃)的提供者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule &#123;</span><br><span class="line">	...</span><br><span class="line">    @Override</span><br><span class="line">    public Server choose(Object key) &#123;</span><br><span class="line">        if (loadBalancerStats &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return super.choose(key);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; serverList &#x3D; getLoadBalancer().getAllServers();</span><br><span class="line">        &#x2F;&#x2F; 最少活跃数</span><br><span class="line">        int minimalConcurrentConnections &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        long currentTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        Server chosen &#x3D; null;</span><br><span class="line">        for (Server server: serverList) &#123;</span><br><span class="line">            ServerStats serverStats &#x3D; loadBalancerStats.getSingleServerStat(server);</span><br><span class="line">            &#x2F;&#x2F; 选择未短路的服务提供者进行比较</span><br><span class="line">            if (!serverStats.isCircuitBreakerTripped(currentTime)) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 比较当前活跃数 如果小则替换</span><br><span class="line">                int concurrentConnections &#x3D; serverStats.getActiveRequestsCount(currentTime);</span><br><span class="line">                if (concurrentConnections &lt; minimalConcurrentConnections) &#123;</span><br><span class="line">                    minimalConcurrentConnections &#x3D; concurrentConnections;</span><br><span class="line">                    chosen &#x3D; server;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (chosen &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return super.choose(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return chosen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="RandomRule-随机-请勿使用，见github-issue链接"><a href="#RandomRule-随机-请勿使用，见github-issue链接" class="headerlink" title="RandomRule(随机) 请勿使用，见github issue链接"></a>RandomRule(随机) 请勿使用，见github issue链接</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">    if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Server server &#x3D; null;</span><br><span class="line"></span><br><span class="line">    while (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 可用服务提供者列表</span><br><span class="line">        List&lt;Server&gt; upList &#x3D; lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allList &#x3D; lb.getAllServers();</span><br><span class="line"></span><br><span class="line">        int serverCount &#x3D; allList.size();</span><br><span class="line">        if (serverCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * No servers. End regardless of pass, because subsequent passes</span><br><span class="line">             * only get more restrictive.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; index &#x3D; ThreadLocalRandom.current().nextInt(serverCount)</span><br><span class="line">        int index &#x3D; chooseRandomInt(serverCount);</span><br><span class="line">        &#x2F;&#x2F; upList获取可用实例，越界警告</span><br><span class="line">        server &#x3D; upList.get(index);</span><br><span class="line"></span><br><span class="line">        if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * The only time this should happen is if the server list were</span><br><span class="line">             * somehow trimmed. This is a transient condition. Retry after</span><br><span class="line">             * yielding.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (server.isAlive()) &#123;</span><br><span class="line">            return (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Shouldn&#39;t actually happen.. but must be transient or a bug.</span><br><span class="line">        server &#x3D; null;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return server;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请勿使用该规则，在获取提供者时server = upList.get(index);其中upList是可用提供者列表，而index是由所有提供者数量生成的随机数，这可能会产生越界错误(当有server处于非UP时)，去github上查了下这个bug一直没修：<a href="https://github.com/Netflix/ribbon/issues/233" target="_blank" rel="noopener">RandomRule incorrect index bug</a></p>
<h6 id="RetryRule"><a href="#RetryRule" class="headerlink" title="RetryRule"></a>RetryRule</h6><p>重试机制，需配合其他规则使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class RetryRule extends AbstractLoadBalancerRule &#123;</span><br><span class="line">	&#x2F;&#x2F; 默认规则轮询，可设</span><br><span class="line">	IRule subRule &#x3D; new RoundRobinRule();</span><br><span class="line">    &#x2F;&#x2F; 默认重试时长</span><br><span class="line">	long maxRetryMillis &#x3D; 500;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 请求时间</span><br><span class="line">		long requestTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F; 截至时间</span><br><span class="line">		long deadline &#x3D; requestTime + maxRetryMillis;</span><br><span class="line"></span><br><span class="line">		Server answer &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 根据子规则选取服务提供者</span><br><span class="line">		answer &#x3D; subRule.choose(key);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 时间不超过deadline时，如选取失败，进行重试</span><br><span class="line">		if (((answer &#x3D;&#x3D; null) || (!answer.isAlive()))</span><br><span class="line">				&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 设定一个定时任务来执行中断以在超时时退出选取</span><br><span class="line">			InterruptTask task &#x3D; new InterruptTask(deadline</span><br><span class="line">					- System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">			while (!Thread.interrupted()) &#123;</span><br><span class="line">				answer &#x3D; subRule.choose(key);</span><br><span class="line"></span><br><span class="line">				if (((answer &#x3D;&#x3D; null) || (!answer.isAlive()))</span><br><span class="line">						&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line">					&#x2F;* pause and retry hoping it&#39;s transient *&#x2F;</span><br><span class="line">					Thread.yield();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">                	&#x2F;&#x2F; 选取成功</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            &#x2F;&#x2F; 取消该定时器</span><br><span class="line">			task.cancel();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if ((answer &#x3D;&#x3D; null) || (!answer.isAlive())) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return answer;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ZoneAvoidanceRule-区域过滤轮询"><a href="#ZoneAvoidanceRule-区域过滤轮询" class="headerlink" title="ZoneAvoidanceRule(区域过滤轮询)"></a>ZoneAvoidanceRule(区域过滤轮询)</h6><p>ZoneAvoidanceRule继承了PredicateBasedRule(见AvailabilityFilteringRule)，因为他没有重写choose方法，所以他只是在新定义的规则上对所有服务提供者进行过滤再轮询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ZoneAvoidanceRule extends PredicateBasedRule &#123;</span><br><span class="line">	&#x2F;&#x2F; 过滤条件</span><br><span class="line">    private CompositePredicate compositePredicate;</span><br><span class="line">    </span><br><span class="line">    public ZoneAvoidanceRule() &#123;</span><br><span class="line">        super();</span><br><span class="line">        ZoneAvoidancePredicate zonePredicate &#x3D; new ZoneAvoidancePredicate(this);</span><br><span class="line">        AvailabilityPredicate availabilityPredicate &#x3D; new AvailabilityPredicate(this);</span><br><span class="line">        compositePredicate &#x3D; createCompositePredicate(zonePredicate, availabilityPredicate);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private CompositePredicate createCompositePredicate(ZoneAvoidancePredicate p1, AvailabilityPredicate p2) &#123;</span><br><span class="line">    	&#x2F;&#x2F; ZoneAvoidancePredicate为主，AvailabilityPredicate为副的组合过滤条件</span><br><span class="line">        return CompositePredicate.withPredicates(p1, p2)</span><br><span class="line">                             .addFallbackPredicate(p2)</span><br><span class="line">                             .addFallbackPredicate(AbstractServerPredicate.alwaysTrue())</span><br><span class="line">                             .build();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://www.nginx.com/resources/glossary/load-balancing/" target="_blank" rel="noopener">What Is Load Balancing?</a></li>
<li><a href="https://www.cnblogs.com/wpjamer/articles/6443332.html" target="_blank" rel="noopener">解析 Nginx 负载均衡策略</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">一致哈希</a></li>
<li><a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers" target="_blank" rel="noopener">Ribbon Working with load balancers</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/13/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" data-id="ckaqo6uzn001y28o60fm6g0v9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Eclipse常用插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/12/Eclipse%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/" class="article-date">
  <time datetime="2019-03-12T10:36:08.000Z" itemprop="datePublished">2019-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/12/Eclipse%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/">Eclipse常用插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因为自己电脑出问题，借了朋友电脑，然后从头配置环境，记录下插件。</p>
<ul>
<li><p>PlamtUML plugin</p>
</li>
<li><p>Enhanced Class Decompiler</p>
</li>
<li><p><a href="https://marketplace.eclipse.org/content/memory-analyzer-0" target="_blank" rel="noopener">Memory Analyzer</a></p>
</li>
<li><p><a href="https://marketplace.eclipse.org/content/yedit" target="_blank" rel="noopener">YEdit</a></p>
</li>
</ul>
<p>在最新的EE版本(4.10，2018-12)下已经集成的常用插件：</p>
<ul>
<li><p>Buildship</p>
</li>
<li><p>EclEmma</p>
</li>
<li><p><a href="https://marketplace.eclipse.org/content/checkstyle-plug" target="_blank" rel="noopener">Checkstyle Plug-in</a></p>
</li>
<li><p><a href="https://github.com/alibaba/p3c/tree/master/eclipse-plugin" target="_blank" rel="noopener">p3c</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/12/Eclipse%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/" data-id="ckaqo6uxx000528o68wjs2fc5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spring-cloud-enreka配置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/10/spring-cloud-enreka%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2019-03-10T15:19:00.000Z" itemprop="datePublished">2019-03-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/10/spring-cloud-enreka%E9%85%8D%E7%BD%AE/">spring cloud 实践(一) enreka</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Enreka-Server搭建"><a href="#Enreka-Server搭建" class="headerlink" title="Enreka Server搭建"></a>Enreka Server搭建</h3><h5 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h5><p>在<a href="https://start.spring.io/" target="_blank" rel="noopener">SPRING INITIALIZR</a>快速构建项目，转到带全部选项，在<strong>Cloud Discovery</strong>勾选<strong>Eureka Server</strong>并创建下载项目。看到起pom文件如下：(这里我用的maven，也可以生成gradle)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.1.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br><span class="line">&lt;groupId&gt;lyyljs.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">&lt;name&gt;eureka&lt;&#x2F;name&gt;</span><br><span class="line">&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;spring-cloud.version&gt;Greenwich.RELEASE&lt;&#x2F;spring-cloud.version&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">			&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">			&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line">&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;</span><br><span class="line">	&lt;plugins&gt;</span><br><span class="line">		&lt;plugin&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;plugin&gt;</span><br><span class="line">	&lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">&lt;repositories&gt;</span><br><span class="line">	&lt;repository&gt;</span><br><span class="line">		&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">		&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">		&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">	&lt;&#x2F;repository&gt;</span><br><span class="line">&lt;&#x2F;repositories&gt;</span><br></pre></td></tr></table></figure>

<p>然后再Application.java文件里使用注解声明是<strong>Enreka Server</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaServer		&#x2F;&#x2F;通过该注解激活为Eureka服务器</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class EurekaApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着编写配置文件，这里使用application.yml：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-eureka</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8000</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>
<p>其中有几个重要的参数</p>
<ul>
<li>eureka.client.register-with-eureka ：表示是否将自己注册到Eureka Server，默认为true。单点可关闭，集群必须开启。</li>
<li>eureka.client.fetch-registry ：表示是否从Eureka Server获取注册信息，默认为true。单点可关闭，集群必须开启。</li>
<li>eureka.client.serviceUrl.defaultZone ：设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。</li>
<li>eureka.server.enable-self-preservation ：设置为false代表关闭注册中心的保护机制，默认为true。</li>
</ul>
<p>接着就可以启动server了。</p>
<p>现在还是单点，这肯定是不行的，这种关键服务如果down掉会有毁灭性的后果。所以需要配置集群。我们修改配置文件。</p>
<ul>
<li>application.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-eureka</span><br><span class="line">#  profiles:</span><br><span class="line">#    active: peer</span><br><span class="line"># peer是单注册中心配置文件，peer1,2,3为集群1,2,3配置文件</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  register:</span><br><span class="line">    port1: 8000</span><br><span class="line">    port2: 8001</span><br><span class="line">    port3: 8002</span><br></pre></td></tr></table></figure>

<ul>
<li>application-peer.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 单点配置，仅用于自己测试用</span><br><span class="line">server:</span><br><span class="line">  port: $&#123;server.register.port1&#125;</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>application-peer1.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 集群1号机</span><br><span class="line">server:</span><br><span class="line">  port: $&#123;server.register.port1&#125;</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port2&#125;&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port3&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>application-peer2.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 集群2号机</span><br><span class="line">server:</span><br><span class="line">  port: $&#123;server.register.port2&#125;</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port3&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<ul>
<li>application-peer3.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 集群3号机</span><br><span class="line">server:</span><br><span class="line">  port: $&#123;server.register.port3&#125;</span><br><span class="line">  </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port2&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>添加完成后，通过修改application.yml里<strong>spring.profiles.active</strong>打包运行，或直接打包后在java命令后添加参数<strong>java -jar eureka-0.0.1-SNAPSHOT.jar –spring.profiles.active=peer1</strong>运行。</p>
<p>我这里有三台机器，启动前两个时因为找不到第三个会报错，在全部启动起来后便不会报错。</p>
<p>在同一台机器上运行多个注册中心时容易出现<strong>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</strong>错误。这是因为Eureka server和client心跳频率低于了阈值。在没有实例的时候出现属于正常现象。</p>
<p><strong>eureka.server.renewalPercentThreshold</strong>参数定义了renews（上一分钟内收到的心跳次数）和renews threshold（server期望在每分钟中收到的心跳次数）的比值，默认值为0.85。当server在15分钟内，比值低于percent，即少了15%的微服务心跳，server会进入自我保护状态，此时server不会删除注册信息。<br>本机测试的时候可以将此值调低，stackoverflow给出的本机测试推荐值为0.49(多注册中心)，0(单注册中心)。</p>
<h5 id="enreka配置"><a href="#enreka配置" class="headerlink" title="enreka配置"></a>enreka配置</h5><p>Spring Cloud Enreka配置分为3个部分:Server,Client和Instance。<br>这里Spring Cloud Enreka版本为2.1.0-Release，对应Enreka版本为1.9.8。<br>下面说明以yml文件格式保存，对应值皆为默认值。因从java源代码查找并复制过来(不符合配置文件规范)所以需要修改才可使用。</p>
<h6 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    # 来自EurekaServerConfigBean，spring-cloud-netflix-enreka-server-2.1.0.RELEASE</span><br><span class="line">    # MINUTES &#x3D; 60 * 1000</span><br><span class="line">    aWSAccessId: null #AWS Access Id 亚马逊云使用 绑定Elastic IP </span><br><span class="line">    aWSSecretKey: null #AWS Secret Key 亚马逊云使用 绑定Elastic IP </span><br><span class="line">    eIPBindRebindRetries: 3 #绑定Elastic IP 重试次数</span><br><span class="line">    eIPBindingRetryIntervalMs: 5 * MINUTES # eIP绑定重试间隔 eIP已绑定时 也作刷新间隔</span><br><span class="line">    eIPBindingRetryIntervalMsWhenUnbound: 1 * MINUTES # eIP未被绑定时绑定重试间隔</span><br><span class="line">    route53BindRebindRetries: 3 # 绑定Route53域名重试次数</span><br><span class="line">    route53BindingRetryIntervalMs: 5 * MINUTES # 绑定Route53域名重试间隔</span><br><span class="line">    route53DomainTTL: 30  # Route53域名TTL</span><br><span class="line">    bindingStrategy: AwsBindingStrategy.EIP # 绑定策略EIP, ROUTE53, ENI</span><br><span class="line">    useAwsAsgApi: true # 是否使用 AWS API查询ASG statuses</span><br><span class="line">    aSGQueryTimeoutMs: 300 # 向AWS请求ASG信息超时时间</span><br><span class="line">    aSGUpdateIntervalMs: 5 * MINUTES # ASG信息更新间隔</span><br><span class="line">    aSGCacheExpiryTimeoutMs: 10 * MINUTES # ASG信息过期时间</span><br><span class="line">    primeAwsReplicaConnections: true # 检查是否应启动与副本的连接,在AWS，防火墙有时需要为新节点建立网络连接</span><br><span class="line">    listAutoScalingGroupsRoleName: ListAutoScalingGroups # 角色名称，用于描述从第三方AWS账户得到的自动缩放组</span><br><span class="line">    </span><br><span class="line">    enableSelfPreservation: true # 是否开启自我保护，开启后会检查renewals参数是否</span><br><span class="line">                                 # 低于renewalPercentThreshold阈值，低于时启动自我保护模式，</span><br><span class="line">                                 # 此时会关闭过期删除(注册信息)以避免因client与server之间网络不畅通导致的误删</span><br><span class="line">    renewalPercentThreshold: 0.85 # 一个周期(renewalThresholdUpdateIntervalMs)实际收到心跳包与期望收到心跳包最小比值，</span><br><span class="line">                                  # 低于该阈值开启自我保护</span><br><span class="line">    renewalThresholdUpdateIntervalMs: 15 * MINUTES # 一个间隔周期，用于心跳检测</span><br><span class="line">    expectedClientRenewalIntervalSeconds: 30 # 期望客户端发送心跳间隔时间，应与客户端发送间隔时间相同，否则自我保护机制失效</span><br><span class="line">    </span><br><span class="line">    peerEurekaNodesUpdateIntervalMs: 10 * MINUTES # 集群里eureka节点的变化信息更新的时间间隔</span><br><span class="line">    numberOfReplicationRetries: 5 # 向peer节点发送同步请求重试次数</span><br><span class="line">    peerEurekaStatusRefreshTimeIntervalMs: 30 * 1000 # 获取peer节点状态更新信息 时间间隔</span><br><span class="line">    waitTimeInMsWhenSyncEmpty: 5 * MINUTES # Eureka服务器启动时无法从对等节点获取实例时的等待时间</span><br><span class="line">    peerNodeConnectTimeoutMs: 200 # 向peer节点发送同步请求超时时间</span><br><span class="line">    peerNodeReadTimeoutMs: 200 # 从peer节点同步获取信息超时时间</span><br><span class="line">    peerNodeTotalConnections: 1000 # peer节点复制时HTTP连接最大数</span><br><span class="line">    peerNodeTotalConnectionsPerHost: 500 # 单个peer节点复制时HTTP连接最大数</span><br><span class="line">    peerNodeConnectionIdleTimeoutSeconds: 30 # HTTP连接允许的最大闲置时间</span><br><span class="line">    </span><br><span class="line">    disableDelta: false # 增量信息是否服务与客户端</span><br><span class="line">    retentionTimeInMSInDeltaQueue: 3 * MINUTES # 缓存增量信息时间，保证客户端在丢失信息时能重新获得这些信息</span><br><span class="line">    deltaRetentionTimerIntervalInMs: 30 * 1000 # 清理任务休眠间隔，用于清理过期的增量信息(delta information)</span><br><span class="line">   </span><br><span class="line">    evictionIntervalTimerInMs: 60 * 1000 # task唤醒和执行时间间隔，用于过期实例</span><br><span class="line">    </span><br><span class="line">    responseCacheAutoExpirationInSeconds: 180 # registry payload被change events失效后在cache中保存时间</span><br><span class="line">    responseCacheUpdateIntervalMs: 30 * 1000 # 缓存的客户端payload需要更新的时间间隔</span><br><span class="line">    useReadOnlyResponseCache: true # 注册信息响应缓存，使用了二级缓存结构，带有过期策略的读写缓存以及没有过期的只读缓存(com.netflix.eureka.registry.ResponseCache)</span><br><span class="line">    </span><br><span class="line">    maxIdleThreadInMinutesAgeForStatusReplication: 10 # 状态复制线程最大闲置时间(Minutes)</span><br><span class="line">    minThreadsForStatusReplication: 1 # 状态复制线程最小线程数</span><br><span class="line">    maxThreadsForStatusReplication: 1 # 状态复制线程最大线程数</span><br><span class="line">    maxElementsInStatusReplicationPool: 1000 # 状态复制线程池阻塞队列存放数量</span><br><span class="line">    </span><br><span class="line">    syncWhenTimestampDiffers: true # 当时间戳出现差异时是否同步实例</span><br><span class="line">    </span><br><span class="line">    registrySyncRetries: 0 # 在启动时从peer节点获取注册信息重试次数</span><br><span class="line">    registrySyncRetryWaitMs: 30 * 1000 # 重试同步间隔时间</span><br><span class="line">    </span><br><span class="line">    maxElementsInPeerReplicationPool: 10000 # 复制事件线程池阻塞队列限制</span><br><span class="line">    maxIdleThreadAgeInMinutesForPeerReplication: 15 # replication线程最大闲置时间</span><br><span class="line">    minThreadsForPeerReplication: 5 # replication线程池最小线程数</span><br><span class="line">    maxThreadsForPeerReplication: 20 # replication线程池最大线程数</span><br><span class="line">    maxTimeForReplication: 30000 # 丢弃replication events前尝试复制的最大时间</span><br><span class="line">    </span><br><span class="line">    disableDeltaForRemoteRegions: false # 增量信息是否服务与远程客户端</span><br><span class="line">    remoteRegionConnectTimeoutMs: 1000 # 连接远程peer节点超时时间</span><br><span class="line">    remoteRegionReadTimeoutMs: 1000 # 从远程peer节点读取信息超时时间</span><br><span class="line">    remoteRegionTotalConnections: 1000 # 远程peer节点复制时HTTP连接最大数</span><br><span class="line">    remoteRegionTotalConnectionsPerHost: 500 # 单个远程peer节点复制时HTTP连接最大数</span><br><span class="line">    remoteRegionConnectionIdleTimeoutSeconds: 30 # HTTP连接允许的最大闲置时间</span><br><span class="line">    gZipContentFromRemoteRegion: true # 远程连接是否开启gZip压缩</span><br><span class="line">    remoteRegionUrlsWithName: empty Map # HashMap  region name-remote region discovery url</span><br><span class="line">    remoteRegionUrls: null # url，该选项已被remoteRegionUrlsWithName取代</span><br><span class="line">    remoteRegionAppWhitelist: null # Map&lt;String, Set&lt;String&gt;&gt; regionName-A set of application names 应用白名单</span><br><span class="line">    remoteRegionRegistryFetchInterval: 30 # 从远端拉取注册信息时间间隔</span><br><span class="line">    remoteRegionFetchThreadPoolSize: 20 # 远端拉取注册信息线程池大小</span><br><span class="line">    remoteRegionTrustStore: &quot;&quot; # 空字符串 远端抓取信息证书文件</span><br><span class="line">    remoteRegionTrustStorePassword: changeit # 远端抓取信息证书文件密码</span><br><span class="line">    disableTransparentFallbackToOtherRegion: false # 如果本地区域中没有该应用程序的实例，则将禁用回退到远程区域中的应用程序（如果有配置）的旧行为。true 禁用旧行为</span><br><span class="line">    </span><br><span class="line">    batchReplication: false # 是否开启对群集节点之间的复制进行批处理，以提高网络效率</span><br><span class="line">    rateLimiterEnabled: false # 是否开启速率限制器</span><br><span class="line">    rateLimiterThrottleStandardClients: false # 是否对标准客户端限速 </span><br><span class="line">    rateLimiterPrivilegedClients: Collections.emptySet() # 空set 除开标准enreka客户端之外的受信客户端</span><br><span class="line">    rateLimiterBurstSize: 10 # 令牌桶算法(token bucket algorithm)的属性，速率限制的burst size</span><br><span class="line">    rateLimiterRegistryFetchAverageRate: 500 # 令牌桶算法的属性,平均执行注册请求速率</span><br><span class="line">    rateLimiterFullFetchAverageRate: 100 # 令牌桶算法的属性,平均执行请求速率</span><br><span class="line">    logIdentityHeaders: true # enreka服务器是否追踪clientAuthHeaders</span><br><span class="line">    </span><br><span class="line">    enableReplicatedRequestCompression: false # 在请求中压缩复制数据</span><br><span class="line">    jsonCodecName: null # 指定json编&#x2F;解码器类名，没有则使用默认解码器</span><br><span class="line">    xmlCodecName: null # 制定xml编&#x2F;解码器类名，没有则使用默认解码器</span><br><span class="line">    </span><br><span class="line">    minAvailableInstancesForPeerReplication: -1 # 未知含义，在EurekaServerConfigBean有，在EurekaServerConfig无，</span><br><span class="line">                          # 在spring-cloud-enraka中只有EurekaServerConfigBean和一个测试类有设定该值，但并未使用</span><br><span class="line">                          # 从字面意义看，是peer复制最少可用实例</span><br><span class="line">    initialCapacityOfResponseCache: 1000 # responseCache初始缓存大小</span><br><span class="line">    </span><br><span class="line">    myUrl: null # 定义自身url,用于Eureka URLs不匹配IP地址或hostname时(如将enreka实例放在负载均衡器下)</span><br><span class="line">                # 需要使用完整地址，如http:&#x2F;&#x2F;eureka-node1.mydomain.com:8010&#x2F;eureka&#x2F;v2&#x2F;</span><br></pre></td></tr></table></figure>

<h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    # 来自EurekaClientConfigBean，spring-cloud-netflix-enreka-client-2.1.0.RELEASE</span><br><span class="line">    # DEFAULT_PREFIX: &#x2F;eureka</span><br><span class="line">    # DEFAULT_URL: &quot;http:&#x2F;&#x2F;localhost:8761&quot; + DEFAULT_PREFIX + &quot;&#x2F;&quot;</span><br><span class="line">    # DEFAULT_ZONE: defaultZone</span><br><span class="line">    # MINUTES: 60</span><br><span class="line">    </span><br><span class="line">    enabled: true # 是否开启enreka client</span><br><span class="line">    registryFetchIntervalSeconds: 30 # 从enreka服务器抓取注册信息频率</span><br><span class="line">    instanceInfoReplicationIntervalSeconds: 30 # 复制实例变化信息到eureka服务器频率</span><br><span class="line">    initialInstanceInfoReplicationIntervalSeconds: 40 # 初始复制实例信息到eureka服务器时长</span><br><span class="line">    eurekaServiceUrlPollIntervalSeconds: 5 * MINUTES # 询问Eureka Server信息变化的时间间隔</span><br><span class="line">    </span><br><span class="line">    proxyPort: null # 获取eureka服务的代理端口</span><br><span class="line">    proxyHost: null # 获取eureka服务的代理主机</span><br><span class="line">    proxyUserName: null # 获取eureka服务的代理用户名</span><br><span class="line">    proxyPassword: null # 获取eureka服务的代理密码</span><br><span class="line">    </span><br><span class="line">    eurekaServerReadTimeoutSeconds: 8 # 建立读取enreka server超时时间</span><br><span class="line">    eurekaServerConnectTimeoutSeconds: 5 # 建立到enreka server连接超时</span><br><span class="line">    backupRegistryImpl: null # 实现了BackupRegistry接口的类名称，用于第一次从enreka服务器获取注册信息失败时降级操作</span><br><span class="line">    eurekaServerTotalConnections: 200 # 到所有enreka server的总连接数</span><br><span class="line">    eurekaServerTotalConnectionsPerHost: 50 # 到单个enreka host的总连接数</span><br><span class="line">    </span><br><span class="line">    useDnsForFetchingServiceUrls: false # eureka客户端是否应该使用DNS机制来获取eureka服务器的地址列表</span><br><span class="line">    eurekaServerURLContext: null # URL context:用于构建服务url，来连接enreka server</span><br><span class="line">                                 # 当enreka服务器ip列表来自于DNS需要使用此项</span><br><span class="line">    eurekaServerPort: null # eureka服务器的端口,当enreka服务器ip列表来自于DNS需要使用此项</span><br><span class="line">    eurekaServerDNSName: null # DNS名称，用来获取enreka服务器ip列表</span><br><span class="line">    </span><br><span class="line">    region: us-east-1 # AWS datacenters 区域</span><br><span class="line">    </span><br><span class="line">    eurekaConnectionIdleTimeoutSeconds: 30 # 与enreka服务器的http连接闲置超时时间</span><br><span class="line">    registryRefreshSingleVipAddress: null # 客户端只对一个单一的VIP注册表的信息感兴趣</span><br><span class="line">    heartbeatExecutorThreadPoolSize: 2 # 心跳线程池初始大小</span><br><span class="line">    heartbeatExecutorExponentialBackOffBound: 10 # 心跳指数回退属性，是重试延迟的最大倍数值</span><br><span class="line">    </span><br><span class="line">    cacheRefreshExecutorThreadPoolSize: 2 # 缓存刷新线程池大小</span><br><span class="line">    cacheRefreshExecutorExponentialBackOffBound: 10 # 缓存刷新回退属性，是重试延迟的最大倍数值</span><br><span class="line">    </span><br><span class="line">    serviceUrl: # zone: 服务的url&#x2F;urls(以,号分隔) url需要时全路径,如http:&#x2F;&#x2F;ec2-256-156-243-129.compute-1.amazonaws.com:7001&#x2F;eureka&#x2F;</span><br><span class="line">      DEFAULT_ZONE: DEFAULT_URL # client下端注释值</span><br><span class="line">      </span><br><span class="line">    gZipContent: true # 连接是否开启gZip压缩</span><br><span class="line">    </span><br><span class="line">    registerWithEureka: true # 是否注册该实例到enreka服务器</span><br><span class="line">    preferSameZoneEureka: true # 实例是否使用同一zone里的eureka服务器</span><br><span class="line">    </span><br><span class="line">    logDeltaDiff: false # 是否记录eureka服务器和客户端之间在注册表的信息方面的差异</span><br><span class="line">                        # enreka客户端每次从服务器仅取服务器增加的信息以减少网络开销；收到增量信息后，</span><br><span class="line">                        # enreka客户端会向服务器验证是否有差异(丢失)。如果这个过程失败则会尝试获取全部信息。</span><br><span class="line">                        # 当获取全部信息时，是否记录服务器信息与本地信息的差异</span><br><span class="line">    disableDelta: false # 见上，是否关闭增量更新</span><br><span class="line">    fetchRemoteRegionsRegistry: null # 逗号隔开的区域列表，用来获取服务注册信息</span><br><span class="line">    availabilityZones: new HashMap&lt;&gt;() # 逗号隔开的实例所在的地区下可用性的区域列表(AWS datacenter下使用)</span><br><span class="line">    filterOnlyUpInstances: true # 仅获取实例状态为UP的应用</span><br><span class="line">    fetchRegistry: true # 是否从enreka server获取注册信息</span><br><span class="line">    </span><br><span class="line">    dollarReplacement: _- # 在与enreka服务器通信(反)序列化替换$</span><br><span class="line">    escapeCharReplacement: __ # 同上，替换_符号</span><br><span class="line">    allowRedirects: false # 允许server重定向client的请求</span><br><span class="line">    </span><br><span class="line">    onDemandUpdateStatusChange: true # 本地状态更新是否触发频率受限的on-demand更新到enreka server</span><br><span class="line">    encoderName: null # 临时配置选项配置使用编码器，当最新的编码器稳定后移除</span><br><span class="line">    decoderName: null # 同上</span><br><span class="line">    clientDataAccept: EurekaAccept.full.name() # full, compact 客户端数据接收使用的EurekaAccept名称</span><br><span class="line">    </span><br><span class="line">    shouldUnregisterOnShutdown: true # 客户端关闭时向enreka server注销</span><br><span class="line">    </span><br><span class="line">    shouldEnforceRegistrationAtInit: false # 客户端初始化期间是否强制注册</span><br><span class="line">    order: 0 # CompositeDiscoveryClient用来排序可用客户端</span><br></pre></td></tr></table></figure>

<h6 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    # 来自EurekaInstanceConfigBean，spring-cloud-netflix-enreka-client-2.1.0.RELEASE</span><br><span class="line">    # UNKNOWN: unknown</span><br><span class="line">    </span><br><span class="line">    # spring boot actuator</span><br><span class="line">    actuatorPrefix: &#x2F;actuator # actuator endpoints默认前缀</span><br><span class="line">    statusPageUrlPath: actuatorPrefix + &quot;&#x2F;info&quot; # 状态信息页面相对路径</span><br><span class="line">    statusPageUrl: null # 状态信息页面绝对路径</span><br><span class="line">    homePageUrlPath: &#x2F; # 主页相对路径</span><br><span class="line">    homePageUrl: null # 主页绝对路径</span><br><span class="line">    healthCheckUrlPath: actuatorPrefix + &quot;&#x2F;health&quot; # 健康检查相对路径</span><br><span class="line">    healthCheckUrl: null # 健康检查绝对路径</span><br><span class="line">    secureHealthCheckUrl: null # 安全端口健康检查绝对路径</span><br><span class="line">    </span><br><span class="line">    appname: unknown # 应用注册名 如未设定appname，则查询spring.application.name，如皆未设定，则为unknown</span><br><span class="line">    appGroupName: null # 应用组名称</span><br><span class="line">    instanceEnabledOnit: false # 实例注册到eureka服务器时，是否马上开始通讯</span><br><span class="line">    nonSecurePort: 80 # 非加密接受通讯端口</span><br><span class="line">    securePort: 443 # 加密接受通讯端口</span><br><span class="line">    nonSecurePortEnabled: true # 是否使用非加密接受通讯端口</span><br><span class="line">    securePortEnabled: false # 是否使用加密接受通讯端口</span><br><span class="line">    leaseRenewalIntervalInSeconds: 30 # enreka客户端发送心跳间隔</span><br><span class="line">    leaseExpirationDurationInSeconds: 90 # 心跳过期时间，enreka服务端在接收心跳后，如在此时间内未收到下一跳，则删除该实例</span><br><span class="line">    virtualHostName: unknown # 虚拟主机名 未设定该值则为spring.application.name，如皆未设定，则为unknown</span><br><span class="line">    instanceId: null # 实例id，实例注册到eureka服务端的唯一的实例ID,未设定则从metadataMap查询</span><br><span class="line">    secureVirtualHostName: unknown # 安全虚拟主机名 如未设定，则查询spring.application.name，如皆未设定，则为unknown</span><br><span class="line">    aSGName: null # AWS autoscaling group name</span><br><span class="line">    metadataMap: new HashMap # enreka元数据，元数据被发送到eureka服务器，其他实例可以使用</span><br><span class="line">    dataCenterInfo: MyOwn # DataCenterInfo.Name.MyOwn Netflix, Amazon, MyOwn 该实例被部署的数据中心</span><br><span class="line">    ipAddress: null # 实例的ip地址，无配置会使用默认发现的第一个非回环地址 相关类 org.springframework.cloud.commons.util.InetUtils</span><br><span class="line">    namespace: eureka # 用于查找属性的命名空间，Spring Cloud中会被忽略</span><br><span class="line">    hostname: null # 配置的主机名，无配置会从OS中获取。 InetUtils</span><br><span class="line">    preferIpAddress: false # IP优先于(取代)从OS中获取的主机名。 InetUtils</span><br><span class="line">    initialStatus: UP # InstanceStatus.UP&#x2F;DOWN&#x2F;STARTING&#x2F;OUT_OF_SERVICE&#x2F;UNKNOWN</span><br><span class="line">                      # 注册到enreka server时实例状态</span><br><span class="line">                      # UP:可以通讯   DOWN:下线，禁止通讯，health check失败时</span><br><span class="line">                      # STARTING: 正在进行初始化，禁止通讯  OUT_OF_SERVICE: 主动离线</span><br><span class="line">                      # UNKNOWN: 未知</span><br></pre></td></tr></table></figure>

<h5 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h5><ul>
<li><p><a href="https://blog.asarkar.org/technical/netflix-eureka/#" target="_blank" rel="noopener">Spring Cloud Netflix Eureka - The Hidden Manual</a></p>
</li>
<li><p><a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1195" target="_blank" rel="noopener">EMERGENCY! EUREKA MAY…</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/33921557/understanding-spring-cloud-eureka-server-self-preservation-and-renew-threshold" target="_blank" rel="noopener">Understanding Spring Cloud Eureka Server self preservation and renew threshold</a></p>
</li>
<li><p><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">github eureka</a></p>
</li>
<li><p><a href="https://github.com/Netflix/eureka/wiki" target="_blank" rel="noopener">Enreka Wiki</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/10/spring-cloud-enreka%E9%85%8D%E7%BD%AE/" data-id="ckaqo6uyy000y28o67pg55ivg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elastic-search/" rel="tag">elastic search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elk/" rel="tag">elk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%91%BD%E4%BB%A4/" rel="tag">java命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stream/" rel="tag">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/elastic-search/" style="font-size: 10px;">elastic search</a> <a href="/tags/elk/" style="font-size: 10px;">elk</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/java%E5%91%BD%E4%BB%A4/" style="font-size: 17.5px;">java命令</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">java基础</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/spring-cloud/" style="font-size: 20px;">spring cloud</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/05/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E5%9F%9F%E5%90%8D%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/">反向代理解决微信小程序业务域名限制问题</a>
          </li>
        
          <li>
            <a href="/2019/05/13/Stream-%E7%BC%96%E7%A8%8B%E8%83%8C%E5%90%8E/">Stream实现原理</a>
          </li>
        
          <li>
            <a href="/2019/05/04/jdk8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">jdk8函数式编程</a>
          </li>
        
          <li>
            <a href="/2019/04/27/OWASP%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/">OWASP第三方依赖检查插件使用</a>
          </li>
        
          <li>
            <a href="/2019/04/11/docker%E6%90%AD%E5%BB%BAjenkins/">docker搭建jenkins</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 lyyljs<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>