<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>lyyljs`s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="java">
<meta property="og:type" content="website">
<meta property="og:title" content="lyyljs&#96;s blog">
<meta property="og:url" content="http://lyyljs.site/page/3/index.html">
<meta property="og:site_name" content="lyyljs&#96;s blog">
<meta property="og:description" content="java">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lyyljs">
<meta property="article:tag" content="开发者">
<meta property="article:tag" content="程序猿">
<meta property="article:tag" content="程序媛">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="代码">
<meta property="article:tag" content="Developer">
<meta property="article:tag" content="Programmer">
<meta property="article:tag" content="Coder">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="lyyljs`s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lyyljs`s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lyyljs.site"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-服务调用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/06/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" class="article-date">
  <time datetime="2019-03-06T14:50:00.000Z" itemprop="datePublished">2019-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/06/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/">spring cloud 实践(二)  服务调用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在注册中心解决了服务发现问题以后，就可以进行服务调用了。首先创建一个服务提供者。</p>
<p>依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>编写yml写好配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-producer</span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 9000</span><br><span class="line">  register:</span><br><span class="line">    port1: 8000</span><br><span class="line">    port2: 8001</span><br><span class="line">    port3: 8002</span><br><span class="line">    </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>
<p>然后在入口Application.java的class上加上注解<strong>@EnableDiscoveryClient</strong>以开启服务注册与发现。</p>
<p>接着就可以写我们的服务了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">	</span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String index(@RequestParam String name) &#123;</span><br><span class="line">        return &quot;Hello &quot; + name + &quot;, Welcome to Spring Cloud.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样服务提供者就写好了，开启服务提供者。在Enreka控制台查看：<br><img src="/images/cloud/ProducerInstance1.png" alt="ProducerInstance1" title="ProducerInstance1"><br>可以看到服务已注册到Enreka Server。</p>
<p>浏览器访问地址 <a href="http://localhost:9000/hello?name=lyyljs" target="_blank" rel="noopener">http://localhost:9000/hello?name=lyyljs</a> 看见返回信息 Hello lyyljs, Welcome to Spring Cloud. 则说明服务正常。</p>
<p>然后编写一个服务消费者，依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">Feign</a></strong>是一个声明web服务客户端，可以使编写web服务客户端更容易。同时，<strong>Feign</strong>的<strong>ribbon</strong>模块和<strong>hystrix</strong>模块分别对<strong>ribbon</strong>与<strong>hystrix</strong>进行封装来实现负载均衡与熔断功能。</p>
<hr>
<p>同样，写好配置文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-consumer</span><br><span class="line">    </span><br><span class="line">server:</span><br><span class="line">  port: 9001</span><br><span class="line">  register:</span><br><span class="line">    port1: 8000</span><br><span class="line">    port2: 8001</span><br><span class="line">    port3: 8002</span><br><span class="line">    </span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.register.port1&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>
<p>在启动class上加上注解<strong>@EnableDiscoveryClient</strong> <strong>@EnableFeignClients</strong>。<br>按照Feign方法写好接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FeignClient(name&#x3D; &quot;spring-cloud-producer&quot;)</span><br><span class="line">public interface HelloService &#123;</span><br><span class="line">	@RequestMapping(value &#x3D; &quot;&#x2F;hello&quot;)</span><br><span class="line">    public String hello(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是WEB Controller</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ConsumerController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HelloService helloService;</span><br><span class="line">	</span><br><span class="line">    @RequestMapping(&quot;&#x2F;hello&#x2F;&#123;name&#125;&quot;)</span><br><span class="line">    public String index(@PathVariable(&quot;name&quot;) String name) &#123;</span><br><span class="line">        return helloService.hello(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样消费者demo也就写好了，启动起来。在注册中心可以看到<br><img src="/images/cloud/ConsumerInstance1.png" alt="ConsumerInstance1" title="ConsumerInstance1"></p>
<p>访问 <a href="http://localhost:9001/hello/lyyljs" target="_blank" rel="noopener">http://localhost:9001/hello/lyyljs</a> 看见返回 Hello lyyljs, Welcome to Spring Cloud. 信息说明消费者正常调用服务提供者的服务并返回信息。</p>
<hr>
<p>相关链接：</p>
<ul>
<li><a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">Github Feign</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/06/%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8/" data-id="ckaqo6uzu002828o6emcq0vzl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-分布式服务注册中心" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/02/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/" class="article-date">
  <time datetime="2019-03-02T20:33:00.000Z" itemprop="datePublished">2019-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/02/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/">分布式服务注册中心</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>在微服务架构中，一般每一个服务都是有多个拷贝，来做负载均衡。一个服务随时可能下线，也可能应对临时访问压力增加新的服务节点。服务之间如何相互感知？服务如何管理？这时就轮到注册中心出场了。</p>
<p>服务提供者启动后首先向注册中心注册当前地址，服务调用者向注册中心查询提供者的地址来调用服务。</p>
<p><img src="/images/cloud/DubboArchitecture.png" alt="Dubbo" title="Dubbo"></p>
<p>上图是<strong>Dubbo</strong>框架图，<strong>Registry</strong>即是注册中心，通常使用<strong>zookeeper</strong>。</p>
<p>在<strong>Spring cloud</strong>中，则大部分使用<strong>eureka</strong>作为注册中心。其框架图如下：</p>
<p><img src="/images/cloud/EurekaArchitecture.png" alt="Eureka" title="Dubbo"></p>
<p>除了这两者之外，还有<strong>Consul</strong>、<strong>etcd</strong>等可以选择，它们同异如下表：</p>
<table>
<thead>
<tr>
<th align="center">Feature</th>
<th align="center">Consul</th>
<th align="center">zookeeper</th>
<th align="center">etcd</th>
<th align="center">euerka</th>
</tr>
</thead>
<tbody><tr>
<td align="center">服务健康检查</td>
<td align="center">服务状态，内存，硬盘等</td>
<td align="center">(弱)长连接，keepalive</td>
<td align="center">连接心跳</td>
<td align="center">可配支持</td>
</tr>
<tr>
<td align="center">多数据中心</td>
<td align="center">支持</td>
<td align="center">—</td>
<td align="center">—</td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">kv存储服务</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">一致性</td>
<td align="center">raft</td>
<td align="center">paxos</td>
<td align="center">raft</td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">cap</td>
<td align="center">ca</td>
<td align="center">cp</td>
<td align="center">cp</td>
<td align="center">ap</td>
</tr>
<tr>
<td align="center">使用接口(多语言能力)</td>
<td align="center">支持http和dns</td>
<td align="center">客户端</td>
<td align="center">http/grpc</td>
<td align="center">http（sidecar）</td>
</tr>
<tr>
<td align="center">watch支持</td>
<td align="center">全量/支持long polling</td>
<td align="center">支持</td>
<td align="center">支持 long polling</td>
<td align="center">支持 long polling/大部分增量</td>
</tr>
<tr>
<td align="center">自身监控</td>
<td align="center">metrics</td>
<td align="center">—</td>
<td align="center">metrics</td>
<td align="center">metrics</td>
</tr>
<tr>
<td align="center">安全</td>
<td align="center">acl/https</td>
<td align="center">acl</td>
<td align="center">https支持（弱）</td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">spring cloud集成</td>
<td align="center">已支持</td>
<td align="center">已支持</td>
<td align="center">已支持</td>
<td align="center">已支持</td>
</tr>
</tbody></table>
<h5 id="关于CAP"><a href="#关于CAP" class="headerlink" title="关于CAP"></a>关于<strong>CAP</strong></h5><p>CAP理论是分布式架构中重要理论:</p>
<p>一致性(Consistency) (所有节点在同一时间具有相同的数据)</p>
<p>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</p>
<p>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</p>
<p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。</p>
<p><strong>Eureka</strong>典型的AP,作为分布式场景下的服务发现的产品较为合适，服务发现场景的可用性优先级较高，一致性并不是特别致命。其次 CA 类型的场景 Consul,也能提供较高的可用性，并能 k-v store 服务保证一致性。 而Zookeeper,Etcd则是CP类型，牺牲可用性，在服务发现场景并没太大优势。</p>
<p>在部署注册中心集群的时候需要注意的是除了<strong>Eureka</strong>对部署数量没有特别的限制外，其他三种都因为使用了一致性协议(paxos，raft)需要部署<strong>基数</strong>个。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://luyiisme.github.io/2017/04/22/spring-cloud-service-discovery-products/?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">服务发现比较:Consul vs Zookeeper vs Etcd vs Eureka</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/02/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/" data-id="ckaqo6uze001n28o65rybf0v0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ClassLoader与热加载" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/26/ClassLoader%E4%B8%8E%E7%83%AD%E5%8A%A0%E8%BD%BD/" class="article-date">
  <time datetime="2019-02-26T18:39:27.000Z" itemprop="datePublished">2019-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/26/ClassLoader%E4%B8%8E%E7%83%AD%E5%8A%A0%E8%BD%BD/">ClassLoader与热加载</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>非工程用，仅作原理展示。下面示例代码为同一个包”package lyyljs.hotclassloader;”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Printer &#123;</span><br><span class="line">	public boolean print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;测试用类</span><br><span class="line">public class Test implements Printer&#123;</span><br><span class="line"></span><br><span class="line">	public boolean print()&#123;</span><br><span class="line">		System.out.println(&quot;Test Out&quot;);</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;自定义的类加载器</span><br><span class="line">public class HotClassLoader extends ClassLoader&#123;</span><br><span class="line"></span><br><span class="line">	private String path;</span><br><span class="line">	</span><br><span class="line">	public HotClassLoader(String path)&#123;</span><br><span class="line">		this.path &#x3D; path;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 实现查找类</span><br><span class="line">	 * @param name 类名，如果属于package，则为package.class</span><br><span class="line">	 * @return 加载的class</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	protected Class&lt;?&gt; findClass(String name)&#123;</span><br><span class="line">		&#x2F;&#x2F;转换class名称为全路径，</span><br><span class="line">		String fullPath &#x3D; path + </span><br><span class="line">				name.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;</span><br><span class="line">		</span><br><span class="line">		byte[] cls &#x3D; loadFile(fullPath);</span><br><span class="line"> 		</span><br><span class="line">        &#x2F;&#x2F;加载实际使用defineClass，加载字节码、解析、验证</span><br><span class="line">		return defineClass(name, cls, 0, cls.length);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 读取文件转换为byte[]</span><br><span class="line">	 * @param filePath 文件路径，包含文件名</span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private byte[] loadFile(String filePath)&#123;</span><br><span class="line">		try &#123;</span><br><span class="line">            InputStream is &#x3D; new FileInputStream(filePath);</span><br><span class="line">            ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();</span><br><span class="line">            byte[] buffer &#x3D; new byte[2048];</span><br><span class="line">            int num &#x3D; 0;</span><br><span class="line">            while ((num &#x3D; is.read(buffer)) !&#x3D; -1) &#123;</span><br><span class="line">                bos.write(buffer, 0, num);</span><br><span class="line">            &#125;</span><br><span class="line">            return bos.toByteArray();</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">public class ClassCompiler &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;JavaFileObject接口实现类，用于JavaCompiler编译源码</span><br><span class="line">	static class StrJavaFileObject extends SimpleJavaFileObject &#123;</span><br><span class="line"></span><br><span class="line">		final String code;</span><br><span class="line">		</span><br><span class="line">		protected StrJavaFileObject(String name, String code) &#123;</span><br><span class="line">        &#x2F;&#x2F;Kind枚举类位于JavaFileObject接口，Kind.SOURCE.extension是java文件的后缀(&quot;.java&quot;)</span><br><span class="line">			super(URI.create(&quot;string:&#x2F;&#x2F;&#x2F;&quot; + name.replace(&#39;.&#39;,&#39;&#x2F;&#39;) + Kind.SOURCE.extension), Kind.SOURCE);</span><br><span class="line">			this.code &#x3D; code;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		@Override</span><br><span class="line">        &#x2F;&#x2F;SimpleJavaFileObject未实现该方法，FileObject获取内容用</span><br><span class="line">		public CharSequence getCharContent(boolean ignoreEncodingErrors) &#123;</span><br><span class="line">			return code;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;使用当前线程的资源绝对路径</span><br><span class="line">	public static String getDefaultOutPath()&#123;</span><br><span class="line">		String outDir &#x3D; &quot;&quot;;</span><br><span class="line">		try &#123;</span><br><span class="line">            File classPath &#x3D; new File(Thread.currentThread().getContextClassLoader()</span><br><span class="line">            		.getResource(&quot;&quot;).toURI());</span><br><span class="line">            outDir &#x3D; classPath.getAbsolutePath() + File.separator;</span><br><span class="line">        &#125; catch (URISyntaxException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">		return outDir;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;编译Java文件，filePath是文件路径</span><br><span class="line">	public boolean compileJavaFile(String filePath)&#123;</span><br><span class="line">		</span><br><span class="line">		JavaCompiler compiler &#x3D; ToolProvider.getSystemJavaCompiler();</span><br><span class="line">		</span><br><span class="line">		Iterable&lt;String&gt; options &#x3D; Arrays.asList(&quot;-d&quot;, getDefaultOutPath());</span><br><span class="line">		</span><br><span class="line">		Iterable&lt;? extends JavaFileObject&gt; compilationUnits &#x3D; compiler</span><br><span class="line">				.getStandardFileManager(null, null, null)</span><br><span class="line">                .getJavaFileObjectsFromFiles(Arrays.asList(new File(</span><br><span class="line">                		filePath)));</span><br><span class="line">		</span><br><span class="line">		return compiler.getTask(null, null,</span><br><span class="line">        		null, options, null, compilationUnits).call();</span><br><span class="line">	&#125;</span><br><span class="line">    &#x2F;&#x2F; 将JavaCompiler.getTask搬过来</span><br><span class="line">    &#x2F;&#x2F;	CompilationTask getTask(Writer out, &#x2F;&#x2F;additional output</span><br><span class="line">	&#x2F;&#x2F;            JavaFileManager fileManager,&#x2F;&#x2F;null使用编译器标准文件管理器</span><br><span class="line">	&#x2F;&#x2F;            DiagnosticListener&lt;? super JavaFileObject&gt; diagnosticListener,&#x2F;&#x2F;诊断监听器，null时使用默认方法报告诊断信息</span><br><span class="line">	&#x2F;&#x2F;            Iterable&lt;String&gt; options,&#x2F;&#x2F;编译参数，null时没有编译参数</span><br><span class="line">	&#x2F;&#x2F;            Iterable&lt;String&gt; classes,&#x2F;&#x2F;待编译类名，可为null</span><br><span class="line">	&#x2F;&#x2F;            Iterable&lt;? extends JavaFileObject&gt; compilationUnits);&#x2F;&#x2F;待编译的代码</span><br><span class="line">    &#x2F;&#x2F; getTask创建了一个编译任务，task.call()执行该编译任务</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;编译类</span><br><span class="line">    &#x2F;&#x2F;className是类名(无需带包名)，javaCodes是该类的代码</span><br><span class="line">    public boolean compile(String className, String javaCodes) &#123;</span><br><span class="line">        JavaCompiler compiler &#x3D; ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        </span><br><span class="line">        StrJavaFileObject srcObject &#x3D; new StrJavaFileObject(className, javaCodes);</span><br><span class="line">        Iterable&lt;? extends JavaFileObject&gt; fileObjects &#x3D; Arrays.asList(srcObject);</span><br><span class="line">        </span><br><span class="line">        Iterable&lt;String&gt; options &#x3D; Arrays.asList(&quot;-d&quot;, getDefaultOutPath());</span><br><span class="line"></span><br><span class="line">        return compiler.getTask(null, null,</span><br><span class="line">        		null, options, null, fileObjects).call();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    	String classPath &#x3D; ClassCompiler.getDefaultOutPath();</span><br><span class="line">    	String javaFilePath &#x3D; &quot;****\\Test.java&quot;;</span><br><span class="line">    	</span><br><span class="line">    	String code &#x3D; &quot;package lyyljs.hotclassloader;&quot;</span><br><span class="line">    		    + &quot;public class Test implements Printer &#123;&quot; </span><br><span class="line">    		    + &quot;public boolean print() &#123;&quot; </span><br><span class="line">    		    + &quot;System.out.println(\&quot;Test1 Out\&quot;);&quot; </span><br><span class="line">    		    + &quot;return true;&quot;</span><br><span class="line">    		    + &quot;&#125;&#125;&quot;;</span><br><span class="line">    	</span><br><span class="line">    	ClassCompiler cc &#x3D; new ClassCompiler();</span><br><span class="line">    	</span><br><span class="line">        &#x2F;&#x2F;一个ClassLoader不能重复加载某个class</span><br><span class="line">    	HotClassLoader clsLoader1 &#x3D; new HotClassLoader(classPath);</span><br><span class="line">    	HotClassLoader clsLoader2 &#x3D; new HotClassLoader(classPath);</span><br><span class="line">    	</span><br><span class="line">    	boolean result &#x3D; cc.compileJavaFile(javaFilePath);</span><br><span class="line">    	</span><br><span class="line">    	if (!result)&#123;</span><br><span class="line">    		System.out.println(&quot;compile Test failed!&quot;);</span><br><span class="line">    		return;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	Class clazz &#x3D; clsLoader1.findClass(&quot;lyyljs.hotclassloader.Test&quot;);</span><br><span class="line">    	try &#123;</span><br><span class="line">			Printer p1 &#x3D; (Printer) clazz.newInstance();</span><br><span class="line">			p1.print();</span><br><span class="line">		&#125; catch (InstantiationException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    	</span><br><span class="line">    	result &#x3D; cc.compile(&quot;Test&quot;, code);</span><br><span class="line">    	clazz &#x3D; clsLoader2.findClass(&quot;lyyljs.hotclassloader.Test&quot;);</span><br><span class="line">    	</span><br><span class="line">    	try &#123;</span><br><span class="line">			Printer p2 &#x3D; (Printer) clazz.newInstance();</span><br><span class="line">			p2.print();</span><br><span class="line">		&#125; catch (InstantiationException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">Test Out</span><br><span class="line">Test1 Out</span><br></pre></td></tr></table></figure>

<p>关于热加载方案可参见<a href="https://yq.aliyun.com/articles/65023" target="_blank" rel="noopener">漫谈JVM热加载技术</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/02/26/ClassLoader%E4%B8%8E%E7%83%AD%E5%8A%A0%E8%BD%BD/" data-id="ckaqo6uxl000128o682q7brg1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EagerThreadPool" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/24/EagerThreadPool/" class="article-date">
  <time datetime="2019-02-24T19:18:00.000Z" itemprop="datePublished">2019-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/24/EagerThreadPool/">EagerThreadPool</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先来回顾下Java提供的默认线程池的工作流程：</p>
<ol>
<li>如果线程池线程数量未到corePoolSize，即使有空闲线程，也会立即新建线程来执行任务</li>
<li>如果线程数量已达corePoolSize，则将任务放进阻塞队列workQueue</li>
<li>如果workQueue已满，线程池没有空闲线程且线程数量未到maximumPoolSize，则新建线程执行任务</li>
<li>如果workQueue已满，总线程数又达到了maximumPoolSize，则根据饱和策略handler来处理该任务</li>
</ol>
<p>看到第二条，如果线程数量已达corePoolSize，但未达到maximumPoolSize，默认线程池还是会将任务放进阻塞队列。</p>
<p>来看这样一个场景，我们需要线程池来处理抵达的网络请求，平时我们不需要太多线程数量，高峰期需要一个大的线程数量，这是一个弹性的需求。同时高峰期我们肯定希望尽快处理网络请求，但按默认线程池处理策略，它在核心线程都在忙的时候会把请求丢到阻塞队列，然后等到阻塞队列满了才增加线程进行处理，这是我们不能接受的。这里出现的就是EagerThreadPool。</p>
<p><strong>EagerThreadPool</strong>这个名词出现在阿里的<strong>dubbo</strong>框架中，但实际上很多容器如<strong>Tomcat</strong>也使用了相同的策略；它的与默认策略不同的是当核心线程数都忙且线程数量未到达最大线程数的时候，创建新的线程来处理任务而非丢进阻塞队列，这提高了吞吐量。</p>
<p>首先来看<strong>ThreadPoolExecutor</strong>的<strong>execute</strong>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">       if (command &#x3D;&#x3D; null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       int c &#x3D; ctl.get();</span><br><span class="line">       if (workerCountOf(c) &lt; corePoolSize) &#123;&#x2F;&#x2F;当小于核心线程数的时候创建新线程</span><br><span class="line">           if (addWorker(command, true))</span><br><span class="line">               return;</span><br><span class="line">           c &#x3D; ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;&#x2F;&#x2F;核心线程数满，尝试入队</span><br><span class="line">           int recheck &#x3D; ctl.get();</span><br><span class="line">           if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">               addWorker(null, false);</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!addWorker(command, false))&#x2F;&#x2F;否则增加非核心线程执行</span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看到，我们需要介入的是<strong>workQueue.offer(command)</strong>这里的行为，只要这里为false，那么自然就会去创建新的线程。同时，还需要扩展该<strong>execute()</strong>方法，在线程数量满的时候令任务进入阻塞队列。</p>
<p>Tomcat和Dubbo都是通过继承<strong>ThreadPoolExecutor</strong>和<strong>LinkedBlockingQueue</strong>重写<strong>execute</strong>和<strong>offer</strong>来实行这一行为的，下面来看看核心代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.tomcat.util.threads;</span><br><span class="line"></span><br><span class="line">public class TaskQueue extends LinkedBlockingQueue&lt;Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;通过设置该变量来监控线程池状态</span><br><span class="line">    private transient volatile ThreadPoolExecutor parent &#x3D; null;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;入队操作，如果非EagerThreadPool则抛出错误</span><br><span class="line">    public boolean force(Runnable o) &#123;</span><br><span class="line">        if ( parent&#x3D;&#x3D;null || parent.isShutdown() ) throw new RejectedExecutionException(sm.getString(&quot;taskQueue.notRunning&quot;));</span><br><span class="line">        return super.offer(o); &#x2F;&#x2F;forces the item onto the queue, to be used if the task is rejected</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean offer(Runnable o) &#123;</span><br><span class="line">        &#x2F;&#x2F;parent为null，则无需干预线程池行为，使用默认行为即可</span><br><span class="line">        if (parent&#x3D;&#x3D;null) return super.offer(o);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;当线程池线程数满直接放进队列</span><br><span class="line">        if (parent.getPoolSize() &#x3D;&#x3D; parent.getMaximumPoolSize()) return super.offer(o);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;getSubmittedCount是Tomcat扩展方法，获取已提交但未完成的任务数量，这里判断说明有空闲线程，那么无需新建线程，丢尽队列等待调度即可</span><br><span class="line">        if (parent.getSubmittedCount()&lt;&#x3D;(parent.getPoolSize())) return super.offer(o);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;当前线程数量是否已满，未满则返回false使线程池创建新线程</span><br><span class="line">        if (parent.getPoolSize()&lt;parent.getMaximumPoolSize()) return false;</span><br><span class="line">        </span><br><span class="line">        return super.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.tomcat.util.threads;</span><br><span class="line"></span><br><span class="line">public class ThreadPoolExecutor extends java.util.concurrent.ThreadPoolExecutor &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;已提交但未完成的任务数量，包括在队列里和已经提交给工作线程但未开始执行的任务，数值&gt;&#x3D;getActiveCount()</span><br><span class="line">    private final AtomicInteger submittedCount &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    public int getSubmittedCount() &#123;</span><br><span class="line">        return submittedCount.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void execute(Runnable command, long timeout, TimeUnit unit) &#123;</span><br><span class="line">        submittedCount.incrementAndGet();</span><br><span class="line">        try &#123;</span><br><span class="line">        	&#x2F;&#x2F;首先执行ThreadPoolExecutor的execute，这里已经通过TaskQueue实现先新建线程而非入队</span><br><span class="line">            super.execute(command);</span><br><span class="line">        &#125; catch (RejectedExecutionException rx) &#123;</span><br><span class="line">        	&#x2F;&#x2F;判断是否使用TaskQueue，即是否使用的EagerThreadPool</span><br><span class="line">            if (super.getQueue() instanceof TaskQueue) &#123;</span><br><span class="line">                final TaskQueue queue &#x3D; (TaskQueue)super.getQueue();</span><br><span class="line">                try &#123;</span><br><span class="line">                	&#x2F;&#x2F;如果尝试入队失败</span><br><span class="line">                    if (!queue.force(command, timeout, unit)) &#123;</span><br><span class="line">                        submittedCount.decrementAndGet();</span><br><span class="line">                        throw new RejectedExecutionException(sm.getString(&quot;threadPoolExecutor.queueFull&quot;));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (InterruptedException x) &#123;</span><br><span class="line">                &#x2F;&#x2F;尝试入队出错处理</span><br><span class="line">                    submittedCount.decrementAndGet();</span><br><span class="line">                    throw new RejectedExecutionException(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                submittedCount.decrementAndGet();</span><br><span class="line">                throw rx;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这些修改，就改变了默认策略，改变了线程池工作流程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/02/24/EagerThreadPool/" data-id="ckaqo6uxs000328o6c1bn5otq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2019-02-19T17:58:18.000Z" itemprop="datePublished">2019-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">java多线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JVM的资源调度是以线程进行的，这可以更好的利用cpu的资源，所以需要我们对java多线程进行熟练掌握。</p>
<h3 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h3><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单元。</p>
<p>在java中，线程既是一个<em>java.lang.Thread</em>类的一个实例，也指运行中的线程。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>在Java中，线程可为以下状态：</p>
<ul>
<li><strong>New</strong> 线程未调用start方法，对应Thread.State.NEW</li>
<li><strong>Runnable</strong> 就绪，等待调度程序运行。当调用start方法后进入此状态。对应Thread.State.RUNNABLE</li>
<li><strong>Running</strong> 线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</li>
<li><strong>Blocked</strong> 等待/阻塞/睡眠。线程此时仍然存活，但因缺少运行条件不能进入就绪状态。可因其他事件导致条件满足返回就绪状态。对应Thread.State.BLOCKED/Thread.State.WAITING/Thread.State.TIMED_WAITING</li>
<li><strong>Dead</strong> 线程的run()方法完成，对应Thread.State.TERMINATED</li>
</ul>
<p><img src="/images/thread_status.png" alt="线程状态转换" title="线程状态转换"></p>
<p>使用<strong>jstack</strong>命令可以打印Java线程栈信息，其与java状态对应如下表。</p>
<p><img src="/images/vm_thread.jpg" alt="线程对应关系" title="线程状态转换"></p>
<p>线程分为用户线程以及守护线程。一般的，守护线程用于gc等后台非必要操作。在jvm启动后，以main()为入口开启线程作为主线程。当所有的非守护线程消亡后，jvm即可推出，同时关闭守护线程。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p><strong>线程安全</strong>指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。下面展示了一段非线程安全的案例，因编译器和处理器指令重排序导致得不到想要结果。<br><img src="/images/statement_reordering.png" alt="语句重排序" title="statement_reordering"><br>更详细的内容可参照Oracle的<strong>JSR133</strong>文档。</p>
<h3 id="互斥机制"><a href="#互斥机制" class="headerlink" title="互斥机制"></a>互斥机制</h3><h5 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h5><p>在操作系统进程我们使用<strong>信号量(semaphore)</strong>和<strong>互斥量(mutex)</strong>来控制进入临界区的多个进程。在使用互斥量机制时非常容易出错，因为我们需要去亲自操作变量以及对进程进行阻塞和唤醒。而java使用了<strong>monitor</strong>机制来实现对临界区的访问管理，而无法进入<strong>monitor</strong>临界区的线程，它们则被阻塞，并且在必要的时候会被唤醒。并且对外屏蔽掉这些机制，并且在内部实现这些机制，使得使用<strong>monitor</strong>的人看到的是一个简洁易用的接口。</p>
<p>使用<strong>monitor</strong>机制的目的主要是为了互斥进入临界区；在java中，可以采用<strong>synchronized</strong>关键字来修饰实例方法、类方法以及代码块，而被<strong>synchronized</strong>关键字修饰的方法、代码块，就是<strong>monitor</strong>机制的临界区。<strong>synchronized</strong>如果修饰实例方法，则默认对象是<strong>this</strong>；若修饰类方法，则对象为<strong>this.class</strong>。</p>
<p>java中的java.lang.Object类充当着维护互斥量以及定义wait/signal API来管理线程的阻塞和唤醒的角色。java.lang.Object类定义了 wait()，notify()，notifyAll()方法，它们原理如下图：</p>
<p><img src="/images/monitor.png" alt="ObjectMonitor" title="ObjectMonitor"></p>
<p>当一个线程需要获取Object的锁时，会被放入EntrySet中进行等待。如果该线程通过竞争获取了该锁，则成为了该锁的The Owner。如果Owner发现因为某些原因使得程序无法进行下去(如消费者发现资源队列为空时)，可以通过wait释放锁并进入WaitSet,这可以使得其他需要该锁的线程可以重新竞争该锁。当条件得到满足时该进程又可加入到锁的竞争中去。</p>
<p>wait/notify必须存在于synchronized块中。并且，这三个关键字针对的是同一个监视器（某对象的监视器）。这意味着wait之后，其他线程可以进入同步块执行。</p>
<p>使用synchronized/wait/notify实现的一个典型的生产者消费者代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">public class ProducerConsumer &#123;</span><br><span class="line"></span><br><span class="line">	static final int MIN_STORGE &#x3D; 0;</span><br><span class="line">	static final int MAX_STORGE &#x3D; 10;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 产品</span><br><span class="line">	 * @field producerName 生产者名称</span><br><span class="line">	 * @filed value 随机值</span><br><span class="line">	 * @author lyyljs</span><br><span class="line">	 *</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static class Product&#123;</span><br><span class="line">		private String producerName;</span><br><span class="line">		private long value;</span><br><span class="line">		</span><br><span class="line">		Product(String producerName, long value)&#123;</span><br><span class="line">			this.producerName &#x3D; producerName;</span><br><span class="line">			this.value &#x3D; value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public String getProducerName() &#123;</span><br><span class="line">			return producerName;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void setProducerName(String producerName) &#123;</span><br><span class="line">			this.producerName &#x3D; producerName;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public long getValue() &#123;</span><br><span class="line">			return value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void setValue(long value) &#123;</span><br><span class="line">			this.value &#x3D; value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public String toString() &#123;</span><br><span class="line">			return &quot;Product [生产者:&quot; + producerName + &quot;, value&#x3D;&quot; + value + &quot;]&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 消费者</span><br><span class="line">	 * @field name 消费者名称</span><br><span class="line">	 * @filed queue 商品库,临界资源</span><br><span class="line">	 * @author lyyljs</span><br><span class="line">	 *</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static class Consumer implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">		private String name;</span><br><span class="line">		private List&lt;Product&gt; queue;</span><br><span class="line">		</span><br><span class="line">		Consumer(String name, List&lt;Product&gt; queue)&#123;</span><br><span class="line">			this.name &#x3D; name;</span><br><span class="line">			this.queue &#x3D; queue;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		void consume(String name)&#123;</span><br><span class="line">			synchronized(queue)&#123;&#x2F;&#x2F;对queue加锁，防止其他线程操作</span><br><span class="line">				if (queue.size() &lt;&#x3D; MIN_STORGE)&#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.println(name + &quot;尝试消费，但缺货&quot;);</span><br><span class="line">						queue.wait();</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				Product p &#x3D; queue.remove(0);</span><br><span class="line">				System.out.println(name + &quot;消费了一个商品&quot; + p);</span><br><span class="line">				queue.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			while (true)&#123;</span><br><span class="line">				consume(name);</span><br><span class="line">				</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(1000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 生产者</span><br><span class="line">	 * @field name 生产者名称</span><br><span class="line">	 * @field queue 商品库,临界资源</span><br><span class="line">	 * @author lyyljs</span><br><span class="line">	 *</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static class Producer implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">		private String name;</span><br><span class="line">		private List&lt;Product&gt; queue;</span><br><span class="line">		</span><br><span class="line">		Producer(String name, List&lt;Product&gt; queue)&#123;</span><br><span class="line">			this.name &#x3D; name;</span><br><span class="line">			this.queue &#x3D; queue;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		void produce(String name)&#123;</span><br><span class="line">			synchronized (queue)&#123;&#x2F;&#x2F;对queue加锁，防止其他线程操作</span><br><span class="line">				if (queue.size() &gt;&#x3D; MAX_STORGE)&#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						System.out.println(name + &quot;尝试生产，但满仓&quot;);</span><br><span class="line">						queue.wait();</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				queue.add(new Product(name, ThreadLocalRandom.current().nextLong(100)));</span><br><span class="line">				System.out.println(name + &quot;生产了一个商品&quot;);</span><br><span class="line">				queue.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			while (true)&#123;</span><br><span class="line">				produce(name);</span><br><span class="line">				</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(1000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		List&lt;Product&gt; list &#x3D; new ArrayList&lt;Product&gt;();</span><br><span class="line">		ExecutorService pool &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">		</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class="line">			pool.submit(new Consumer(&quot;consumer_&quot; + i, list));</span><br><span class="line">			pool.submit(new Producer(&quot;producer_&quot; + i, list));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其部分执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">consumer_0尝试消费，但缺货</span><br><span class="line">producer_0生产了一个商品</span><br><span class="line">producer_2生产了一个商品</span><br><span class="line">producer_1生产了一个商品</span><br><span class="line">consumer_2消费了一个商品Product [生产者:producer_0, value&#x3D;96]</span><br><span class="line">consumer_1消费了一个商品Product [生产者:producer_2, value&#x3D;68]</span><br><span class="line">consumer_2消费了一个商品Product [生产者:producer_1, value&#x3D;74]</span><br><span class="line">consumer_1尝试消费，但缺货</span><br></pre></td></tr></table></figure>

<h3 id="线程内存"><a href="#线程内存" class="headerlink" title="线程内存"></a>线程内存</h3><p><img src="/images/thread_JMM.png" alt="thread_JMM" title="thread_JMM"></p>
<ul>
<li>主内存（Main Memory）：所有变量的存储位置。直接对应于物理硬件的内存。</li>
<li>工作内存（Working Memory）：每条线程还有自己的工作内存，用于保存被该线程使用到的变量的主内存副本拷贝。为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中。</li>
</ul>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p>多线程在对同一个变量进行操作的时候很有可能产生不可预知的结果(一个线程修改了这个值，但是之后在另一个线程看到的是修改之前的值)。此时<strong>volatile</strong>可以解决可见性问题。<strong>volatile</strong>保证了对一个<strong>volatile</strong>变量的写操作先行发生于后面对这个变量的读操作。本质上，<strong>volatile</strong>既是不去取工作内存的缓存值而是直接去取主内存的值。在线程安全的情况下会牺牲性能。详细参见<a href="https://www.jianshu.com/p/506c1e38a922" target="_blank" rel="noopener">volatile关键字解惑</a>。</p>
<h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><p>ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量，这意味着线程修改该副本不会影响到其他副本。常见的用法有:存储单个线程上下文信息。比如存储id等，示例如dubbo调用链中生成id追踪调用链；使变量线程安全。变量既然成为了每个线程内部的局部变量，自然就不会存在并发问题了，示例如数据库session连接管理。</p>
<p>ThreadLocal里类型的变量，其实是放入了当前Thread里。每个Thread都有一个threadLocals。threadLocals是一个ThreadLocalMap。TreadLocalMap是一个Map，它以ThreadLocal本身为Key(这里实际是ThreadLocal的弱引用WeakReference&lt;ThreadLocal&lt;?&gt;&gt;)，value为Object。当设置一个ThreadLocal变量时，这个map里就多了一对ThreadLocal -&gt; Object的映射。</p>
<p><img src="/images/ThreadLocal.png" alt="ThreadLocal" title="ThreadLocal"></p>
<p>使用ThreadLocal时需要注意可能存在的内存泄露问题，见<a href="http://www.importnew.com/22039.html" target="_blank" rel="noopener">深入分析 ThreadLocal 内存泄漏问题</a>。</p>
<h3 id="常用类与接口"><a href="#常用类与接口" class="headerlink" title="常用类与接口"></a>常用类与接口</h3><h4 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h4><ul>
<li><strong>Runnable</strong></li>
</ul>
<p>最常见的创建一个线程的方法即实现该接口，通过run()启动线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Producer implements Runnable&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">    &#x2F;&#x2F; do something;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">	Producer thread &#x3D; new Producer();</span><br><span class="line">    thread.run();&#x2F;&#x2F;启动线程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Thread</strong></li>
</ul>
<p>Thread类实现了Runnable接口，并提供了丰富的方法。</p>
<ul>
<li><strong>start()</strong> 自定义线程启动，同runnable的run()</li>
<li><strong>yield()</strong> 线程让步，先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把CPU的占有权交给次线程，否则继续运行原来的线程。如持有锁则不会释放锁。</li>
<li><strong>sleep(TimeMillis)</strong> 使当前线程休眠指定时间(ms)。同yield如持有锁则不会释放锁。</li>
<li><strong>join(TimeMillis)</strong> JDK文档里描述为Waits for this thread to die.用于等待指定线程完成后再继续执行。从源码里可以看出实际上是执行了在不断检测线程存活并wait()。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        long base &#x3D; System.currentTimeMillis();</span><br><span class="line">        long now &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            while (isAlive()) &#123;&#x2F;&#x2F;判断线程是否存活</span><br><span class="line">                wait(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay &#x3D; millis - now;</span><br><span class="line">                if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>wait()和sleep()</strong>：wait()是Object的方法，且会释放锁让其他线程可以竞争锁;sleep()是Thread的方法，其只将线程暂停，让其他线程得到执行的机会，如果持有锁则并不会释放锁。</p>
<ul>
<li><strong>Callable,Future,FutureTask</strong></li>
</ul>
<p>不同于Runnable没有返回值，Callable可以拿到返回结果。使用Future/FutureTask获取Callable的返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">	static class Task implements Callable&lt;Integer&gt;&#123;</span><br><span class="line"></span><br><span class="line">		public Integer call() throws Exception &#123;</span><br><span class="line">			System.out.println(&quot;child thread sleeping&quot;);</span><br><span class="line">			</span><br><span class="line">			TimeUnit.SECONDS.sleep(1L);&#x2F;&#x2F;同Thread.sleep(1000)</span><br><span class="line">			</span><br><span class="line">			System.out.println(&quot;child thread executing&quot;);</span><br><span class="line">			</span><br><span class="line">			int sum &#x3D; 0;</span><br><span class="line">			</span><br><span class="line">			for (int i &#x3D; 0; i &lt;&#x3D; 1000; i++) &#123;</span><br><span class="line">	            sum +&#x3D; i;</span><br><span class="line">	        &#125;</span><br><span class="line">			</span><br><span class="line">			return sum;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Task task &#x3D; new Task();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;使用Future获取返回结果</span><br><span class="line">		ExecutorService executor &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">		Future&lt;Integer&gt; result &#x3D; executor.submit(task);</span><br><span class="line">		executor.shutdown();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;使用FutureTask获取返回结果,因为FutureTask继承RunnableFuture接口,所以可以直接new Thread(FutureTask),这里实际使用了new Thread(Runnable)</span><br><span class="line">&#x2F;&#x2F;		FutureTask&lt;Integer&gt; result &#x3D; new FutureTask&lt;Integer&gt;(task);</span><br><span class="line">&#x2F;&#x2F;		Thread thread &#x3D; new Thread(result);</span><br><span class="line">&#x2F;&#x2F;		thread.start();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;master thread executing&quot;);</span><br><span class="line">		</span><br><span class="line">		if (!result.isDone())&#123;</span><br><span class="line">			System.out.println(&quot;child thread has not done&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if (!result.isCancelled())&#123;</span><br><span class="line">			System.out.println(&quot;child thread has not cancelled&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		try &#123;</span><br><span class="line">			Integer sum &#x3D; result.get();</span><br><span class="line">			System.out.println(&quot;result:&quot; + sum);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; catch (ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">master thread executing</span><br><span class="line">child thread has not done</span><br><span class="line">child thread has not cancelled</span><br><span class="line">child thread sleeping</span><br><span class="line">child thread executing</span><br><span class="line">result:500500</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>CountDownLatch</strong></li>
</ul>
<p>类似于join；不同于join，调用join方法需要等待thread执行完毕才能继续向下执行,而CountDownLatch只需要检查计数器的值为零就可以继续向下执行，相比之下，CountDownLatch更加灵活一些，可以实现一些更加复杂的业务场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">final CountDownLatch cd &#x3D; new CountDownLatch(SIZE);</span><br><span class="line">for (int i &#x3D; 0; i &lt; SIZE; i++)&#123;</span><br><span class="line">	new Thread(() -&gt; &#123;  </span><br><span class="line">      try &#123;  </span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;  </span><br><span class="line">      	e.printStackTrace();  </span><br><span class="line">      &#125; finally&#123;</span><br><span class="line">      	cd.countDown();&#x2F;&#x2F;减去计数</span><br><span class="line">  	&#125;</span><br><span class="line">   &#125;).start(); </span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">	cd.await();&#x2F;&#x2F;阻塞主线程，等待所有子线程执行完毕</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">	&#x2F;&#x2F;deal Exception</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子线程任务都完成后继续主线程逻辑</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>CyclicBarrier</strong></li>
</ul>
<p>可以让一组线程等待至某个状态之后再全部同时执行。如await有指定时间且到达时间有线程未就绪则其它就绪线程抛出BrokenBarrierException继续执行后面任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final CyclicBarrier cb &#x3D; new CyclicBarrier(SIZE);</span><br><span class="line">for (int i &#x3D; 0; i &lt; SIZE; i++)&#123;</span><br><span class="line">	new Thread(() -&gt; &#123;  </span><br><span class="line">      try &#123;  </span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">        cb.await();&#x2F;&#x2F;阻塞线程直到其他所有线程都到达该点然后继续执行下面的代码</span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">      &#125; catch (InterruptedException | BrokenBarrierException e1) &#123;  </span><br><span class="line">      	e1.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;).start(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Phaser</strong></li>
</ul>
<p>Phaser是JDK 7新增的一个同步辅助类，在功能上跟CyclicBarrier和CountDownLatch差不多，但支持更丰富的用法：使用过程中可以随时注册和注销参与者；不同于CyclicBarrier，分离出”到达”和”等待”机制；支持结束，默认情况下，当没有参与者的时候Phaser就结束了；支持层级Phaser结构；提供针对内部状态的监控方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重要方法</span><br><span class="line">public int register();	&#x2F;&#x2F;注册到Phaser</span><br><span class="line">public int bulkRegister(int parties);	&#x2F;&#x2F;register的批量注册方法</span><br><span class="line">public int arrive();	&#x2F;&#x2F;记录到达状态</span><br><span class="line">public int arriveAndDeregister();	&#x2F;&#x2F;抵达并注销</span><br><span class="line">public int arriveAndAwaitAdvance();	&#x2F;&#x2F;抵达并等待其它线程达到</span><br><span class="line">protected boolean onAdvance(int phase, int registeredParties);	&#x2F;&#x2F;覆写该方法来定义抵达动作并控制终止条件</span><br><span class="line">public int awaitAdvance(int phase);	&#x2F;&#x2F;当phase大于给定数时返回</span><br><span class="line">public int getRegisteredParties();	&#x2F;&#x2F;获取parties数</span><br><span class="line">public int getArrivedParties();	&#x2F;&#x2F;已经到达当前phase的parties数</span><br><span class="line">public int getUnarrivedParties();	&#x2F;&#x2F;剩余的未到达parties数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;分层示例</span><br><span class="line">void build(Task[] tasks, int lo, int hi, Phaser ph) &#123;</span><br><span class="line">    	 if (hi - lo &gt; TASKS_PER_PHASER) &#123;&#x2F;&#x2F;如果大于每阶段任务数则分层</span><br><span class="line">    	   for (int i &#x3D; lo; i &lt; hi; i +&#x3D; TASKS_PER_PHASER) &#123;</span><br><span class="line">    	     int j &#x3D; Math.min(i + TASKS_PER_PHASER, hi);</span><br><span class="line">    	     build(tasks, i, j, new Phaser(ph));&#x2F;&#x2F;进行分层</span><br><span class="line">    	   &#125;</span><br><span class="line">    	 &#125; else &#123;</span><br><span class="line">    	   for (int i &#x3D; lo; i &lt; hi; ++i)</span><br><span class="line">    	     tasks[i] &#x3D; new Task(ph);&#x2F;&#x2F;假定在new Task(ph)中执行了ph.register()</span><br><span class="line">    	 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">build(new Task[n], 0, n, new Phaser());</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Semaphore</strong></li>
</ul>
<p>Java中信号量的实现类。同样提供公平锁与非公平两种机制。内部调度同样基于<strong>AQS</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;几个重要的方法</span><br><span class="line">&#x2F;&#x2F;阻塞的方法</span><br><span class="line">public void acquire();	&#x2F;&#x2F;获取一个许可，若未获得，则会一直等待，直到获得许可。</span><br><span class="line">public void acquire(int permits);	&#x2F;&#x2F;获取permits个许可</span><br><span class="line">public void release();	&#x2F;&#x2F;释放一个许可</span><br><span class="line">public void release(int permits);	&#x2F;&#x2F;释放permits个许可</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;非阻塞方法</span><br><span class="line">public boolean tryAcquire();	&#x2F;&#x2F;尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false</span><br><span class="line">public boolean tryAcquire(long timeout, TimeUnit unit);	&#x2F;&#x2F;尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false</span><br><span class="line">public boolean tryAcquire(int permits);	&#x2F;&#x2F;尝试获取permits个许可</span><br><span class="line">public boolean tryAcquire(int permits, long timeout, TimeUnit unit);	&#x2F;&#x2F;尝试获取permits个许可</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>TimeUnit</strong></li>
</ul>
<p>时间单元类。支持有：<strong>DAYS</strong>,<strong>HOURS</strong>,<strong>MINUTS</strong>,<strong>SECONDS</strong>,<strong>MILLISECONDS</strong>,<strong>MICROSECONDS</strong>,<strong>NANOSECONDS</strong>。除了提供时间转换方法以外，该类还提供了快捷的指定时间的wait/sleep/join方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void timedWait(Object obj, long timeout);</span><br><span class="line">public void timedJoin(Thread thread, long timeout);</span><br><span class="line">public void sleep(long timeout);</span><br></pre></td></tr></table></figure>
<h4 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h4><p>原子类，使用原子类可以保证原子操作。</p>
<ul>
<li><strong>AtomicBoolean,AtomicInteger,AtomicLong,AtomicReference</strong><br>这四种基本类型用来处理布尔，整数，长整数，对象四种数据。</li>
<li><strong>LongAdder,LongAccumulator,DoubleAdder,DoubleAccumulator</strong><br>这四种类是jdk1.8新增，他们都继承了<strong>Striped64</strong>。<strong>Striped64</strong>是在java8中添加用来支持累加器的并发组件，其设计类似于分段锁算法，在竞争激烈的时候尽量分散竞争。LongAdder基本可以替换掉AtomicLong，在高并发情况下性能更高。LongAccumulator对LongAdder进行了扩展；LongAdder只支持加减，而LongAccumulator则提供了自定义函数操作。</li>
<li><strong>AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray</strong><br>这三类提供了对数组的原子操作。</li>
<li><strong>AtomicLongFieldUpdater,AtomicIntegerFieldUpdater,AtomicReferenceFieldUpdater</strong><br>这三类基于反射，提供对对象域的原子操作。</li>
<li><strong>AtomicMarkableReference,AtomicStampedReference</strong><br>这两类解决了ABA问题。本质上是采用了版本号对修改进行了记录。AtomicStampedReference是使用pair的int stamp作为计数器使用，它记录了修改了几次，AtomicMarkableReference的pair使用的是boolean mark，它则是记录是否被修改。</li>
</ul>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h5 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h5><ul>
<li><strong>独享锁/共享锁</strong> <strong>独享锁</strong>是指该锁一次只能被一个线程所持有(可看作信号量为1)，<strong>共享锁</strong>是指该锁可被多个线程所持有(可看作信号量大于1)。</li>
<li><strong>互斥锁/读写锁</strong> <strong>互斥锁</strong>是独享锁的具体实现，<strong>读写锁</strong>是共享锁的具体实现。</li>
<li><strong>公平锁/非公平锁</strong> <strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁。而<strong>非公平锁</strong>则是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，可能会造成优先级反转或者饥饿现象。</li>
<li><strong>可重入锁</strong> <strong>可重入锁</strong>又名<strong>递归锁</strong>，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</li>
<li><strong>乐观锁/悲观锁</strong> 乐观锁与悲观锁并不是具体的锁，而是看待并发同步的角度。<strong>乐观锁</strong>认为不存在很多的并发更新操作，不加锁是安全的。在innodb的读操作就采取了乐观锁(MVCC，有效范围为REPEATABLE READ和READ COMMITTED)。在Java中，常常采取CAS实现，例如Atomic类的更新。<strong>悲观锁</strong>则认为存在很多并发更新操作，一定需要加锁来确保安全。</li>
<li><strong>分段锁</strong> 分段锁同样不是具体的锁，而是一种锁的设计。它是通过更细的粒度来降低每一粒度的并发，从而减少冲突。在<strong>ConcurrentHashMap</strong>和<strong>Striped64</strong>就体现了这种设计思想。</li>
<li><strong>自旋锁</strong> 自旋锁是指尝试获取锁的线程不会阻塞，而是采用循环的方式尝试获取锁。好处是减少上下文切换，缺点是一直占用CPU资源。低并发下使用。自旋锁属于<strong>乐观锁</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SpinLock &#123;&#x2F;&#x2F;一个简单的自旋锁</span><br><span class="line">    private AtomicReference&lt;Thread&gt; cas &#x3D; new AtomicReference&lt;Thread&gt;();</span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        Thread current &#x3D; Thread.currentThread();</span><br><span class="line">        while (!cas.compareAndSet(null, current));&#x2F;&#x2F;循环获取锁</span><br><span class="line">    &#125;</span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        Thread current &#x3D; Thread.currentThread();</span><br><span class="line">        cas.compareAndSet(current, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>偏向锁/轻量级锁/重量级锁</strong> 这是针对<strong>Synchronized</strong>做的优化。<strong>偏向锁</strong>是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。当锁是偏向锁的时候，被另一个线程所访问时，会将锁升级为<strong>轻量级锁</strong>。此时未获得锁的线程会通过<strong>自旋</strong>来尝试获取锁。在<strong>自旋</strong>超过一定次数任未获得锁时，则升级为<strong>重量级锁</strong>。<strong>偏向锁</strong>和<strong>轻量级锁</strong>都属于<strong>乐观锁</strong>。</li>
</ul>
<h5 id="locks"><a href="#locks" class="headerlink" title="locks"></a>locks</h5><ul>
<li><strong>synchronized</strong> </li>
</ul>
<p><strong>synchronized</strong>属于<strong>互斥锁</strong>，同一时间仅允许一个线程访问临界资源。在公平锁/非公平锁上属于<strong>非公平锁</strong>，是由竞争来获取锁所有权。同时<strong>synchronized</strong>也是<strong>可重入锁</strong>，即一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法不会出现死锁，即以下代码是合法的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">synchronized void functionA() throws Exception&#123;</span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">    functionB();&#x2F;&#x2F;重入该对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized void functionB() throws Exception&#123;</span><br><span class="line">    &#x2F;&#x2F;do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/JUCL_UML.png" alt="JUCL_UML" title="JUCL_UML"></p>
<ul>
<li><strong>AbstractOwnableSynchronizer(AOS);AbstractQueuedLongSynchronizer(AQLS)/AbstractQueuedSynchronizer(AQS)</strong></li>
</ul>
<p><strong>AOS</strong>为创建锁和相关同步器的所有权提供了一个标准，它本身不管理和提供任何信息，需要由子类来实现。它的两个子类即使<strong>AQS</strong>和<strong>AQLS</strong>。<strong>AQS</strong>和<strong>AQLS</strong>通过<strong>CLH队列</strong>与共享资源<strong>state</strong>来管理线程关于锁的使用和同步。需要注意的是它们并不参与具体如何获取和释放锁，这需要由子类来实现。<strong>AQLS</strong>相较于<strong>AQS</strong>的区别在于内部acquire和release的arg参数是long而不是int类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;需要子类实现其获取和释放锁的方法，AQLS其入参类型为long</span><br><span class="line">protected boolean tryAcquire(int arg);&#x2F;&#x2F;尝试获取锁，用于独享锁</span><br><span class="line">protected boolean tryRelease(int arg);&#x2F;&#x2F;尝试释放锁，用于独享锁</span><br><span class="line">protected int tryAcquireShared(int arg);&#x2F;&#x2F;尝试获取锁，用于共享锁</span><br><span class="line">protected boolean tryReleaseShared(int arg);&#x2F;&#x2F;尝试释放锁，用于共享锁</span><br></pre></td></tr></table></figure>

<p><img src="/images/AQS.png" alt="AQS" title="AQS"></p>
<ul>
<li><strong>Condition</strong> </li>
</ul>
<p>在JUC(java.util.concurrent)下实现类似<strong>wait/notify</strong>的功能。Condition将Object监视器方法（wait、notify和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用，为每个对象提供多个等待 set（wait-set）。其中，Lock 替代了synchronized方法和语句的使用，Condition替代了 Object监视器方法的使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;JDK示例代码</span><br><span class="line">class BoundedBuffer &#123;</span><br><span class="line">     final Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">     final Condition notFull &#x3D; lock.newCondition();&#x2F;&#x2F;其实现在AQS里ConditionObject</span><br><span class="line">     final Condition notEmpty &#x3D; lock.newCondition();</span><br><span class="line"></span><br><span class="line">     final Object[] items &#x3D; new Object[100];</span><br><span class="line">     int putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">     public void put(Object x) throws InterruptedException &#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">          try &#123;</span><br><span class="line">               while (count &#x3D;&#x3D; items.length)</span><br><span class="line">                    notFull.await();&#x2F;&#x2F;将该线程挂起并移到等待队列中</span><br><span class="line">               items[putptr] &#x3D; x;</span><br><span class="line">               if (++putptr &#x3D;&#x3D; items.length) putptr &#x3D; 0;</span><br><span class="line">               ++count;</span><br><span class="line">               notEmpty.signal();&#x2F;&#x2F;通知等待队列</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public Object take() throws InterruptedException &#123;</span><br><span class="line">          lock.lock();</span><br><span class="line">          try &#123;</span><br><span class="line">               while (count &#x3D;&#x3D; 0)</span><br><span class="line">                    notEmpty.await();</span><br><span class="line">               Object x &#x3D; items[takeptr];</span><br><span class="line">               if (++takeptr &#x3D;&#x3D; items.length) takeptr &#x3D; 0;</span><br><span class="line">               --count;</span><br><span class="line">               notFull.signal();</span><br><span class="line">               return x;</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Lock</strong> </li>
</ul>
<p>抽象接口，提供类似<strong>synchronized</strong>的功能，在JUC.locks下主要实现为<strong>ReentrantLock</strong>。其与<strong>synchronized</strong>区别主要如下:</p>
<hr>
<ol>
<li>使用上lock必须使用finally释放锁，否则会容易造成死锁；lock更灵活，可以自由定义多把锁的枷锁解锁顺序，synchronized要按照先加的后解顺序。</li>
<li>在加锁方案上提供多种加锁方案，lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式， 还有trylock的带超时时间版本。</li>
<li>锁类型上两者皆是可重入锁，但lock提供公平锁的方案。</li>
<li>性能lock相比synchronized更高。</li>
</ol>
<hr>
<ul>
<li><strong>LockSupport</strong> </li>
</ul>
<p>工具类，操作对象是线程，基于Unsafe类实现。基本操作park和unpark。park会把使得线程挂起，直到出现以下几种情况中的一种：其他线程调用unpark方法操作该线程；该线程被中断；park方法立刻返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重要的方法</span><br><span class="line">public static void park();</span><br><span class="line">public static void parkNanos(long nanos);</span><br><span class="line">public static void parkUntil(long deadline);</span><br><span class="line">public static void unpark(Thread thread);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用示例：一个先进先出的互斥队列</span><br><span class="line">public class FIFOMutex &#123;</span><br><span class="line">	 private final AtomicBoolean locked &#x3D; new AtomicBoolean(false);</span><br><span class="line">	 private final Queue&lt;Thread&gt; waiters &#x3D; new ConcurrentLinkedQueue&lt;Thread&gt;();</span><br><span class="line">	 </span><br><span class="line">	 public void lock() &#123;</span><br><span class="line">	     boolean wasInterrupted &#x3D; false;</span><br><span class="line">	     Thread current &#x3D; Thread.currentThread();</span><br><span class="line">	     waiters.add(current);</span><br><span class="line">	     </span><br><span class="line">	     &#x2F;&#x2F; 非队首或不能获取锁的时候挂起</span><br><span class="line">	     while (waiters.peek() !&#x3D; current ||</span><br><span class="line">	          !locked.compareAndSet(false, true)) &#123;	 </span><br><span class="line">	         LockSupport.park(this);</span><br><span class="line">	         if (Thread.interrupted()) &#x2F;&#x2F; 在等待的时候忽略中断</span><br><span class="line">	             wasInterrupted &#x3D; true;</span><br><span class="line">	     &#125;</span><br><span class="line">	     </span><br><span class="line">	     waiters.remove();</span><br><span class="line">	     if (wasInterrupted)          &#x2F;&#x2F; 重新设定中断状态并退出</span><br><span class="line">	    	 current.interrupt();</span><br><span class="line">	 &#125;</span><br><span class="line">	 </span><br><span class="line">	 public void unlock() &#123;</span><br><span class="line">	     locked.set(false);</span><br><span class="line">	     LockSupport.unpark(waiters.peek());</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ReadWriteLock</strong> </li>
</ul>
<p>读写锁接口，实现是<strong>ReentrantReadWriteLock</strong>。和<strong>Lock</strong>接口无关。读写锁在实现上保持了两个锁:读锁与写锁。其中读锁是共享锁，可被多个线程同时读取；写锁是独享锁，仅能被单个线程占有。</p>
<ul>
<li><strong>ReentrantLock</strong> </li>
</ul>
<p>可重入锁，是<strong>Lock</strong>的实现类。控制方法采用<strong>AQS</strong>；其内部有<strong>NonfairSync</strong>非公平和<strong>FairSync</strong>公平两种实现，默认非公平。使用示例见<strong>Condition</strong>下JDK示例。</p>
<ul>
<li><strong>ReentrantReadWriteLock</strong> </li>
</ul>
<p>可重入读写锁，是<strong>ReadWriteLock</strong>的实现类。内部持有一个<strong>ReadLock</strong>与一个<strong>WriteLock</strong>。同样使用<strong>AQS</strong>控制调度，也有<strong>NonfairSync</strong>非公平和<strong>FairSync</strong>公平两种实现，默认非公平。在自定义的<strong>Sync</strong>抽象类中(继承<strong>AQS</strong>)，<strong>state</strong>高位的16位是共享锁的状态，低位的16位是独占锁的状态，以此来同时管理两种锁并实现读写互斥。</p>
<ul>
<li><strong>StampedLock</strong> </li>
</ul>
<p>可简单理解为读写锁的一个改进版本。读写锁读写互斥；而<strong>StampedLock</strong>则提供了乐观的读策略，在读的时候发现有写操作，再去读多一次，这使得读操作不会阻塞写操作。需要注意的是，<strong>StampedLock是不可重入的</strong>，这使得如果一个线程已经持有了写锁，再去获取写锁的话就会造成死锁。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p><img src="/images/ThreadPool_UML.png" alt="ThreadPool_UML" title="ThreadPool_UML"></p>
<ul>
<li><strong>Executor/ExecutorService/ScheduledExecutorService</strong></li>
</ul>
<p>JUC中三个接口；<strong>Executor</strong>提供了一个运行新任务的简单接口；<strong>ExecutorService</strong>扩展了<strong>Executor</strong>接口，添加了一些用来管理执行器生命周期和任务生命周期的方法；<strong>ScheduledExecutorService</strong>则在<strong>ExecutorService</strong>基础上增添了一些计划任务方法。</p>
<ul>
<li><strong>ThreadPoolExecutor</strong></li>
</ul>
<p><strong>ThreadPoolExecutor</strong>是线程池的核心类。它的构造函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler);</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><strong>corePoolSize</strong> 线程池核心线程数</li>
<li><strong>maximumPoolSize</strong> 线程池最大数量</li>
<li><strong>keepAliveTime</strong> 超出corePoolSize数量的线程的保留时间。</li>
<li><strong>unit</strong> keepAliveTime单位。见JUC里TimeUnit。</li>
<li><strong>workQueue</strong> 阻塞队列，存放来不及执行的线程。<strong>BlockingQueue</strong>接口在JUC里有以下实现类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity);&#x2F;&#x2F;默认非公平的array实现，可以通过另一个构造方法使用公平调度</span><br><span class="line"></span><br><span class="line">public DelayQueue();&#x2F;&#x2F;队列内元素必须实现Delayed接口，这就意味着你传进去的任务必须先实现Delayed接口。这个队列接收到任务时，首先先入队，只有达到了指定的延时时间，才会执行任务。</span><br><span class="line"></span><br><span class="line">public LinkedBlockingQueue();&#x2F;&#x2F;链表实现，其大小默认Integer.MAX_VALUE，可手动通过另一构造方法指定大小，否则当有大量请求任务时，容易造成OOM。</span><br><span class="line"></span><br><span class="line">public SynchronousQueue();&#x2F;&#x2F;同步队列，这是一个不存储元素的特殊队列，它负责把生产者线程处理的数据直接传递给消费者线程，默认非公平；公平时构造TransferQueue实现公平交易，否则构造TransferStack实现非公平交易。实际上，这个队列接收到任务的时候，会直接提交给线程处理，而不保留它。</span><br><span class="line"></span><br><span class="line">public LinkedTransferQueue();&#x2F;&#x2F;SynchronousQueue在交易时只有一个空位，而LinkedTransferQueue则是由多个空位(链表)来存储待交易的节点进行匹配</span><br><span class="line"></span><br><span class="line">public PriorityBlockingQueue();&#x2F;&#x2F;带优先级的阻塞队列，其默认大小为11；它在PriorityQueue的基础上增加了阻塞，队列不支持插入null元素，同时不支持插入非comparable的对象。</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>threadFactory</strong> 用来创建新线程。默认使用Executors.defaultThreadFactory()来创建线程。</li>
<li><strong>handler</strong> 线程池的饱和策略。如果阻塞队列满了并且没有空闲的线程，这时如果继续提交任务，就需要采取一种策略处理该任务。如果需要自定义策略，可实现<strong>RejectedExecutionHandler</strong>接口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public CallerRunsPolicy();&#x2F;&#x2F;用调用者所在的线程来执行任务</span><br><span class="line">public AbortPolicy();&#x2F;&#x2F;直接抛出异常,默认策略</span><br><span class="line">public DiscardPolicy();&#x2F;&#x2F;什么都不做，意即丢弃任务</span><br><span class="line">public DiscardOldestPolicy();&#x2F;&#x2F;丢弃阻塞队列中靠最前的任务，并执行当前任务</span><br></pre></td></tr></table></figure>

<p>当向线程池添加任务时：</p>
<ol>
<li>如果线程池线程数量未到corePoolSize，即使有空闲线程，也会立即新建线程来执行任务</li>
<li>如果线程数量已达corePoolSize，则将任务放进阻塞队列workQueue</li>
<li>如果workQueue已满，线程池没有空闲线程且线程数量未到maximumPoolSize，则新建线程执行任务</li>
<li>如果workQueue已满，总线程数又达到了maximumPoolSize，则根据饱和策略handler来处理该任务</li>
</ol>
<hr>
<ul>
<li><strong>ScheduledThreadPoolExecutor</strong></li>
</ul>
<p><strong>ScheduledThreadPoolExecutor</strong>扩展了<strong>ThreadPoolExecutor</strong>，在其基础上新增了计划任务，实现了<strong>ScheduledExecutorService</strong>接口。这里计划任务可分为两类：指定延时后执行任务；周期性重复执行任务。<br>它的构造方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ScheduledThreadPoolExecutor</span><br><span class="line">        extends ThreadPoolExecutor</span><br><span class="line">        implements ScheduledExecutorService &#123;</span><br><span class="line">	public ScheduledThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                                       ThreadFactory threadFactory,</span><br><span class="line">                                       RejectedExecutionHandler handler) &#123;</span><br><span class="line">        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,</span><br><span class="line">              new DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它是一个核心线程数为corePoolSize，最大线程数为Integer.MAX_VALUE，同时空闲线程不会因闲置时间消亡的线程池，corePoolSize是必要参数，threadFactory和handler默认情况下为Executors.defaultThreadFactory()和AbortPolicy()。特别的，这里的阻塞队列为<strong>DelayedWorkQueue</strong>，它是一个内部静态类，内部存储对象为<strong>RunnableScheduledFuture</strong>，初始数组大小为16，它保证了添加到队列中的任务，会按照任务的延时时间进行排序，延时时间少的任务首先被获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;一些重要的方法</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;指定时延后调度执行任务</span><br><span class="line">public ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       long delay,</span><br><span class="line">                                       TimeUnit unit);</span><br><span class="line">&#x2F;&#x2F;指定时延后调度执行任务                                       </span><br><span class="line">public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,</span><br><span class="line">                                           long delay,</span><br><span class="line">                                           TimeUnit unit);</span><br><span class="line">&#x2F;&#x2F;指定时延后开始执行任务，以后每隔period的时长再次执行该任务                </span><br><span class="line">public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  long initialDelay,</span><br><span class="line">                                                  long period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line">&#x2F;&#x2F;指定时延后开始执行任务，以后任务执行完成后等待delay时长，再次执行任务</span><br><span class="line">public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     long initialDelay,</span><br><span class="line">                                                     long delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Fork/Join框架与ForkJoinPool</strong></li>
</ul>
<p><strong>Fork/Join</strong>核心思想是<strong>分治</strong>，它将大任务划分为小任务并行计算，最后再将小任务结果汇总得到最终结果。<strong>fork</strong>分解任务，<strong>join</strong>汇集结果。</p>
<p>在<strong>Fork/Join</strong>框架中，若某个子问题由于等待另一个子问题的完成而无法继续执行。那么处理该子问题的线程会主动寻找其他尚未运行完成的子问题来执行。这种方式减少了线程的等待时间，提高了性能。</p>
<p>ForkJoin主要提供了两个主要的执行任务的接口。<strong>RecurisiveAction</strong>与<strong>RecurisiveTask</strong>。其中<strong>RecurisiveTask</strong>代表有返回值的任务，而<strong>RecurisiveAction</strong>代表没有返回值的任务。 它们的父类都是<strong>ForkJoinTask</strong>，<strong>fork</strong>和<strong>join</strong>的实现在ForkJoinTask类中。fork方法用以一部方式启动任务的执行，join方法则等待任务完成并返回指向结果。</p>
<p><strong>ForkJoinPool</strong>是ExecutorService的实现类。它使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public ForkJoinPool(int parallelism,&#x2F;&#x2F;线程数，默认为可用的CPU数量</span><br><span class="line">                        ForkJoinWorkerThreadFactory factory,&#x2F;&#x2F;默认为defaultForkJoinWorkerThreadFactory</span><br><span class="line">                        UncaughtExceptionHandler handler,&#x2F;&#x2F;异常处理，默认null</span><br><span class="line">                        boolean asyncMode);&#x2F;&#x2F;是否同步，默认false</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;几个重要方法</span><br><span class="line">public &lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task);&#x2F;&#x2F;等待获取结果，内部调用ForkJoinTask.invoke</span><br><span class="line">public void execute(ForkJoinTask&lt;?&gt; task);&#x2F;&#x2F;异步执行任务，内部调用ForkJoinTask.fork</span><br><span class="line">public void execute(Runnable task);&#x2F;&#x2F;异步执行任务将Runnable封装为ForkJoinTask再调用</span><br><span class="line">public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(ForkJoinTask&lt;T&gt; task);&#x2F;&#x2F;提交ForkJoinTask执行并返回结果</span><br><span class="line">public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">public &lt;T&gt; ForkJoinTask&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">public ForkJoinTask&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p><strong>ForkJoinPool</strong>特别之处在于实现了工作窃取，即当前线程的Task已经全被执行完毕，则自动取到其他线程的Task池中取出Task继续执行。</p>
<p><img src="/images/ForkJoinPool.png" alt="ForkJoinPool" title="ForkJoinPool"></p>
<p>考虑对1000万个数据进行排序，使用归并将其划分为两个500万的排序任务和一个针对这两组500万数据的合并任务；以此思想不断递归划分，当子任务规模足够小的时候（低于某个阈值，比如10），停止继续划分，直接使用其他排序方式(如插入排序)进行排序。</p>
<p>此时它的树形任务图有21层，任务数约有10w个。问题的关键在于，对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。</p>
<p>这里不能使用ThreadPoolExecutor，因为ThreadPoolExecutor中的线程无法像任务队列中再添加一个任务并且在等待该任务完成之后再继续执行。而使用ForkJoinPool时，就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。</p>
<ul>
<li><strong>Executors</strong></li>
</ul>
<p><strong>Executors</strong>提供了一些常用的线程池，开箱即用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>FixedThreadPool</strong>核心线程等于最大线程数，线程不会因闲置而销毁。因使用队列为默认LinkedBlockingQueue，其最大数量为Integer.MAX_VALUE，当有大量请求任务时可能会在队列里堆积导致OOM。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newWorkStealingPool(int parallelism) &#123;</span><br><span class="line">        return new ForkJoinPool</span><br><span class="line">            (parallelism,</span><br><span class="line">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">             null, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>WorkStealingPool</strong>提供了同步的<strong>ForkJoinPool</strong>线程池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SingleThreadExecutor</strong>同<strong>FixedThreadPool</strong>，只是核心线程数为1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                      60L, TimeUnit.SECONDS,</span><br><span class="line">                                      new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>CachedThreadPool</strong>没有核心线程，最大线程数量无限制，创建任务如有空闲线程则提交空闲线程执行，没有则立即新建线程，当有大量请求任务时会创建大量的线程，导致OOM。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">        return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>ScheduledThreadPool</strong>提供了指定核心数量的计划任务线程池<strong>ScheduledThreadPoolExecutor</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">        return new DelegatedScheduledExecutorService</span><br><span class="line">            (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>SingleThreadScheduledExecutor</strong>单线程的<strong>ScheduledThreadPool</strong>。</p>
<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><p><img src="/images/JUC_Collections_UML.png" alt="JUC_Collections_UML" title="JUC_Collections_UML"></p>
<ul>
<li><strong>ConcurrentHashMap</strong></li>
</ul>
<p><strong>ConcurrentHashMap</strong>是<strong>HashMap</strong>的并发实现，初见JDK1.7，彼时底层使用分段的方式来降低高并发导致的热点争用问题；在1.8时，弃用了分段锁，采用CAS来优化并发。详细讲解见<a href="https://javadoop.com/post/hashmap" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a>。<br><img src="/images/ConcurrentHashMap_17.png" alt="ConcurrentHashMap_17.png" title="ConcurrentHashMap_17.png"><br><img src="/images/ConcurrentHashMap_18.png" alt="ConcurrentHashMap_18.png" title="ConcurrentHashMap_18.png"></p>
<ul>
<li><strong>ConcurrentLinkedQueue</strong></li>
</ul>
<p><strong>ConcurrentLinkedQueue</strong>是一个基于链接节点的无界线程安全FIFO队列。在入队时，首先定位尾节点，然后使用CAS将入队节点设置为尾节点的后继。出队时首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<ul>
<li><strong>ConcurrentLinkedDeque</strong></li>
</ul>
<p><strong>ConcurrentLinkedDeque</strong>是<strong>ConcurrentLinkedQueue</strong>双向链表版本，同时支持FIFO和FILO两种操作方式。头插入时首先寻找合法(存活)头节点，然后将新节点尾指针指向原头节点，并通过CAS设置原头节点前指针。取节点也类似，找到合法(存活)节点后unlink。</p>
<ul>
<li><strong>ConcurrentSkipListMap</strong></li>
</ul>
<p>跳跃表是一种通过“空间来换取时间”的一个算法，通过在每个节点中增加了向前的指针，从而提升查找的效率。<strong>ConcurrentSkipListMap</strong>提供了一种线程安全的并发访问的排序映射表。内部是SkipList（跳表）结构实现，在理论上能够O(log(n))时间内完成查找、插入、删除操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static class Index&lt;K,V&gt; &#123;</span><br><span class="line">        final Node&lt;K,V&gt; node;</span><br><span class="line">        final Index&lt;K,V&gt; down;</span><br><span class="line">        volatile Index&lt;K,V&gt; right;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在其中，Node是传统的链表节点，跳跃表中在之上建立索引，Index则是跳跃表的基本组成单元。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* Head nodes          Index nodes       </span><br><span class="line">* +-+   right    +-+       +-+              </span><br><span class="line">* |1|-----------&gt;| |------&gt;| |----------------&gt;| |-&gt;null</span><br><span class="line">* +-+            +-+       +-+                 +-+</span><br><span class="line">*  v  down        |         |                   |</span><br><span class="line">* Nodes  next     v         v                   v</span><br><span class="line">* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  </span><br><span class="line">* | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|J|-&gt;|K|-&gt;null</span><br><span class="line">* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br></pre></td></tr></table></figure>
<p>一个带一级索引的跳跃表如上。<br>在添加元素时，首先新增一个结点到最底层的链表上；然后生成一个随机数，并根据该随机数得到一个<em>level</em>，如果概率算得的<em>level</em>在当前跳表<em>level</em>范围内，则构建一个从<em>1</em>到<em>level</em>的纵列<em>index</em>结点引用；否则新增添加一层，完成<em>head</em>结点的指针转移，并构建好纵向的<em>index</em>结点引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* Head nodes          Index nodes</span><br><span class="line">* +-+    right        +-+                      +-+</span><br><span class="line">* |2|----------------&gt;| |---------------------&gt;| |-&gt;null</span><br><span class="line">* +-+                 +-+                      +-+</span><br><span class="line">*  | down              |                        |</span><br><span class="line">*  v                   v                        v</span><br><span class="line">* +-+            +-+  +-+       +-+            +-+       +-+</span><br><span class="line">* |1|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;null</span><br><span class="line">* +-+            +-+  +-+       +-+            +-+       +-+</span><br><span class="line">*  v              |    |         |              |         |</span><br><span class="line">* Nodes  next     v    v         v              v         v</span><br><span class="line">* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br><span class="line">* | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;null</span><br><span class="line">* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span><br></pre></td></tr></table></figure>
<p>上图中，插入元素<em>D</em>时，得到一个大于当前跳跃表的<em>level</em>，于是便新增一层，并建立纵向的<em>index</em>结点引用。然后新增元素<em>I</em>，此时得到等于当前跳表的<em>level</em>，于是直接添加并每层都添加好向下的<em>index</em>结点引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*        +------+       +------+      +------+</span><br><span class="line">*   ...  |   b  |------&gt;|   n  |-----&gt;|   f  | ...</span><br><span class="line">*        +------+       +------+      +------+</span><br></pre></td></tr></table></figure>
<p>删除节点时，如上图的n节点，首先使用CAS将n的value换成null；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*        +------+       +------+      +------+       +------+</span><br><span class="line">*   ...  |   b  |------&gt;|   n  |-----&gt;|marker|------&gt;|   f  | ...</span><br><span class="line">*        +------+       +------+      +------+       +------+</span><br></pre></td></tr></table></figure>
<p>然后在n的后面增加一个空的结点（marker）以避免一些在基于CAS链表的删除错误；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*        +------+                                    +------+</span><br><span class="line">*   ...  |   b  |-----------------------------------&gt;|   f  | ...</span><br><span class="line">*        +------+                                    +------+</span><br></pre></td></tr></table></figure>
<p>最后将b指向f，断开n，让n被GC回收掉。</p>
<ul>
<li><strong>ConcurrentSkipListSet</strong></li>
</ul>
<p><strong>ConcurrentSkipListSet</strong>本质是<strong>ConcurrentSkipListMap&lt;E,Object&gt;</strong>。</p>
<ul>
<li><strong>CopyOnWriteArrayList</strong></li>
</ul>
<p><strong>CopyOnWriteArrayList</strong>使用了写时复制，当有新元素添加到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。因此做到了线程安全。</p>
<ul>
<li><strong>CopyOnWriteArraySet</strong></li>
</ul>
<p><strong>CopyOnWriteArraySet</strong>本质是<strong>CopyOnWriteArrayList<E></strong>,在添加元素时调用了<strong>CopyOnWriteArrayList</strong>的<strong>addIfAbsent(e)</strong>方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/02/19/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" data-id="ckaqo6uyk000j28o6eo1zaw32" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java执行顺序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/19/Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="article-date">
  <time datetime="2019-02-19T13:43:00.000Z" itemprop="datePublished">2019-02-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/19/Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">Java执行顺序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>众所周知，java程序入口为main方法，但java程序首先执行的并不一定是main程序的第一句话。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">	static&#123;</span><br><span class="line">		System.out.println(&quot;构造块&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;main start&quot;);</span><br><span class="line">        Test t &#x3D; new Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">构造块</span><br><span class="line">main start</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，可以看到构造块先于main start输出。这是因为静态部分是属于类，而不是属于对象的，jvm首先加载类，而后在运行过程中有需要再进行类的实例化。</p>
<p>在一般情况下，代码执行顺序如下:</p>
<ol>
<li>父类的静态属性 静态方法声明 静态块</li>
<li>静态属性 静态方法声明 静态块</li>
<li>父类的动态属性 普通方法声明 构造块</li>
<li>父类构造方法</li>
<li>动态属性 普通方法声明 构造块</li>
<li>构造方法</li>
</ol>
<p>当加载一个类时，jvm首先为静态属性一并赋予默认值，按静态相关代码出现顺序执行(静态属性初始化,静态方法的声明,静态块的加载)，且静态代码仅执行一次(仅加载一次，双亲委托避免重复加载类)。</p>
<p>当新建一个对象时，会调用该对象的构造方法。但在这之前，会先为动态属性一并赋予默认值(此时类加载已完成，除非因静态代码中实例化被打断而暂停)，然后按代码出现顺序执行(动态属性初始化,构造块，方法声明)。最后执行构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;<span class="comment">//父类</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = print();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"print i:"</span> + i);</span><br><span class="line">		<span class="keyword">return</span> ++i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Test的构造块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Test的构造方法 i:"</span> + print());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestParent</span> <span class="keyword">extends</span> <span class="title">Test</span></span>&#123;<span class="comment">//子类</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> p = print();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"print j:"</span> + j);</span><br><span class="line">		<span class="keyword">return</span> ++j;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"TestParent的构造块"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TestParent</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"TestParent的构造方法 j:"</span> + print());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//执行入口</span></span><br><span class="line">        System.out.println(<span class="string">"main start"</span>);</span><br><span class="line">        TestParent t = <span class="keyword">new</span> TestParent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print i:0</span><br><span class="line">Test的构造块</span><br><span class="line">print j:0</span><br><span class="line">TestParent的构造块</span><br><span class="line">main start</span><br><span class="line">print i:1</span><br><span class="line">Test的构造方法 i:2</span><br><span class="line">print j:10</span><br><span class="line">TestParent的构造方法 j:11</span><br></pre></td></tr></table></figure>

<p>在类加载过程中，如果静态部分有实例对象操作，则会暂停类加载而进行类实例化，来看下面这一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Text t1 = <span class="keyword">new</span> Text(<span class="string">"t1"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Text t2 = <span class="keyword">new</span> Text(<span class="string">"t2"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = print(<span class="string">"i"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = print(<span class="string">"j"</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="string">"构造块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        print(<span class="string">"静态块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Text</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println((++k) + <span class="string">":"</span> + str + <span class="string">"   i="</span> + i + <span class="string">"    n="</span> + n);</span><br><span class="line">        ++i;</span><br><span class="line">        ++n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">print</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println((++k) + <span class="string">":"</span> + str + <span class="string">"   i="</span> + i + <span class="string">"    n="</span> + n);</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="keyword">return</span> ++i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    	Text t = <span class="keyword">new</span> Text(<span class="string">"init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1:j   i&#x3D;0    n&#x3D;0</span><br><span class="line">2:构造块   i&#x3D;1    n&#x3D;1</span><br><span class="line">3:t1   i&#x3D;2    n&#x3D;2</span><br><span class="line">4:j   i&#x3D;3    n&#x3D;3</span><br><span class="line">5:构造块   i&#x3D;4    n&#x3D;4</span><br><span class="line">6:t2   i&#x3D;5    n&#x3D;5</span><br><span class="line">7:i   i&#x3D;6    n&#x3D;6</span><br><span class="line">8:静态块   i&#x3D;7    n&#x3D;99</span><br><span class="line">9:j   i&#x3D;8    n&#x3D;100</span><br><span class="line">10:构造块   i&#x3D;9    n&#x3D;101</span><br><span class="line">11:init   i&#x3D;10    n&#x3D;102</span><br></pre></td></tr></table></figure>

<p>在这里先进行了<strong>public int j = print(“j”);</strong>的执行，是因为在类加载时遇到了<strong>public static Text t1 = new Text(“t1”);</strong>实例化操作，所以就出现了以上执行结果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/02/19/Java%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" data-id="ckaqo6uy4000828o67erobu8m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字符活跃排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/09/%E5%AD%97%E7%AC%A6%E6%B4%BB%E8%B7%83%E6%8E%92%E5%BA%8F/" class="article-date">
  <time datetime="2018-04-09T16:55:00.000Z" itemprop="datePublished">2018-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/09/%E5%AD%97%E7%AC%A6%E6%B4%BB%E8%B7%83%E6%8E%92%E5%BA%8F/">字符活跃排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给定一个字符串，统计每个Alpha字符（统一作为小写）出现的频率，并排序。</p>
<p>示例输入：I have A Dream…</p>
<p>示例输出：aedhimrv</p>
<p>其中a出现了3次，e出现了2次，其余字符出现一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">sortMostActiveString</span><span class="params">(String in)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> in.toLowerCase().chars()</span><br><span class="line">		.filter(t -&gt; t&gt;=<span class="string">'a'</span> &amp;&amp; t &lt;=<span class="string">'z'</span>)</span><br><span class="line">		.mapToObj(t -&gt; &#123;<span class="keyword">char</span>[] cs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];cs[<span class="number">0</span>] = (<span class="keyword">char</span>) t;<span class="keyword">return</span> <span class="keyword">new</span> String(cs);&#125;)</span><br><span class="line">		.collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))</span><br><span class="line">		.entrySet().stream().sorted(</span><br><span class="line">				<span class="keyword">new</span> Comparator&lt;Entry&lt;String, Long&gt;&gt;()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String, Long&gt; o1, Entry&lt;String, Long&gt; o2)</span> </span>&#123;</span><br><span class="line">						<span class="keyword">if</span> (o1.getValue() &gt; o2.getValue()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">						<span class="keyword">if</span> (o1.getValue() &lt; o2.getValue()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">return</span> o1.getKey().compareTo(o2.getKey());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				)</span><br><span class="line">		.map(Entry::getKey)</span><br><span class="line">		.collect(Collectors.joining());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2018/04/09/%E5%AD%97%E7%AC%A6%E6%B4%BB%E8%B7%83%E6%8E%92%E5%BA%8F/" data-id="ckaqo6uzp002128o692iu5u60" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jmap命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/26/jmap%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2018-03-26T11:28:00.000Z" itemprop="datePublished">2018-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/26/jmap%E5%91%BD%E4%BB%A4/">jmap命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&nbsp;&nbsp;&nbsp;&nbsp;打印可共享内存map或堆内存细节信息。使用时可能需要root权限。</p>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p><strong>jmap</strong> [options] <em>pid</em></p>
<p><strong>jmap</strong> [options] <em>executable</em> <em>core</em></p>
<p><strong>jmap</strong> [options] [pid] [server-id@] remote-hostname-or-IP</p>
<p><strong>options</strong> 命令行选项。</p>
<p><strong>pid</strong> Java进程号。</p>
<p><strong>executable</strong> 可执行命令。</p>
<p><strong>core</strong> 需要打印内存信息的core文件。</p>
<p><strong>remote-hostname-or-IP</strong> 多个调试服务器在同一个远程主机上运行时使用的可选唯一标识。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<em>jmap</em>主要用于打印指定Java进程(或核心文件、远程调试服务器)的共享对象内存映射或堆内存细节。如果进程运行在64位虚拟机上，则可能需要使用-J-d64选项。</p>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p><strong>&lt; no option &gt;</strong> 如果使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % sudo jmap 3431</span><br><span class="line">Attaching to process ID 3431, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.66-b17</span><br><span class="line">0x0000000000400000	7K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;bin&#x2F;java</span><br><span class="line">0x00007f95eee86000	48K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;libmanagement.so</span><br><span class="line">0x00007f95ef592000	86K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libgcc_s.so.1</span><br><span class="line">0x00007f95ef7a8000	250K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;libsunec.so</span><br><span class="line">0x00007f95efbef000	90K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;libnio.so</span><br><span class="line">0x00007f9611931000	113K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;libnet.so</span><br><span class="line">0x00007f96279cc000	121K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;libzip.so</span><br><span class="line">0x00007f9627be7000	50K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libnss_files-2.15.so</span><br><span class="line">0x00007f9627df4000	46K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libnss_nis-2.15.so</span><br><span class="line">0x00007f962c0ce000	94K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libnsl-2.15.so</span><br><span class="line">0x00007f962c2e8000	34K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libnss_compat-2.15.so</span><br><span class="line">0x00007f962c4f1000	220K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;libjava.so</span><br><span class="line">0x00007f962c71d000	64K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;libverify.so</span><br><span class="line">0x00007f962c92c000	31K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;librt-2.15.so</span><br><span class="line">0x00007f962cb34000	1006K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libm-2.15.so</span><br><span class="line">0x00007f962ce30000	16516K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;jre&#x2F;lib&#x2F;amd64&#x2F;server&#x2F;libjvm.so</span><br><span class="line">0x00007f962de0a000	1772K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.15.so</span><br><span class="line">0x00007f962e1ca000	14K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libdl-2.15.so</span><br><span class="line">0x00007f962e3ce000	100K	&#x2F;home&#x2F;lyyljs&#x2F;lan&#x2F;jdk8&#x2F;lib&#x2F;amd64&#x2F;jli&#x2F;libjli.so</span><br><span class="line">0x00007f962e5e4000	132K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libpthread-2.15.so</span><br><span class="line">0x00007f962e801000	145K	&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;ld-2.15.so</span><br></pre></td></tr></table></figure>

<p><strong>-dump:[live,] format=b, file=<em>filename</em></strong> 以hprof二进制格式转储Java堆到指定<em>filename<em>的文件中。live子选项是可选的。如果指定了live子选项，堆中只有活动的对象会被转储。可使用</em>jhat</em>,<em>Visual GC</em>,<em>eclipse Memory Analyzer</em>等工具进行分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jmap -dump:format&#x3D;b,file&#x3D;test.bin 3431</span><br><span class="line">Dumping heap to&#x2F;home&#x2F;lyyljs&#x2F;test.bin ...</span><br><span class="line">Heap dump file created</span><br><span class="line">-&gt; % jhat test.bin </span><br><span class="line">Reading from test.bin...</span><br><span class="line">Dump file created Mon Mar 26 14:09:49 CST 2018</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 1250155 objects...</span><br><span class="line">Chasing references, expect 250 dots..........................................................................................................................................................................................................................................................</span><br><span class="line">Eliminating duplicate references..........................................................................................................................................................................................................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.#可以通过ip:7000访问查看分析。</span><br></pre></td></tr></table></figure>

<p><strong>-finalizerinfo</strong> 打印等待终结（finalization）的对象信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % sudo jmap -finalizerinfo 3431</span><br><span class="line">Attaching to process ID 3431, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.66-b17</span><br><span class="line">Number of objects pending for finalization: 0</span><br></pre></td></tr></table></figure>

<p><strong>-heap</strong> 打印一个堆的摘要信息,，包括使用的GC算法、堆配置信息和分代堆使用信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % sudo jmap -heap 3431 </span><br><span class="line">Attaching to process ID 3431, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.66-b17</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 2 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         &#x3D; 0</span><br><span class="line">   MaxHeapFreeRatio         &#x3D; 100</span><br><span class="line">   MaxHeapSize              &#x3D; 268435456 (256.0MB)</span><br><span class="line">   NewSize                  &#x3D; 134217728 (128.0MB)</span><br><span class="line">   MaxNewSize               &#x3D; 134217728 (128.0MB)</span><br><span class="line">   OldSize                  &#x3D; 134217728 (128.0MB)</span><br><span class="line">   NewRatio                 &#x3D; 2</span><br><span class="line">   SurvivorRatio            &#x3D; 10</span><br><span class="line">   MetaspaceSize            &#x3D; 62914560 (60.0MB)</span><br><span class="line">   CompressedClassSpaceSize &#x3D; 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         &#x3D; 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         &#x3D; 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity &#x3D; 131072000 (125.0MB)</span><br><span class="line">   used     &#x3D; 73502080 (70.0970458984375MB)</span><br><span class="line">   free     &#x3D; 57569920 (54.9029541015625MB)</span><br><span class="line">   56.07763671875% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity &#x3D; 1572864 (1.5MB)</span><br><span class="line">   used     &#x3D; 987520 (0.9417724609375MB)</span><br><span class="line">   free     &#x3D; 585344 (0.5582275390625MB)</span><br><span class="line">   62.784830729166664% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity &#x3D; 1572864 (1.5MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 1572864 (1.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity &#x3D; 134217728 (128.0MB)</span><br><span class="line">   used     &#x3D; 30292192 (28.888885498046875MB)</span><br><span class="line">   free     &#x3D; 103925536 (99.11111450195312MB)</span><br><span class="line">   22.56944179534912% used</span><br><span class="line"></span><br><span class="line">19790 interned Strings occupying 1802464 bytes.</span><br></pre></td></tr></table></figure>


<p><strong>-histo[:live]</strong> 打印堆的柱状图。其中包括每个Java类,对象数量,内存大小,完全限定的类名。打印的JVM内部类名称将会带有一个****<em>前缀。如果指定了</em>live*子选项，则只计算活动的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jmap -histo 3431 &gt; test.histo</span><br><span class="line">-&gt; % less test.histo </span><br><span class="line"> num     #instances         #bytes  class name</span><br><span class="line"> 序号	实例数量			字节数		类名</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:        289741       37478104  [C</span><br><span class="line">   2:         97559       31077664  [B</span><br><span class="line">   3:        192282        4614768  java.lang.String</span><br><span class="line">   4:         21694        3215944  [I</span><br><span class="line">   5:         76700        2454400  java.util.HashMap$Node</span><br><span class="line">   6:         31789        1531960  [Ljava.lang.Object;</span><br><span class="line">   7:         20941        1507752  java.lang.reflect.Field</span><br><span class="line">   8:         15375        1353000  java.lang.reflect.Method</span><br><span class="line">   9:         11452        1214248  [Ljava.util.HashMap$Node;</span><br><span class="line">  10:          7957         888752  java.lang.Class</span><br><span class="line">  11:         27131         868192  java.util.concurrent.ConcurrentHashMap$Node</span><br><span class="line">  ...</span><br><span class="line">  3299:             1             16  sun.util.locale.provider.TimeZoneNameUtility$TimeZoneNameGetter</span><br><span class="line">3300:             1             16  sun.util.resources.LocaleData</span><br><span class="line">3301:             1             16  sun.util.resources.LocaleData$LocaleDataResourceBundleControl</span><br><span class="line">Total       1213485      100989464</span><br></pre></td></tr></table></figure>

<p><strong>-clstats</strong> 打印Java堆的类加载统计信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % sudo jmap -clstats 3431</span><br><span class="line">Attaching to process ID 3431, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.66-b17</span><br><span class="line">finding class loader instances ..</span><br><span class="line">done.</span><br><span class="line">computing per loader stat ..done.</span><br><span class="line">please wait.. computing liveness.........liveness analysis may be inaccurate ...</span><br><span class="line">class_loader	classes	bytes	parent_loader	alive?	type</span><br><span class="line">类加载器地址	加载类数量	加载类大小	父加载器	是否存活	类加载器类型</span><br><span class="line"></span><br><span class="line">&lt;bootstrap&gt;	2778	4860705	  null  	live	&lt;internal&gt;</span><br><span class="line">0x00000000f02caf28	1	1473	0x00000000f056f510	dead	sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000100009df8</span><br><span class="line">0x00000000f02cbd38	1	1471	  null  	dead	sun&#x2F;reflect&#x2F;DelegatingClassLoader@0x0000000100009df8</span><br><span class="line">0x00000000f0174730	0	0	0x00000000f056f510	live	java&#x2F;util&#x2F;ResourceBundle$RBClassLoader@0x00000001000c72f8</span><br><span class="line">0x00000000f05410b8	138	282890	  null  	live	sun&#x2F;misc&#x2F;Launcher$ExtClassLoader@0x000000010000fa30</span><br><span class="line">0x00000000f056f510	4783	7865232	0x00000000f05410b8	live	sun&#x2F;misc&#x2F;Launcher$AppClassLoader@0x000000010000f688</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">total &#x3D; 167	8001	13646309	    N&#x2F;A    	alive&#x3D;8, dead&#x3D;159	    N&#x2F;A</span><br></pre></td></tr></table></figure>

<p><strong>-F</strong> 强制模式。如果指定的pid没有响应使用该选项，<em>live</em>子选项不支持该模式。</p>
<p><strong>-h|-help</strong> 打印帮助信息。</p>
<p><strong>-J<em>flag</em></strong> 指定传递给运行jmap的JVM的参数。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html#CEGCECJB" target="_blank" rel="noopener">Oracle jmap官方文档</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2018/03/26/jmap%E5%91%BD%E4%BB%A4/" data-id="ckaqo6uyp000p28o6gnvr92r7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%91%BD%E4%BB%A4/" rel="tag">java命令</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jstack命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/26/jstack%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2018-03-26T10:17:00.000Z" itemprop="datePublished">2018-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/26/jstack%E5%91%BD%E4%BB%A4/">jstack命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&nbsp;&nbsp;&nbsp;&nbsp;打印Java线程栈信息。</p>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p><strong>jstack</strong> [options] <em>pid</em></p>
<p><strong>jstack</strong> [options] executable core</p>
<p><strong>jstack</strong> [options] [server-id@] <em>remote-hostname-or-IP</em></p>
<p><strong>options</strong> 命令行选项。</p>
<p><strong>pid</strong> Java进程Id。</p>
<p><strong>executable</strong> 产生core dump的java可执行指令</p>
<p><strong>core</strong> 栈信息打印核心文件</p>
<p><strong>remote-hostname-or-IP</strong> 远程服务器主机名或IP地址。</p>
<p><strong>server-id</strong>  多个调试服务器在同一个远程主机上运行时使用的可选唯一标识。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>jstack</strong>用于生成java虚拟机当前时刻的线程快照。只要可达，就会打印Java frame，类全名，方法名，字节码索引(BCI)以及行号。使用<em>-m*选项，jstack命令用程序计数器打印所有线程的Java和本机帧。对于本地帧会打印可达的最靠近PC的native symbol。c++打乱的名称不会被恢复。为了恢复C++名称，可以通过改命令输出到管道c++filt。在64位JVM上，可能需要使用</em>-J-d64*选项。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面描述可以看出，jstack命令主要用来查看Java线程的调用栈，以分析线程问题（如死锁，高cpu等）。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p><strong>-F</strong> 当jstack [-l]<em>pid</em>无响应时使用。强制dump。一般情况不需要使用。</p>
<p><strong>-l</strong> 长列表。打印关于锁的列表信息。会使得JVM STW时间变长，一般不使用。</p>
<p><strong>-m</strong> 打印Java和本地C/C++栈帧。一般不使用。已知bug: -m选项不能在远程模式下生效。</p>
<p><strong>-h|-help</strong> 打印帮助信息。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html#BABGJDIF" target="_blank" rel="noopener">Oracle jstack官方文档</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2018/03/26/jstack%E5%91%BD%E4%BB%A4/" data-id="ckaqo6uyr000r28o6ag4zbra7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%91%BD%E4%BB%A4/" rel="tag">java命令</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jstat命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/25/jstat%E5%91%BD%E4%BB%A4/" class="article-date">
  <time datetime="2018-03-25T15:51:00.000Z" itemprop="datePublished">2018-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/25/jstat%E5%91%BD%E4%BB%A4/">jstat命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>&nbsp;&nbsp;&nbsp;&nbsp;监控JVM状态。</p>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p><strong>jstat</strong> [ <em>generalOption</em> | <em>outputOptions</em> <em>vmid</em> [ <em>interval</em>[s|ms] [ <em>count</em> ] ]</p>
<p><strong>generalOption</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在使用通用选项后，不能跟其他参数。</p>
<ul>
<li><em>-help</em>显示帮助信息。</li>
<li><em>-options</em>显示统计选项。</li>
</ul>
<p><strong>outputOptions</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;一个统计选项加一些额外选项如<em>-t*，</em>-h<em>，</em>-J*。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;输出为一个表格，以空格隔开。<em>-h*为头部信息显示频率。</em>-t<em>显示从JVM启动开始经过的时间,单位秒。<em>interval</em>制定显示频率，<em>count</em>指定次数。-J*javaOption</em>:传递java参数到java应用启动器;如<em>-J-Xms48m</em>设定启动内存为48MB。</p>
<p>统计选项如下：</p>
<ul>
<li><p><em>class</em> 显示统计类加载器信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -class 3431</span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time   </span><br><span class="line">  7474 13825.1       48    64.0       7.10</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Loaded</td>
<td align="center">装载的类的数量</td>
</tr>
<tr>
<td align="center">Bytes</td>
<td align="center">装载类所占用的字节数</td>
</tr>
<tr>
<td align="center">Unloaded</td>
<td align="center">卸载类的数量</td>
</tr>
<tr>
<td align="center">Bytes</td>
<td align="center">卸载类的字节数</td>
</tr>
<tr>
<td align="center">Time</td>
<td align="center">装载和卸载类所花费的时间</td>
</tr>
</tbody></table>
</li>
<li><p><em>compiler</em> 显示JVM 即时编译器统计信息。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -compiler 3431</span><br><span class="line">Compiled Failed Invalid   Time   FailedType FailedMethod</span><br><span class="line">   12443      1       0    85.52          1 com&#x2F;mysql&#x2F;jdbc&#x2F;AbandonedConnectionCleanupThread run</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Compiled</td>
<td align="center">编译任务执行数量</td>
</tr>
<tr>
<td align="center">Failed</td>
<td align="center">编译任务执行失败数量</td>
</tr>
<tr>
<td align="center">Invalid</td>
<td align="center">编译任务执行失效数量</td>
</tr>
<tr>
<td align="center">Time</td>
<td align="center">编译任务消耗时间</td>
</tr>
<tr>
<td align="center">FailedType</td>
<td align="center">最后一个编译失败任务的类型</td>
</tr>
<tr>
<td align="center">FailedMethod</td>
<td align="center">最后一个编译失败任务所在的类及方法</td>
</tr>
<tr>
<td align="center">* <em>gc</em> 显示垃圾回收堆信息。</td>
<td align="center"></td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gc 3431      </span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">1536.0 1536.0 967.7   0.0   128000.0 79183.5   131072.0   125499.8  46720.0 45479.5 5248.0 4909.1  11563   54.785  66      9.381   64.166</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;后缀C为容量,U为已使用空间,T为时间；首字符S为survivor区域，E为eden区，O为老年区,M为MetaSpace;CCS为压缩类空间,YGC为年轻代垃圾回收，FGC为FullGC;GCT为垃圾回收总时间。这里空间大小单位为KB，时间单位为秒，YGC和FGC单位为次。</p>
<ul>
<li><em>gccapacity</em> 显示各代容量统计信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gccapacity 3431</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC </span><br><span class="line">131072.0 131072.0 131072.0 1536.0 1536.0 128000.0   131072.0   131072.0   131072.0   131072.0      0.0 1091584.0  46720.0      0.0 1048576.0   5248.0  11600    67</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;NGC:新生代大小,OGC:老年代大小,MCM:meta space大小;MN:最小值,MX:最大值；其他参考<em>gc</em>选项。</p>
<ul>
<li><em>gccause</em> 汇总垃圾统计信息(同-gcutil)和原因。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gccause 3431   </span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                 </span><br><span class="line">  0.00  57.54  50.05  69.07  97.34  93.54  11624   55.100    67    9.567   64.667 Allocation Failure   No GC</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;这里的空间为已使用的百分比表示，如S1为57.54表示survivor 1已使用了57.54%。LGCC为最近一次造成垃圾回收的原因，GCC为当前垃圾回收的原因。</p>
<ul>
<li><em>gcnew</em> 年轻代对象的信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gcnew 3431 </span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  </span><br><span class="line">1536.0 1536.0 1014.0    0.0  1  15 1536.0 128000.0  23834.4  11673   55.350</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;TT：晋升阈值；MIT：最大晋升阈值；DSS:期望幸存区大小。</p>
<ul>
<li><em>gcnewcapacity</em> 年轻代对象的信息及其占用量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gcnewcapacity 3431</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC </span><br><span class="line">  131072.0   131072.0   131072.0  10752.0   1536.0  10752.0   1536.0   130048.0   128000.0 11696    67</span><br></pre></td></tr></table></figure>

<p>&nbsp;&nbsp;&nbsp;&nbsp;CMX:容量最大值。</p>
<ul>
<li><em>gcold</em> 老年区以及元区域的对象统计信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gcold 3431        </span><br><span class="line">   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT   </span><br><span class="line"> 46720.0  45479.5   5248.0   4909.1    131072.0    117544.4  11705    67    9.567   65.092</span><br></pre></td></tr></table></figure>

<ul>
<li><em>gcoldcapacity</em> 老年区以及元区域的对象以及容量信息统计信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gcoldcapacity 3431</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT   </span><br><span class="line">   131072.0    131072.0    131072.0    131072.0 11709    67    9.567   65.126</span><br></pre></td></tr></table></figure>

<ul>
<li><em>gcmetacapacity</em> metaspace区域大小信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gcmetacapacity 3431</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT   </span><br><span class="line">       0.0  1091584.0    46720.0        0.0  1048576.0     5248.0 11714    67    9.567   65.152</span><br></pre></td></tr></table></figure>

<ul>
<li><em>gcutil</em> 垃圾回收统计信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gcutil 3431        </span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">  0.00  65.01  30.50  92.93  97.34  93.54  11718   55.611    67    9.567   65.177</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里的空间描述为使用百分比。</p>
<ul>
<li><em>printcompilation</em> 当前VM执行的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -printcompilation 3431</span><br><span class="line">Compiled  Size  Type Method</span><br><span class="line">   12444   1734    1 org&#x2F;quartz&#x2F;core&#x2F;QuartzSchedulerThread run</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Compiled</td>
<td align="center">最近编译的方法执行的编译任务数</td>
</tr>
<tr>
<td align="center">Size</td>
<td align="center">最近方法生成的字节码的大小</td>
</tr>
<tr>
<td align="center">Type</td>
<td align="center">最近编译类型</td>
</tr>
<tr>
<td align="center">Method</td>
<td align="center">最近编译方法 类名 方法名</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;带时间戳，没3行显示一次头部，采样间隔为1秒，采样5次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-&gt; % jstat -gcutil -t -h3 3431 1s 5 </span><br><span class="line">Timestamp         S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">       195385.4   0.00  55.53  12.10  58.00  97.34  93.54  11756   55.817    68   10.046   65.864</span><br><span class="line">       195386.4   0.00  55.53  22.52  58.00  97.34  93.54  11756   55.817    68   10.046   65.864</span><br><span class="line">       195387.4   0.00  55.53  24.07  58.00  97.34  93.54  11756   55.817    68   10.046   65.864</span><br><span class="line">Timestamp         S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">       195388.4   0.00  55.53  34.22  58.00  97.34  93.54  11756   55.817    68   10.046   65.864</span><br><span class="line">       195389.4   0.00  55.53  35.81  58.00  97.34  93.54  11756   55.817    68   10.046   65.864</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHEIDCB" target="_blank" rel="noopener">Oracle jstat官方文档</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2018/03/25/jstat%E5%91%BD%E4%BB%A4/" data-id="ckaqo6uz1001428o64sa4hgrd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java%E5%91%BD%E4%BB%A4/" rel="tag">java命令</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elastic-search/" rel="tag">elastic search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elk/" rel="tag">elk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%91%BD%E4%BB%A4/" rel="tag">java命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stream/" rel="tag">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/elastic-search/" style="font-size: 10px;">elastic search</a> <a href="/tags/elk/" style="font-size: 10px;">elk</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/java%E5%91%BD%E4%BB%A4/" style="font-size: 17.5px;">java命令</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">java基础</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/spring-cloud/" style="font-size: 20px;">spring cloud</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/05/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E5%9F%9F%E5%90%8D%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/">反向代理解决微信小程序业务域名限制问题</a>
          </li>
        
          <li>
            <a href="/2019/05/13/Stream-%E7%BC%96%E7%A8%8B%E8%83%8C%E5%90%8E/">Stream实现原理</a>
          </li>
        
          <li>
            <a href="/2019/05/04/jdk8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">jdk8函数式编程</a>
          </li>
        
          <li>
            <a href="/2019/04/27/OWASP%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/">OWASP第三方依赖检查插件使用</a>
          </li>
        
          <li>
            <a href="/2019/04/11/docker%E6%90%AD%E5%BB%BAjenkins/">docker搭建jenkins</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 lyyljs<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>