<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>客户端负载均衡 | lyyljs`s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是负载均衡负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行">
<meta property="og:type" content="article">
<meta property="og:title" content="客户端负载均衡">
<meta property="og:url" content="http://lyyljs.site/2019/03/13/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/index.html">
<meta property="og:site_name" content="lyyljs&#96;s blog">
<meta property="og:description" content="什么是负载均衡负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lyyljs.site/images/cloud/AvailabilityFilteringRuleUML.png">
<meta property="article:published_time" content="2019-03-13T06:54:00.000Z">
<meta property="article:modified_time" content="2020-05-28T14:33:59.000Z">
<meta property="article:author" content="lyyljs">
<meta property="article:tag" content="开发者">
<meta property="article:tag" content="程序猿">
<meta property="article:tag" content="程序媛">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="代码">
<meta property="article:tag" content="Developer">
<meta property="article:tag" content="Programmer">
<meta property="article:tag" content="Coder">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lyyljs.site/images/cloud/AvailabilityFilteringRuleUML.png">
  
    <link rel="alternate" href="/atom.xml" title="lyyljs`s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lyyljs`s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lyyljs.site"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-客户端负载均衡" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" class="article-date">
  <time datetime="2019-03-13T06:54:00.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      客户端负载均衡
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="什么是负载均衡"><a href="#什么是负载均衡" class="headerlink" title="什么是负载均衡"></a>什么是负载均衡</h4><p>负载平衡（Load balancing）是一种计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到最优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 使用带有负载平衡的多个服务器组件，取代单一的组件，可以通过冗余提高可靠性。负载平衡服务通常是由专用软件和硬件来完成。 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。<a href="https://zh.wikipedia.org/wiki/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" target="_blank" rel="noopener">负载均衡</a></p>
<a id="more"></a>

<h4 id="常用负载均衡策略"><a href="#常用负载均衡策略" class="headerlink" title="常用负载均衡策略"></a>常用负载均衡策略</h4><ul>
<li>轮询/加权轮询</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;轮询是指将请求轮流分配给每台服务器，当服务器群中各服务器的处理能力相同时，且每笔业务处理量差异不大时，最适合使用这种算法。但现实中不能保证每台服务器性能均相近，此时出现的就是加权轮询，将请求按权重分配进行轮询以调控每台服务器的负载。</p>
<ul>
<li>随机(按权重)</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;按权重设置随机概率，调用量较少的时候在一个截面上碰撞的概率高(请求集中在一台服务器上)，但调用量越大分配越均匀(越接近设定的权重比)。</p>
<ul>
<li>最少活跃/加权最少活跃</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;最少活跃指服务提供者当前任务数(当前的活跃调用数)最少；加权则是在其过程中进行按权重分配，如活跃数相同的两个服务提供者，则按权(随机)分配。</p>
<ul>
<li>哈希/一致性哈希</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;将请求按一定规则哈希将请求分配到对应的服务器上；一致哈希是一种特殊的哈希算法。<br>在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中 K 是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p>
<ul>
<li>响应速度</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;根据服务提供者的响应速度来选择。</p>
<h4 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h4><h5 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h5><p>Dubbo的负载均衡代码在dubbo-cluster下com.alibaba.dubbo.rpc.cluster.loadbalance包中(Dubbo 2.6.6)。实现了四种负载均衡策略：一致性哈希，最少活跃，随机，加权轮询。</p>
<h6 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h6><p>dubbo服务在预热期间权重是计算出来的，这个值随着启动时间越长会越接近自定义的权重值，预热期过后才等于自定义权重值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int calculateWarmupWeight(int uptime, int warmup, int weight) &#123;</span><br><span class="line">    &#x2F;&#x2F; 计算权重，下面代码逻辑上形似于 (uptime &#x2F; warmup) * weight。</span><br><span class="line">    &#x2F;&#x2F; 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight</span><br><span class="line">    int ww &#x3D; (int) ((float) uptime &#x2F; ((float) warmup &#x2F; (float) weight));</span><br><span class="line">    return ww &lt; 1 ? 1 : (ww &gt; weight ? weight : ww);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> private static final class ConsistentHashSelector&lt;T&gt; &#123;</span><br><span class="line"> 	&#x2F;&#x2F; 虚拟节点</span><br><span class="line">     private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">     &#x2F;&#x2F; 虚拟节点数量</span><br><span class="line">     private final int replicaNumber;</span><br><span class="line">     &#x2F;&#x2F; 用于检查实际节点是否有变化(上下线等)</span><br><span class="line">     private final int identityHashCode;</span><br><span class="line">     &#x2F;&#x2F; 用于参数定位</span><br><span class="line">     private final int[] argumentIndex;</span><br><span class="line"></span><br><span class="line">     ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123;</span><br><span class="line">         this.virtualInvokers &#x3D; new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">         this.identityHashCode &#x3D; identityHashCode;</span><br><span class="line">         URL url &#x3D; invokers.get(0).getUrl();</span><br><span class="line">         &#x2F;&#x2F; 获取虚拟节点数，默认为160</span><br><span class="line">         this.replicaNumber &#x3D; url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);</span><br><span class="line">         &#x2F;&#x2F; 获取参与 hash 计算的参数下标值，默认对第一个参数进行 hash 运算</span><br><span class="line">         String[] index &#x3D; Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));</span><br><span class="line">         argumentIndex &#x3D; new int[index.length];</span><br><span class="line">         for (int i &#x3D; 0; i &lt; index.length; i++) &#123;</span><br><span class="line">             argumentIndex[i] &#x3D; Integer.parseInt(index[i]);</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 分散到环上</span><br><span class="line">         for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">             String address &#x3D; invoker.getUrl().getAddress();</span><br><span class="line">             for (int i &#x3D; 0; i &lt; replicaNumber &#x2F; 4; i++) &#123;</span><br><span class="line">             	&#x2F;&#x2F; 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span><br><span class="line">                 byte[] digest &#x3D; md5(address + i);</span><br><span class="line">                 &#x2F;&#x2F; 对 digest 每4字节进行hash</span><br><span class="line">                 for (int h &#x3D; 0; h &lt; 4; h++) &#123;</span><br><span class="line">                     long m &#x3D; hash(digest, h);</span><br><span class="line">                     virtualInvokers.put(m, invoker);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">     private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">     	&#x2F;&#x2F; long hash是传入参数md5的hash</span><br><span class="line">     	&#x2F;&#x2F; 查找第一个节点值大于或等于当前 hash 的 Invoker</span><br><span class="line">         Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry &#x3D; virtualInvokers.tailMap(hash, true).firstEntry();</span><br><span class="line">         &#x2F;&#x2F; null说明在末尾，则取首个节点</span><br><span class="line">         if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">             entry &#x3D; virtualInvokers.firstEntry();</span><br><span class="line">         &#125;</span><br><span class="line">         return entry.getValue();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h6 id="加权最少活跃"><a href="#加权最少活跃" class="headerlink" title="加权最少活跃"></a>加权最少活跃</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size();</span><br><span class="line">        &#x2F;&#x2F; 最小的活跃数值(最小的任务数量)</span><br><span class="line">        int leastActive &#x3D; -1;</span><br><span class="line">        &#x2F;&#x2F; 具有相同最小活跃数的服务者提供者数量</span><br><span class="line">        int leastCount &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;具有相同最小活跃数的提供者在列表中的下标</span><br><span class="line">        int[] leastIndexs &#x3D; new int[length]; </span><br><span class="line">        &#x2F;&#x2F; 所有最小活跃的提供者的权重和</span><br><span class="line">        int totalWeight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 第一个最小活跃数的提供者权重值</span><br><span class="line">        int firstWeight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 多个最小活跃时，每个权重是否相等</span><br><span class="line">        boolean sameWeight &#x3D; true;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; invokers.get(i);</span><br><span class="line">            int active &#x3D; RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            &#x2F;&#x2F; 获取权重，如果是预热期则是预热权重</span><br><span class="line">            int afterWarmup &#x3D; getWeight(invoker, invocation);</span><br><span class="line">            &#x2F;&#x2F; 发现比当前有更小活跃的提供者，重置记录值</span><br><span class="line">            if (leastActive &#x3D;&#x3D; -1 || active &lt; leastActive) &#123; </span><br><span class="line">                leastActive &#x3D; active;</span><br><span class="line">                leastCount &#x3D; 1;</span><br><span class="line">                leastIndexs[0] &#x3D; i;</span><br><span class="line">                totalWeight &#x3D; afterWarmup; </span><br><span class="line">                firstWeight &#x3D; afterWarmup;</span><br><span class="line">                sameWeight &#x3D; true;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F; 发现和当前最小活跃数相等的提供者，更新记录值</span><br><span class="line">            &#125; else if (active &#x3D;&#x3D; leastActive) &#123; </span><br><span class="line">                leastIndexs[leastCount++] &#x3D; i;</span><br><span class="line">                totalWeight +&#x3D; afterWarmup; </span><br><span class="line">                if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                        &amp;&amp; afterWarmup !&#x3D; firstWeight) &#123;</span><br><span class="line">                    sameWeight &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 刚好仅有一个最小活跃</span><br><span class="line">        if (leastCount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return invokers.get(leastIndexs[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果有多个最小活跃，且权重不相等，则按权分配</span><br><span class="line">        if (!sameWeight &amp;&amp; totalWeight &gt; 0) &#123;</span><br><span class="line">            int offsetWeight &#x3D; random.nextInt(totalWeight) + 1;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; leastCount; i++) &#123;</span><br><span class="line">                int leastIndex &#x3D; leastIndexs[i];</span><br><span class="line">                offsetWeight -&#x3D; getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">                if (offsetWeight &lt;&#x3D; 0)</span><br><span class="line">                    return invokers.get(leastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 多个最小活跃权重相等，随机返回一个</span><br><span class="line">        return invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size();</span><br><span class="line">        int totalWeight &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 所有服务提供者的权重是否相等</span><br><span class="line">        boolean sameWeight &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 计算总权重，并判断所有服务提供者的权重是否相等</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            totalWeight +&#x3D; weight;</span><br><span class="line">            if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                    &amp;&amp; weight !&#x3D; getWeight(invokers.get(i - 1), invocation)) &#123;</span><br><span class="line">                sameWeight &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 权重不均等按权随机</span><br><span class="line">        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            int offset &#x3D; random.nextInt(totalWeight);</span><br><span class="line">            for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">                offset -&#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">                if (offset &lt; 0) &#123;</span><br><span class="line">                    return invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 权重均等时随机返回一个</span><br><span class="line">        return invokers.get(random.nextInt(length));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h6><p>这里加权轮询算法实现类似nginx的加权轮询，对于每个节点有两个属性，我们配置的weight和用于轮询的current weight。current weight初始为0。对于每次请求：</p>
<ol>
<li>遍历集群中的所有可用提供者，使每个提供者的currentWeight += weight, 并统计出权重总和 totalWeight。</li>
<li>选取currentWeight最大的提供者处理本次请求。</li>
<li>对于本次选定的提供者进行currentWeight -= totalWeight。</li>
</ol>
<p>来看一个权重配置为[A: 3, B: 2, C: 1]的例子。初始currentWeight数组为[0, 0, 0]，totalWeight = 6</p>
<table>
<thead>
<tr>
<th align="center">请求编号</th>
<th align="center">currentWeight 数组</th>
<th align="center">选择结果</th>
<th align="center">选择结果后currentWeight 数组</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">[3, 2, 1]</td>
<td align="center">A</td>
<td align="center">[-3, 2, 1]</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">[0, 4, 2]</td>
<td align="center">B</td>
<td align="center">[0, -2, 2]</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">[3, 0, 3]</td>
<td align="center">A</td>
<td align="center">[-3, 0, 3]</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">[0, 2, 4]</td>
<td align="center">C</td>
<td align="center">[0, 2, -2]</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">[3, 4, -1]</td>
<td align="center">B</td>
<td align="center">[3, -2, -1]</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">[6, 0, 0]</td>
<td align="center">A</td>
<td align="center">[0, 0, 0]</td>
</tr>
</tbody></table>
<p>这种策略避免了同一时间有大量请求集中到同一台机器上并实现轮询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">   protected static class WeightedRoundRobin &#123;</span><br><span class="line">       private int weight;</span><br><span class="line">       &#x2F;&#x2F; currentWeight</span><br><span class="line">       private AtomicLong current &#x3D; new AtomicLong(0);</span><br><span class="line">       &#x2F;&#x2F; 更新currentWeight时间戳</span><br><span class="line">       private long lastUpdate;</span><br><span class="line">       public int getWeight() &#123;</span><br><span class="line">           return weight;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setWeight(int weight) &#123;</span><br><span class="line">           this.weight &#x3D; weight;</span><br><span class="line">           current.set(0);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; currentWeight +&#x3D; weight</span><br><span class="line">       public long increaseCurrent() &#123;</span><br><span class="line">           return current.addAndGet(weight);</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; currentWeight -&#x3D; totalWeight</span><br><span class="line">       public void sel(int total) &#123;</span><br><span class="line">           current.addAndGet(-1 * total);</span><br><span class="line">       &#125;</span><br><span class="line">       public long getLastUpdate() &#123;</span><br><span class="line">           return lastUpdate;</span><br><span class="line">       &#125;</span><br><span class="line">       public void setLastUpdate(long lastUpdate) &#123;</span><br><span class="line">           this.lastUpdate &#x3D; lastUpdate;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123;&quot;服务名.方法名&quot;: &#123;&quot;url(服务提供者)&quot;: WeightedRoundRobin&#125;&#125;</span><br><span class="line">   private ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap &#x3D; new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">   &#x2F;&#x2F; 更新锁，用于移除过期节点</span><br><span class="line">   private AtomicBoolean updateLock &#x3D; new AtomicBoolean();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">   	&#x2F;&#x2F; 第一层索引 &quot;服务名.方法名&quot;</span><br><span class="line">       String key &#x3D; invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();</span><br><span class="line">       &#x2F;&#x2F; 获取&#123;&quot;url(服务提供者)&quot;: WeightedRoundRobin&#125; 不存在就创建</span><br><span class="line">       ConcurrentMap&lt;String, WeightedRoundRobin&gt; map &#x3D; methodWeightMap.get(key);</span><br><span class="line">       if (map &#x3D;&#x3D; null) &#123;</span><br><span class="line">           methodWeightMap.putIfAbsent(key, new ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;());</span><br><span class="line">           map &#x3D; methodWeightMap.get(key);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       int totalWeight &#x3D; 0;</span><br><span class="line">       &#x2F;&#x2F; 当前currentWeight最大值</span><br><span class="line">       long maxCurrent &#x3D; Long.MIN_VALUE;</span><br><span class="line">       long now &#x3D; System.currentTimeMillis();</span><br><span class="line">       Invoker&lt;T&gt; selectedInvoker &#x3D; null;</span><br><span class="line">       WeightedRoundRobin selectedWRR &#x3D; null;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 遍历服务提供者 currentWeight+&#x3D;weight 统计totalWeight 查找currentWeight最大的节点 </span><br><span class="line">       for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">       	&#x2F;&#x2F; 根据服务提供者找到对应的WeightedRoundRobin</span><br><span class="line">           String identifyString &#x3D; invoker.getUrl().toIdentityString();</span><br><span class="line">           WeightedRoundRobin weightedRoundRobin &#x3D; map.get(identifyString);</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 获取权重(带预热机制)</span><br><span class="line">           int weight &#x3D; getWeight(invoker, invocation);</span><br><span class="line">           if (weight &lt; 0) &#123;</span><br><span class="line">               weight &#x3D; 0;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 如果不存在对应的weightedRoundRobin则新建</span><br><span class="line">           if (weightedRoundRobin &#x3D;&#x3D; null) &#123;</span><br><span class="line">               weightedRoundRobin &#x3D; new WeightedRoundRobin();</span><br><span class="line">               weightedRoundRobin.setWeight(weight);</span><br><span class="line">               map.putIfAbsent(identifyString, weightedRoundRobin);</span><br><span class="line">               weightedRoundRobin &#x3D; map.get(identifyString);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; weight有更新，则重置weight与currentWeight</span><br><span class="line">           if (weight !&#x3D; weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">               &#x2F;&#x2F;weight changed</span><br><span class="line">               weightedRoundRobin.setWeight(weight);</span><br><span class="line">           &#125;</span><br><span class="line">           &#x2F;&#x2F; currentWeight +&#x3D; weight</span><br><span class="line">           long cur &#x3D; weightedRoundRobin.increaseCurrent();</span><br><span class="line">           weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">           &#x2F;&#x2F; 如果大于当前currentWeight节点，则替换</span><br><span class="line">           if (cur &gt; maxCurrent) &#123;</span><br><span class="line">               maxCurrent &#x3D; cur;</span><br><span class="line">               selectedInvoker &#x3D; invoker;</span><br><span class="line">               selectedWRR &#x3D; weightedRoundRobin;</span><br><span class="line">           &#125;</span><br><span class="line">           totalWeight +&#x3D; weight;</span><br><span class="line">       &#125; &#x2F;&#x2F; for end</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 服务提供者数量与历史数量不一致，需移除过期的节点</span><br><span class="line">       if (!updateLock.get() &amp;&amp; invokers.size() !&#x3D; map.size()) &#123;</span><br><span class="line">           if (updateLock.compareAndSet(false, true)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   &#x2F;&#x2F; copy -&gt; modify -&gt; update reference</span><br><span class="line">                   ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap &#x3D; new ConcurrentHashMap&lt;String, WeightedRoundRobin&gt;();</span><br><span class="line">                   newMap.putAll(map);</span><br><span class="line">                   Iterator&lt;Entry&lt;String, WeightedRoundRobin&gt;&gt; it &#x3D; newMap.entrySet().iterator();</span><br><span class="line">                   while (it.hasNext()) &#123;</span><br><span class="line">                       Entry&lt;String, WeightedRoundRobin&gt; item &#x3D; it.next();</span><br><span class="line">                       if (now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD) &#123;</span><br><span class="line">                           it.remove();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   methodWeightMap.put(key, newMap);</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   updateLock.set(false);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; currentWeight -&#x3D; totalWeight</span><br><span class="line">       if (selectedInvoker !&#x3D; null) &#123;</span><br><span class="line">           selectedWRR.sel(totalWeight);</span><br><span class="line">           return selectedInvoker;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; should not happen here</span><br><span class="line">       return invokers.get(0);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h5><h6 id="ribbon负载均衡组件"><a href="#ribbon负载均衡组件" class="headerlink" title="ribbon负载均衡组件"></a>ribbon负载均衡组件</h6><ul>
<li>Rule 决定采用哪个服务提供者。</li>
<li>Ping 用于确认服务提供者存活。</li>
<li>ServerList 静态或动态的地址列表，如果是动态则后台会定时刷新过滤该列表。</li>
</ul>
<h6 id="使用配置文件配置"><a href="#使用配置文件配置" class="headerlink" title="使用配置文件配置"></a>使用配置文件配置</h6><ul>
<li>&lt;clientName&gt;.ribbon.NFLoadBalancerClassName: Should implement ILoadBalancer</li>
<li>&lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName: Should implement IRule</li>
<li>&lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName: Should implement IPing</li>
<li>&lt;clientName&gt;.ribbon.NIWSServerListClassName: Should implement ServerList</li>
<li>&lt;clientName&gt;.ribbon.NIWSServerListFilterClassName: Should implement ServerListFilter</li>
</ul>
<p>示例: 为user服务设定负载均衡策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users:</span><br><span class="line">  ribbon:</span><br><span class="line">    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h5><h6 id="RoundRobinRule-轮询"><a href="#RoundRobinRule-轮询" class="headerlink" title="RoundRobinRule(轮询)"></a>RoundRobinRule(轮询)</h6><p>简单轮询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;下一个服务提供者在列表中的位置</span><br><span class="line">   private AtomicInteger nextServerCyclicCounter;</span><br><span class="line">   </span><br><span class="line">   public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">       if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">           log.warn(&quot;no load balancer&quot;);</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 选取的服务提供者</span><br><span class="line">       Server server &#x3D; null;</span><br><span class="line">       &#x2F;&#x2F; 重试计数</span><br><span class="line">       int count &#x3D; 0;</span><br><span class="line">       &#x2F;&#x2F; 轮询</span><br><span class="line">       while (server &#x3D;&#x3D; null &amp;&amp; count++ &lt; 10) &#123;</span><br><span class="line">           List&lt;Server&gt; reachableServers &#x3D; lb.getReachableServers();</span><br><span class="line">           &#x2F;&#x2F; 所有服务提供者</span><br><span class="line">           List&lt;Server&gt; allServers &#x3D; lb.getAllServers();</span><br><span class="line">           &#x2F;&#x2F; 可用的服务提供者数量</span><br><span class="line">           int upCount &#x3D; reachableServers.size();</span><br><span class="line">           &#x2F;&#x2F; 所有服务提供者数量</span><br><span class="line">           int serverCount &#x3D; allServers.size();</span><br><span class="line"></span><br><span class="line">           if ((upCount &#x3D;&#x3D; 0) || (serverCount &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">               log.warn(&quot;No up servers available from load balancer: &quot; + lb);</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; nextServerIndex &#x3D; (nextServerIndex + 1) % total </span><br><span class="line">           int nextServerIndex &#x3D; incrementAndGetModulo(serverCount);</span><br><span class="line">           server &#x3D; allServers.get(nextServerIndex);</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 如果提供者因某些原因(如down)从列表中移除了，则让步一段时间后再重新选取</span><br><span class="line">           if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">               &#x2F;* Transient. *&#x2F;</span><br><span class="line">               Thread.yield();</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 服务提供者存活且可提供服务则返回</span><br><span class="line">           if (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;</span><br><span class="line">               return (server);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; Next.</span><br><span class="line">           server &#x3D; null;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 重试次数过多</span><br><span class="line">       if (count &gt;&#x3D; 10) &#123;</span><br><span class="line">           log.warn(&quot;No available alive servers after 10 tries from load balancer: &quot;</span><br><span class="line">                   + lb);</span><br><span class="line">       &#125;</span><br><span class="line">       return server;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h6 id="AvailabilityFilteringRule-可用服务轮询"><a href="#AvailabilityFilteringRule-可用服务轮询" class="headerlink" title="AvailabilityFilteringRule(可用服务轮询)"></a>AvailabilityFilteringRule(可用服务轮询)</h6><p>在简单轮询策略基础上，对服务提供者做可用性过滤:</p>
<ol>
<li><p>在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。</p>
</li>
<li><p>并发数过高的服务器。如果一个服务器的并发连接数过高(默认Integer.MAX_INT)，配置了AvailabilityFilteringRule规则的客户端也会将其忽略。</p>
</li>
</ol>
<p>相关配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 重试次数</span><br><span class="line">niws.loadbalancer.&lt;clientName&gt;.connectionFailureCountThreshold</span><br><span class="line"></span><br><span class="line"># 短路状态持续时长</span><br><span class="line">niws.loadbalancer.&lt;clientName&gt;.circuitTripMaxTimeoutSeconds</span><br><span class="line"></span><br><span class="line"># 并发连接数</span><br><span class="line">&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit</span><br></pre></td></tr></table></figure>
<p><img src="/images/cloud/AvailabilityFilteringRuleUML.png" alt="AvailabilityFilteringRuleUML"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ClientConfigEnabledRoundRobinRule extends AbstractLoadBalancerRule &#123;</span><br><span class="line">	&#x2F;&#x2F;默认简单轮询</span><br><span class="line">    RoundRobinRule roundRobinRule &#x3D; new RoundRobinRule();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initWithNiwsConfig(IClientConfig clientConfig) &#123;</span><br><span class="line">        roundRobinRule &#x3D; new RoundRobinRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setLoadBalancer(ILoadBalancer lb) &#123;</span><br><span class="line">    	super.setLoadBalancer(lb);</span><br><span class="line">    	roundRobinRule.setLoadBalancer(lb);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class PredicateBasedRule extends ClientConfigEnabledRoundRobinRule &#123;</span><br><span class="line">	&#x2F;&#x2F; 提供了一些过滤方法的抽象类，基于google guava</span><br><span class="line">    public abstract AbstractServerPredicate getPredicate();</span><br><span class="line">        </span><br><span class="line">    @Override</span><br><span class="line">    public Server choose(Object key) &#123;</span><br><span class="line">        ILoadBalancer lb &#x3D; getLoadBalancer();</span><br><span class="line">        &#x2F;&#x2F; 遍历所有服务提供者并过滤出符合条件的进行轮询选取(先过滤，再选取)</span><br><span class="line">        Optional&lt;Server&gt; server &#x3D; getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);</span><br><span class="line">        if (server.isPresent()) &#123;</span><br><span class="line">            return server.get();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class AvailabilityFilteringRule extends PredicateBasedRule &#123;   </span><br><span class="line">    public AvailabilityFilteringRule() &#123;</span><br><span class="line">    	super();</span><br><span class="line">        &#x2F;&#x2F; 判断条件 CompositePredicate 组合过滤条件</span><br><span class="line">        &#x2F;&#x2F; AvailabilityPredicate类 实际上这里的判断条件</span><br><span class="line">    	predicate &#x3D; CompositePredicate.withPredicate(new AvailabilityPredicate(this, null))</span><br><span class="line">                .addFallbackPredicate(AbstractServerPredicate.alwaysTrue())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    &#x2F;&#x2F; 这里相比PredicateBasedRule会少一次服务器列表遍历</span><br><span class="line">    public Server choose(Object key) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 重试次数</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 直接轮询选取</span><br><span class="line">        Server server &#x3D; roundRobinRule.choose(key);</span><br><span class="line">        while (count++ &lt;&#x3D; 10) &#123;</span><br><span class="line">        	&#x2F;&#x2F; 符合条件则返回</span><br><span class="line">            if (predicate.apply(new PredicateKey(server))) &#123;</span><br><span class="line">                return server;</span><br><span class="line">            &#125;</span><br><span class="line">            server &#x3D; roundRobinRule.choose(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return super.choose(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class AvailabilityPredicate extends  AbstractServerPredicate &#123;</span><br><span class="line">	...</span><br><span class="line">    @Override</span><br><span class="line">    public boolean apply(@Nullable PredicateKey input) &#123;</span><br><span class="line">        LoadBalancerStats stats &#x3D; getLBStats();</span><br><span class="line">        if (stats &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return !shouldSkipServer(stats.getSingleServerStat(input.getServer()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private boolean shouldSkipServer(ServerStats stats) &#123;        </span><br><span class="line">    	&#x2F;&#x2F;短路状态判断以及并发数量判断</span><br><span class="line">        if ((CIRCUIT_BREAKER_FILTERING.get() &amp;&amp; stats.isCircuitBreakerTripped()) </span><br><span class="line">                || stats.getActiveRequestsCount() &gt;&#x3D; activeConnectionsLimit.get()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="WeightedResponseTimeRule-响应时长作为权重的随机选择"><a href="#WeightedResponseTimeRule-响应时长作为权重的随机选择" class="headerlink" title="WeightedResponseTimeRule(响应时长作为权重的随机选择)"></a>WeightedResponseTimeRule(响应时长作为权重的随机选择)</h6><p>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。权重定时刷新(默认30s)。<br>对于每次请求:</p>
<ol>
<li>遍历服务提供者列表，计算出平均响应时间总和totalResponseTime += avgResponseTime</li>
<li>再次遍历服务提供者列表，获得当前提供者的权重weight = totalResponseTime - avgResponseTime，并记录下列表累计权重和用于随机accumulatedWeights[i] = accumulatedWeights[i - 1] + weight</li>
<li>生成随机数并进行选取，失败的情况下会回退至简单轮询</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">public class WeightedResponseTimeRule extends RoundRobinRule &#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 累积权重存放，[0]存放了服务器[0]的权重，[1]存放了服务器[0]到[1]的权重和</span><br><span class="line">    &#x2F;&#x2F; [n]则存放了服务器[0]到[n]的权重和</span><br><span class="line">	private volatile List&lt;Double&gt; accumulatedWeights &#x3D; new ArrayList&lt;Double&gt;();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 更新权重用的Timer</span><br><span class="line">    protected Timer serverWeightTimer &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 更新权重锁</span><br><span class="line">    protected AtomicBoolean serverWeightAssignmentInProgress &#x3D; new AtomicBoolean(false);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化维护权重任务</span><br><span class="line">    void initialize(ILoadBalancer lb) &#123;        </span><br><span class="line">        if (serverWeightTimer !&#x3D; null) &#123;</span><br><span class="line">            serverWeightTimer.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        serverWeightTimer &#x3D; new Timer(&quot;NFLoadBalancer-serverWeightTimer-&quot;</span><br><span class="line">                + name, true);</span><br><span class="line">        &#x2F;&#x2F; 启动维护权重任务 </span><br><span class="line">        &#x2F;&#x2F; DynamicServerWeightTask里执行了 new ServerWeight().maintainWeights()</span><br><span class="line">        &#x2F;&#x2F; serverWeightTaskTimerInterval 默认30 * 1000</span><br><span class="line">        serverWeightTimer.schedule(new DynamicServerWeightTask(), 0,</span><br><span class="line">                serverWeightTaskTimerInterval);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 初始化权重值</span><br><span class="line">        ServerWeight sw &#x3D; new ServerWeight();</span><br><span class="line">        sw.maintainWeights();</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                logger</span><br><span class="line">                        .info(&quot;Stopping NFLoadBalancer-serverWeightTimer-&quot;</span><br><span class="line">                                + name);</span><br><span class="line">                serverWeightTimer.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class ServerWeight &#123;</span><br><span class="line">    	&#x2F;&#x2F; 维护权重</span><br><span class="line">        public void maintainWeights() &#123;</span><br><span class="line">            ILoadBalancer lb &#x3D; getLoadBalancer();</span><br><span class="line">            if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 获取锁</span><br><span class="line">            if (!serverWeightAssignmentInProgress.compareAndSet(false,  true))  &#123;</span><br><span class="line">                return; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            try &#123;</span><br><span class="line">                logger.info(&quot;Weight adjusting job started&quot;);</span><br><span class="line">                AbstractLoadBalancer nlb &#x3D; (AbstractLoadBalancer) lb;</span><br><span class="line">                LoadBalancerStats stats &#x3D; nlb.getLoadBalancerStats();</span><br><span class="line">                if (stats &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; no statistics, nothing to do</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 所有服务提供者的响应时间和</span><br><span class="line">                double totalResponseTime &#x3D; 0;</span><br><span class="line">                &#x2F;&#x2F; 获取所有提供者平均响应时间和</span><br><span class="line">                for (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; this will automatically load the stats if not in cache</span><br><span class="line">                    ServerStats ss &#x3D; stats.getSingleServerStat(server);</span><br><span class="line">                    totalResponseTime +&#x3D; ss.getResponseTimeAvg();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 累积权重</span><br><span class="line">                Double weightSoFar &#x3D; 0.0;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; create new list and hot swap the reference</span><br><span class="line">                &#x2F;&#x2F; 累积权重存放 accumulatedWeights</span><br><span class="line">                List&lt;Double&gt; finalWeights &#x3D; new ArrayList&lt;Double&gt;();</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 获取提供者的权重以及累积权重</span><br><span class="line">                for (Server server : nlb.getAllServers()) &#123;</span><br><span class="line">                    ServerStats ss &#x3D; stats.getSingleServerStat(server);</span><br><span class="line">                    double weight &#x3D; totalResponseTime - ss.getResponseTimeAvg();</span><br><span class="line">                    weightSoFar +&#x3D; weight;</span><br><span class="line">                    finalWeights.add(weightSoFar);   </span><br><span class="line">                &#125;</span><br><span class="line">                setWeights(finalWeights);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;Error calculating server weights&quot;, e);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                serverWeightAssignmentInProgress.set(false);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        @Override</span><br><span class="line">    public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">        if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Server server &#x3D; null;</span><br><span class="line"></span><br><span class="line">        while (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; get hold of the current reference in case it is changed from the other thread</span><br><span class="line">            List&lt;Double&gt; currentWeights &#x3D; accumulatedWeights;</span><br><span class="line">            if (Thread.interrupted()) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Server&gt; allList &#x3D; lb.getAllServers();</span><br><span class="line"></span><br><span class="line">            int serverCount &#x3D; allList.size();</span><br><span class="line"></span><br><span class="line">            if (serverCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int serverIndex &#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取所有服务器权重和</span><br><span class="line">            double maxTotalWeight &#x3D; currentWeights.size() &#x3D;&#x3D; 0 ? 0 : currentWeights.get(currentWeights.size() - 1); </span><br><span class="line">            &#x2F;&#x2F; 权重值过期或未初始化时回退至简单轮询</span><br><span class="line">            if (maxTotalWeight &lt; 0.001d || serverCount !&#x3D; currentWeights.size()) &#123;</span><br><span class="line">                server &#x3D;  super.choose(getLoadBalancer(), key);</span><br><span class="line">                if(server &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return server;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	&#x2F;&#x2F; 生成随机数并进行选取服务提供者</span><br><span class="line">                &#x2F;&#x2F; generate a random weight between 0 (inclusive) to maxTotalWeight (exclusive)</span><br><span class="line">                double randomWeight &#x3D; random.nextDouble() * maxTotalWeight;</span><br><span class="line">                &#x2F;&#x2F; pick the server index based on the randomIndex</span><br><span class="line">                int n &#x3D; 0;</span><br><span class="line">                for (Double d : currentWeights) &#123;</span><br><span class="line">                    if (d &gt;&#x3D; randomWeight) &#123;</span><br><span class="line">                        serverIndex &#x3D; n;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        n++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                server &#x3D; allList.get(serverIndex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;* Transient. *&#x2F;</span><br><span class="line">                Thread.yield();</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (server.isAlive()) &#123;</span><br><span class="line">                return (server);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Next.</span><br><span class="line">            server &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        return server;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wiki上提到的规则是以上三种，下面是wiki上并未提及但Ribbon已实现的一些规则。</p>
<h6 id="BestAvailableRule-最佳可用"><a href="#BestAvailableRule-最佳可用" class="headerlink" title="BestAvailableRule(最佳可用)"></a>BestAvailableRule(最佳可用)</h6><p>忽略短路的提供者，然后选择并发数(最少活跃)的提供者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule &#123;</span><br><span class="line">	...</span><br><span class="line">    @Override</span><br><span class="line">    public Server choose(Object key) &#123;</span><br><span class="line">        if (loadBalancerStats &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return super.choose(key);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Server&gt; serverList &#x3D; getLoadBalancer().getAllServers();</span><br><span class="line">        &#x2F;&#x2F; 最少活跃数</span><br><span class="line">        int minimalConcurrentConnections &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        long currentTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        Server chosen &#x3D; null;</span><br><span class="line">        for (Server server: serverList) &#123;</span><br><span class="line">            ServerStats serverStats &#x3D; loadBalancerStats.getSingleServerStat(server);</span><br><span class="line">            &#x2F;&#x2F; 选择未短路的服务提供者进行比较</span><br><span class="line">            if (!serverStats.isCircuitBreakerTripped(currentTime)) &#123;</span><br><span class="line">            	&#x2F;&#x2F; 比较当前活跃数 如果小则替换</span><br><span class="line">                int concurrentConnections &#x3D; serverStats.getActiveRequestsCount(currentTime);</span><br><span class="line">                if (concurrentConnections &lt; minimalConcurrentConnections) &#123;</span><br><span class="line">                    minimalConcurrentConnections &#x3D; concurrentConnections;</span><br><span class="line">                    chosen &#x3D; server;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (chosen &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return super.choose(key);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return chosen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="RandomRule-随机-请勿使用，见github-issue链接"><a href="#RandomRule-随机-请勿使用，见github-issue链接" class="headerlink" title="RandomRule(随机) 请勿使用，见github issue链接"></a>RandomRule(随机) 请勿使用，见github issue链接</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">    if (lb &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Server server &#x3D; null;</span><br><span class="line"></span><br><span class="line">    while (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 可用服务提供者列表</span><br><span class="line">        List&lt;Server&gt; upList &#x3D; lb.getReachableServers();</span><br><span class="line">        List&lt;Server&gt; allList &#x3D; lb.getAllServers();</span><br><span class="line"></span><br><span class="line">        int serverCount &#x3D; allList.size();</span><br><span class="line">        if (serverCount &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * No servers. End regardless of pass, because subsequent passes</span><br><span class="line">             * only get more restrictive.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; index &#x3D; ThreadLocalRandom.current().nextInt(serverCount)</span><br><span class="line">        int index &#x3D; chooseRandomInt(serverCount);</span><br><span class="line">        &#x2F;&#x2F; upList获取可用实例，越界警告</span><br><span class="line">        server &#x3D; upList.get(index);</span><br><span class="line"></span><br><span class="line">        if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">             * The only time this should happen is if the server list were</span><br><span class="line">             * somehow trimmed. This is a transient condition. Retry after</span><br><span class="line">             * yielding.</span><br><span class="line">             *&#x2F;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (server.isAlive()) &#123;</span><br><span class="line">            return (server);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Shouldn&#39;t actually happen.. but must be transient or a bug.</span><br><span class="line">        server &#x3D; null;</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return server;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请勿使用该规则，在获取提供者时server = upList.get(index);其中upList是可用提供者列表，而index是由所有提供者数量生成的随机数，这可能会产生越界错误(当有server处于非UP时)，去github上查了下这个bug一直没修：<a href="https://github.com/Netflix/ribbon/issues/233" target="_blank" rel="noopener">RandomRule incorrect index bug</a></p>
<h6 id="RetryRule"><a href="#RetryRule" class="headerlink" title="RetryRule"></a>RetryRule</h6><p>重试机制，需配合其他规则使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class RetryRule extends AbstractLoadBalancerRule &#123;</span><br><span class="line">	&#x2F;&#x2F; 默认规则轮询，可设</span><br><span class="line">	IRule subRule &#x3D; new RoundRobinRule();</span><br><span class="line">    &#x2F;&#x2F; 默认重试时长</span><br><span class="line">	long maxRetryMillis &#x3D; 500;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	public Server choose(ILoadBalancer lb, Object key) &#123;</span><br><span class="line">    	&#x2F;&#x2F; 请求时间</span><br><span class="line">		long requestTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F; 截至时间</span><br><span class="line">		long deadline &#x3D; requestTime + maxRetryMillis;</span><br><span class="line"></span><br><span class="line">		Server answer &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 根据子规则选取服务提供者</span><br><span class="line">		answer &#x3D; subRule.choose(key);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 时间不超过deadline时，如选取失败，进行重试</span><br><span class="line">		if (((answer &#x3D;&#x3D; null) || (!answer.isAlive()))</span><br><span class="line">				&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 设定一个定时任务来执行中断以在超时时退出选取</span><br><span class="line">			InterruptTask task &#x3D; new InterruptTask(deadline</span><br><span class="line">					- System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">			while (!Thread.interrupted()) &#123;</span><br><span class="line">				answer &#x3D; subRule.choose(key);</span><br><span class="line"></span><br><span class="line">				if (((answer &#x3D;&#x3D; null) || (!answer.isAlive()))</span><br><span class="line">						&amp;&amp; (System.currentTimeMillis() &lt; deadline)) &#123;</span><br><span class="line">					&#x2F;* pause and retry hoping it&#39;s transient *&#x2F;</span><br><span class="line">					Thread.yield();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">                	&#x2F;&#x2F; 选取成功</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            &#x2F;&#x2F; 取消该定时器</span><br><span class="line">			task.cancel();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if ((answer &#x3D;&#x3D; null) || (!answer.isAlive())) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return answer;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ZoneAvoidanceRule-区域过滤轮询"><a href="#ZoneAvoidanceRule-区域过滤轮询" class="headerlink" title="ZoneAvoidanceRule(区域过滤轮询)"></a>ZoneAvoidanceRule(区域过滤轮询)</h6><p>ZoneAvoidanceRule继承了PredicateBasedRule(见AvailabilityFilteringRule)，因为他没有重写choose方法，所以他只是在新定义的规则上对所有服务提供者进行过滤再轮询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class ZoneAvoidanceRule extends PredicateBasedRule &#123;</span><br><span class="line">	&#x2F;&#x2F; 过滤条件</span><br><span class="line">    private CompositePredicate compositePredicate;</span><br><span class="line">    </span><br><span class="line">    public ZoneAvoidanceRule() &#123;</span><br><span class="line">        super();</span><br><span class="line">        ZoneAvoidancePredicate zonePredicate &#x3D; new ZoneAvoidancePredicate(this);</span><br><span class="line">        AvailabilityPredicate availabilityPredicate &#x3D; new AvailabilityPredicate(this);</span><br><span class="line">        compositePredicate &#x3D; createCompositePredicate(zonePredicate, availabilityPredicate);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private CompositePredicate createCompositePredicate(ZoneAvoidancePredicate p1, AvailabilityPredicate p2) &#123;</span><br><span class="line">    	&#x2F;&#x2F; ZoneAvoidancePredicate为主，AvailabilityPredicate为副的组合过滤条件</span><br><span class="line">        return CompositePredicate.withPredicates(p1, p2)</span><br><span class="line">                             .addFallbackPredicate(p2)</span><br><span class="line">                             .addFallbackPredicate(AbstractServerPredicate.alwaysTrue())</span><br><span class="line">                             .build();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://www.nginx.com/resources/glossary/load-balancing/" target="_blank" rel="noopener">What Is Load Balancing?</a></li>
<li><a href="https://www.cnblogs.com/wpjamer/articles/6443332.html" target="_blank" rel="noopener">解析 Nginx 负载均衡策略</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">一致哈希</a></li>
<li><a href="https://github.com/Netflix/ribbon/wiki/Working-with-load-balancers" target="_blank" rel="noopener">Ribbon Working with load balancers</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/03/13/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" data-id="ckbrzih75002817ld395q4rfc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/16/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99-%E4%B8%80-%E9%87%8D%E8%AF%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          服务容错(一) 重试
        
      </div>
    </a>
  
  
    <a href="/2019/03/12/Eclipse%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Eclipse常用插件</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring-webflux/">spring webflux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/couchbase/" rel="tag">couchbase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elastic-search/" rel="tag">elastic search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elk/" rel="tag">elk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%91%BD%E4%BB%A4/" rel="tag">java命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reactive/" rel="tag">reactive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stream/" rel="tag">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/couchbase/" style="font-size: 10px;">couchbase</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/elastic-search/" style="font-size: 10px;">elastic search</a> <a href="/tags/elk/" style="font-size: 10px;">elk</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/java%E5%91%BD%E4%BB%A4/" style="font-size: 17.5px;">java命令</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">java基础</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/reactive/" style="font-size: 10px;">reactive</a> <a href="/tags/spring-cloud/" style="font-size: 20px;">spring cloud</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/22/Spring-Reactive-Data-With-Multi-Couchbase-Buckets/">Spring Reactive Data With Multi Couchbase Buckets</a>
          </li>
        
          <li>
            <a href="/2019/06/05/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E5%9F%9F%E5%90%8D%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/">反向代理解决微信小程序业务域名限制问题</a>
          </li>
        
          <li>
            <a href="/2019/05/13/Stream-%E7%BC%96%E7%A8%8B%E8%83%8C%E5%90%8E/">Stream实现原理</a>
          </li>
        
          <li>
            <a href="/2019/05/04/jdk8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">jdk8函数式编程</a>
          </li>
        
          <li>
            <a href="/2019/04/27/OWASP%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/">OWASP第三方依赖检查插件使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 lyyljs<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>