<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>jdk8函数式编程 | lyyljs`s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Lambda表达式Lambda表达式允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理。这一特性在许多语言都有支持，如pyhton, js等。Jdk1.8开始，Java也支持Lambda表达式。 最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：">
<meta property="og:type" content="article">
<meta property="og:title" content="jdk8函数式编程">
<meta property="og:url" content="http://lyyljs.site/2019/05/04/jdk8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="lyyljs&#96;s blog">
<meta property="og:description" content="Lambda表达式Lambda表达式允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理。这一特性在许多语言都有支持，如pyhton, js等。Jdk1.8开始，Java也支持Lambda表达式。 最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-05-04T07:41:00.000Z">
<meta property="article:modified_time" content="2020-05-28T14:26:41.000Z">
<meta property="article:author" content="lyyljs">
<meta property="article:tag" content="开发者">
<meta property="article:tag" content="程序猿">
<meta property="article:tag" content="程序媛">
<meta property="article:tag" content="编程">
<meta property="article:tag" content="代码">
<meta property="article:tag" content="Developer">
<meta property="article:tag" content="Programmer">
<meta property="article:tag" content="Coder">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="lyyljs`s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">lyyljs`s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lyyljs.site"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-jdk8函数式编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/04/jdk8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2019-05-04T07:41:00.000Z" itemprop="datePublished">2019-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      jdk8函数式编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>Lambda表达式允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理。这一特性在许多语言都有支持，如pyhton, js等。Jdk1.8开始，Java也支持Lambda表达式。</p>
<p>最简单的Lambda表达式可由逗号分隔的参数列表、-&gt;符号和语句块组成，例如：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach(e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>

<p>上面的参数e类型由编译器推导得出，也可显式指定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach((String e) -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>

<p>对于复杂语句块，可以使用花括号扩起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach(e -&gt; &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            System.out.println(e.contains(&quot;a&quot;));</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>Lambda可以引用类成员和局部变量，会将这些变量隐式得转换成final，如以下代码则会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String t &#x3D; &quot;a&quot;;</span><br><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach(e -&gt;</span><br><span class="line">  System.out.println(e + t)); &#x2F;&#x2F; Variable used in lambda expression should be final or effectively final</span><br><span class="line">t &#x3D; &quot;b&quot;;</span><br></pre></td></tr></table></figure>

<p>去掉 t=”b”; 则可正常运行。</p>
<p>Lambda表达式有返回值，返回值的类型也由编译器推理得出。如果Lambda表达式中的语句块只有一行，则可以不用使用return语句，下列两个代码片段效果相同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).sort((e1, e2) -&gt; e1.compareTo(e2));</span><br><span class="line"></span><br><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).sort((e1, e2) -&gt; &#123;</span><br><span class="line">    return e1.compareTo(e2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>在Java中，Lambda表达式则是一种折中的实现方式。Java的Lambda表达式依赖与函数接口，函数接口指的是只有一个抽象方法的接口，<br>这样的接口可以隐式转换为Lambda表达式。</p>
<p>还是从最简单的Lambda表达式开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach(e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>

<p>跳转至 Iterable 接口看看是怎么实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (T t : this) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里forEach方法接收了一个Consumer的参数，Consumer 则是一个函数接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Consumer&lt;T&gt; &#123;</span><br><span class="line">    void accept(T t);</span><br><span class="line"></span><br><span class="line">    default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        return (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@FunctionalInterface 注解显式的声明了 Consumer 是个函数式接口，它仅有一个抽象方法accept()；<br>需要注意的是，默认方法和静态方法不会破坏函数式接口的定义，因此上面的代码是合法的；<br>这使得其可以被转换为Lamda表达式，正如上面的示例。</p>
<p>JDK 1.8新增的函数接口在java.util.function包下：</p>
<ul>
<li>Consumer&lt; T&gt; 代表了接受一个输入参数并且无返回的操作。 函数： void accept(T t);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  default void forEach(Consumer&lt;? super T&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (T t : this) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach(e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure>

<ul>
<li>Function&lt; T, R&gt; 接受一个输入参数，返回一个结果。 函数： R apply(T t);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">      ...</span><br><span class="line">      &#x2F;**</span><br><span class="line">         *</span><br><span class="line">         * 如果给定的key不存在（或者key对应的value为null），就去计算mappingFunction的值；(存在则返回已存入的值)</span><br><span class="line">         *</span><br><span class="line">         * 如果mappingFunction的值不为null，就把key&#x3D;value放进去；</span><br><span class="line">         * 如果mappingFunction的值为null，就不会记录该映射关系，返回值为null；</span><br><span class="line">         * 如果计算mappingFunction的值的过程出现异常，再次抛出异常，不记录映射关系，返回null；</span><br><span class="line">         *&#x2F;</span><br><span class="line">      @Override</span><br><span class="line">      public V computeIfAbsent(K key,</span><br><span class="line">                             Function&lt;? super K, ? extends V&gt; mappingFunction) &#123;</span><br><span class="line">        if (mappingFunction &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        ...</span><br><span class="line">        V v &#x3D; mappingFunction.apply(key);</span><br><span class="line">        ...</span><br><span class="line">        return v;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">hashMap.computeIfAbsent(&quot;key&quot;, k -&gt; k.toUpperCase()); &#x2F;&#x2F; putIfAbsent(&quot;key&quot;, &quot;KEY&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>Predicate&lt; T&gt; 接受一个输入参数，返回一个布尔值结果。 函数： boolean test(T t);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static class Person &#123;</span><br><span class="line">  public enum Sex &#123;</span><br><span class="line">              MALE, FEMALE</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">  String name;</span><br><span class="line">  LocalDate birthday;</span><br><span class="line">  Sex gender;</span><br><span class="line">  String emailAddress;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void printPersonsWithPredicate(List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester) &#123;</span><br><span class="line">    for (Person p : roster) &#123;</span><br><span class="line">        if (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printPersonsWithPredicate(roster,</span><br><span class="line">                p -&gt; p.getGender() &#x3D;&#x3D; Person.Sex.MALE</span><br><span class="line">                        &amp;&amp; p.getAge() &gt;&#x3D; 18</span><br><span class="line">                        &amp;&amp; p.getAge() &lt;&#x3D; 25);</span><br></pre></td></tr></table></figure>

<ul>
<li>Supplier&lt; T&gt; 无参数，返回一个结果。 函数： T get();</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public final class Optional&lt; T&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;</span><br><span class="line">      return value !&#x3D; null ? value : other.get();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Optional.ofNullable(null).orElseGet(() -&gt; &quot;B&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>UnaryOperator&lt; T&gt; extends Function&lt; T, T&gt; 接受一个参数为类型T,返回值类型也为T。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line">  ...</span><br><span class="line">  public final V updateAndGet(UnaryOperator&lt;V&gt; updateFunction) &#123;</span><br><span class="line">        V prev, next;</span><br><span class="line">        do &#123;</span><br><span class="line">            prev &#x3D; get();</span><br><span class="line">            next &#x3D; updateFunction.apply(prev);</span><br><span class="line">        &#125; while (!compareAndSet(prev, next));</span><br><span class="line">        return next;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Person fake(String name)&#123;</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line">        person.name &#x3D; name;</span><br><span class="line">        ...</span><br><span class="line">        return person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AtomicReference&lt;Person&gt; person &#x3D; new AtomicReference&lt;&gt;(roster.get(0));</span><br><span class="line">person.updateAndGet(p -&gt; fake(p.name));</span><br></pre></td></tr></table></figure>

<ul>
<li>BiConsumer&lt; T, U&gt; 代表了一个接受两个输入参数的操作，并且不返回任何结果。 函数： void accept(T t, U u);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements ConcurrentMap&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">      ...</span><br><span class="line">      public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123;</span><br><span class="line">        if (action &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        if ((t &#x3D; table) !&#x3D; null) &#123;</span><br><span class="line">            Traverser&lt;K,V&gt; it &#x3D; new Traverser&lt;K,V&gt;(t, t.length, 0, t.length);</span><br><span class="line">            for (Node&lt;K,V&gt; p; (p &#x3D; it.advance()) !&#x3D; null; ) &#123;</span><br><span class="line">                action.accept(p.key, p.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">concurrentHashMap.forEach((k, v) -&gt; System.out.println(k + &quot; &quot; + v));</span><br></pre></td></tr></table></figure>

<ul>
<li>BiFunction&lt; T, U, R&gt; 代表了一个接受两个输入参数的方法，并且返回一个结果。 函数： R apply(T t, U u);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">      ...</span><br><span class="line">         public V computeIfPresent(K key,</span><br><span class="line">                                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">               if (remappingFunction &#x3D;&#x3D; null)</span><br><span class="line">                   throw new NullPointerException();</span><br><span class="line">               Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">               int hash &#x3D; hash(key);</span><br><span class="line">               if ((e &#x3D; getNode(hash, key)) !&#x3D; null &amp;&amp;</span><br><span class="line">                   (oldValue &#x3D; e.value) !&#x3D; null) &#123;</span><br><span class="line">                   V v &#x3D; remappingFunction.apply(key, oldValue);</span><br><span class="line">                   if (v !&#x3D; null) &#123;</span><br><span class="line">                       e.value &#x3D; v;</span><br><span class="line">                       afterNodeAccess(e);</span><br><span class="line">                       return v;</span><br><span class="line">                   &#125;</span><br><span class="line">                   else</span><br><span class="line">                       removeNode(hash, key, null, false, true);</span><br><span class="line">               &#125;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap&lt;String, String&gt; hashMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">hashMap.computeIfAbsent(&quot;key&quot;, k -&gt; k.toUpperCase()); &#x2F;&#x2F; putIfAbsent(&quot;key&quot;, &quot;KEY&quot;)</span><br><span class="line">hashMap.computeIfPresent(&quot;key&quot;, (k, v) -&gt; k + v); &#x2F;&#x2F; put(&quot;key&quot;, &quot;keyKey&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li>BinaryOperator&lt; T&gt; extends BiFunction&lt; T,T,T&gt;  代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;</span><br><span class="line">  ...</span><br><span class="line">  public final V accumulateAndGet(V x,</span><br><span class="line">                                    BinaryOperator&lt;V&gt; accumulatorFunction) &#123;</span><br><span class="line">        V prev, next;</span><br><span class="line">        do &#123;</span><br><span class="line">            prev &#x3D; get();</span><br><span class="line">            next &#x3D; accumulatorFunction.apply(prev, x);</span><br><span class="line">        &#125; while (!compareAndSet(prev, next));</span><br><span class="line">        return next;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AtomicReference&lt;Integer&gt; integerAtomicReference &#x3D; new AtomicReference&lt;&gt;(Integer.valueOf(1));</span><br><span class="line">integerAtomicReference.accumulateAndGet(5, (oldValue, newValue) -&gt; oldValue + newValue);</span><br></pre></td></tr></table></figure>

<ul>
<li>BiPredicate&lt; T, U&gt; 代表了一个两个参数的boolean值方法。 函数： boolean test(T t, U u);</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BiPredicate&lt;Integer, Integer&gt; largeThan &#x3D; (x, y) -&gt; x &gt; y;</span><br><span class="line">System.out.println(largeThan.test(2, 3));</span><br></pre></td></tr></table></figure>

<p>基础接口为以上，其他接口都是带类型的，如IntConsumer，其接收参数为int；ObjDoubleConsumer，接收一个obj和一个double。</p>
<p>除开 java.util.function 包下的接口，其它常见函数接口如下：</p>
<ul>
<li><p>java.lang.Runnable</p>
</li>
<li><p>java.util.concurrent.Callable</p>
</li>
<li><p>java.util.Comparator</p>
</li>
</ul>
<h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用通过方法的名字来指向一个方法。使用符号 :: 。 这可以使得代码更为紧凑。</p>
<p>如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>再如：<br>有一个 Car 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static class Car &#123;</span><br><span class="line">    public static Car create(Supplier&lt;Car&gt; supplier) &#123;</span><br><span class="line">        return supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void collide(Car car) &#123;</span><br><span class="line">        System.out.println(&quot;Collided &quot; + car.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void follow(Car another) &#123;</span><br><span class="line">        System.out.println(&quot;Following the &quot; + another.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void repair() &#123;</span><br><span class="line">        System.out.println(&quot;Repaired &quot; + this.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器引用：它的语法是Class::new，或者更一般的Class&lt; T &gt;::new</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car car &#x3D; Car.create(Car::new);</span><br></pre></td></tr></table></figure>

<ul>
<li>静态方法引用 Class::static_method</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Car&gt; cars &#x3D; Arrays.asList(car);</span><br><span class="line">cars.forEach(Car::collide);</span><br></pre></td></tr></table></figure>

<ul>
<li>特定类的任意方法引用 Class::method</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.forEach(Car::repair);</span><br></pre></td></tr></table></figure>

<ul>
<li>特定对象的方法引用 instance::method</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car lead &#x3D; Car.create(Car::new);</span><br><span class="line">cars.forEach(lead::follow);</span><br></pre></td></tr></table></figure>

<h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的。它更像一个高级版本的 Iterator，不可以重复遍历里面的数据，像水一样，流过了就一去不复返。它和普通的 Iterator 不同的是，它可以并行遍历，普通的 Iterator 只能是串行，在一个线程中执行。</p>
<p>当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架来拆分任务和加速处理过程。</p>
<p>Stream 的另外一大特点是，数据源本身可以是无限的。</p>
<h5 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h5><p>流的元素类型： Stream&lt; T&gt;, IntStream, LongStream, DoubleStream。</p>
<p>流计算由以下三部分构成： 流来源，0或多个中间操作，终止操作。</p>
<h6 id="流的来源-stream-source"><a href="#流的来源-stream-source" class="headerlink" title="流的来源(stream source)"></a>流的来源(stream source)</h6><ul>
<li>Colloection.stream() or parallelStream() 使用一个集合的元素创建一个流。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list &#x3D; Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;);</span><br><span class="line">Stream stream &#x3D; list.stream();</span><br></pre></td></tr></table></figure></li>
<li>Arrays.stream(T[] array) 使用数组创建流。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] array &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;d&quot;&#125;;</span><br><span class="line">Stream stream &#x3D; Arrays.stream(array);</span><br></pre></td></tr></table></figure></li>
<li>Stream.of(T t) 使用单个元素创建一个流。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream stream &#x3D; Stream.of(Integer.valueOf(&quot;123&quot;));</span><br></pre></td></tr></table></figure></li>
<li>Stream.of(T… values) 使用多个元素创建一个流。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream stream &#x3D; Stream.of(Integer.valueOf(&quot;123&quot;), Double.valueOf(&quot;233.0&quot;));</span><br></pre></td></tr></table></figure></li>
<li>Stream.empty()    创建一个空流。</li>
<li>Stream.iterate(final T seed, final UnaryOperator&lt; T&gt; f) 创建一个包含序列 first, f(first), f(f(first)), … 的无限流<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream stream &#x3D; Stream.iterate(1, e -&gt; e * 2); &#x2F;&#x2F; 2^N</span><br></pre></td></tr></table></figure></li>
<li>Stream.generate(Supplier<T> s) 使用一个生成器函数创建一个无限流。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream stream &#x3D; Stream.generate(Math::random);</span><br></pre></td></tr></table></figure></li>
<li>IntStream.range(int startInclusive, int endExclusive) 创建一个由下限到上限之间的元素组成的 IntStream。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream &#x3D; IntStream.range(1,10); &#x2F;&#x2F; 1-9</span><br></pre></td></tr></table></figure></li>
<li>Random.ints() 创建由随机数构成的无限流。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream &#x3D; new Random().ints();</span><br></pre></td></tr></table></figure></li>
<li>其他： BufferedReader.lines(); BitSet.stream(); Stream.chars(); Files.list(Path dir);<br>Pattern.splitAsStream(CharSequence input); JarFile.stream(); etc..</li>
</ul>
<h6 id="中间操作-intermediate-operation"><a href="#中间操作-intermediate-operation" class="headerlink" title="中间操作(intermediate operation)"></a>中间操作(intermediate operation)</h6><p>中间操作负责将一个流转换为另一个流。一个流可以后面跟随零个或多个中间操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是 lazy 的，就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>
<p>在对于一个 Stream 进行多次中间操作，每次都对 Stream 的每个元素进行转换，而且是执行多次，这样时间复杂度就是 N（转换次数）个 for 循环里把所有操作都做掉的总和吗？其实不是这样的，转换操作都是 lazy 的，多个中间操作只会在终止操作的时候融合起来，一次循环完成。我们可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在终结操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</p>
<p>中间操作包括 filter()（选择与条件匹配的元素）、map()（根据函数来转换元素）、distinct()（删除重复）、limit()（在特定大小处截断流）和 sorted()。</p>
<p>中间操作可进一步划分为无状态和有状态操作。<br>无状态操作（比如 filter() 或 map()）可独立处理每个元素，而有状态操作（比如 sorted() 或 distinct()）可合并以前看到的影响其他元素处理的元素状态。</p>
<ul>
<li><p>filter(Predicate&lt; T&gt;)    与预期匹配的流的元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.createRoster().stream().filter(person -&gt; person.getGender() &#x3D;&#x3D; Person.Sex.MALE</span><br><span class="line">                &amp;&amp; person.getAge() &gt;&#x3D; 18).collect(Collectors.toList()); &#x2F;&#x2F; 查找18岁以上的男性</span><br></pre></td></tr></table></figure>
</li>
<li><p>map(Function&lt; T, U&gt;)    将提供的函数应用于流的元素的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.createRoster().stream().map(person -&gt; person.getAge()).collect(Collectors.toSet()); &#x2F;&#x2F; 获取所有人的年龄集合</span><br></pre></td></tr></table></figure>
</li>
<li><p>flatMap(Function&lt; T, Stream&lt; U&gt;&gt;    将提供的流处理函数应用于流元素后获得的流元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] words &#x3D; new String[]&#123;&quot;abc&quot;,&quot;abc&quot;,&quot;abc&quot;&#125;;</span><br><span class="line">Arrays.stream(words)</span><br><span class="line">                .map(word -&gt; word.split(&quot;&quot;))</span><br><span class="line">                .flatMap(Arrays::stream) &#x2F;&#x2F; 将三个String[]流元素使用Arrays.stream(T..)处理获得String流</span><br><span class="line">                .distinct()</span><br><span class="line">                .forEach(System.out::print);</span><br></pre></td></tr></table></figure>
</li>
<li><p>distinct() 去除重复元素，实际使用了ConcurrentHashMap&lt; T, Boolean&gt;进行操作，所以是根据hashcode进行去重的。(参见DistinctOps类)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] words &#x3D; new String[]&#123;&quot;abc&quot;,&quot;abc&quot;,&quot;abc&quot;&#125;;</span><br><span class="line">Arrays.stream(words)</span><br><span class="line">                .map(word -&gt; word.split(&quot;&quot;))</span><br><span class="line">                .flatMap(Arrays::stream) &#x2F;&#x2F; 将三个String[]流元素使用Arrays.stream(T..)处理获得String流</span><br><span class="line">                .distinct() &#x2F;&#x2F;去重</span><br><span class="line">                .forEach(System.out::print); &#x2F;&#x2F;输出abc</span><br></pre></td></tr></table></figure>
</li>
<li><p>sorted() OR sorted(Comparator&lt;? super T&gt;) 对流元素进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String[] words &#x3D; new String[]&#123;&quot;cbad&quot;,&quot;def&quot;&#125;;</span><br><span class="line">        Arrays.stream(words)</span><br><span class="line">                .map(word -&gt; word.split(&quot;&quot;))</span><br><span class="line">                .flatMap(Arrays::stream)</span><br><span class="line">                .distinct()</span><br><span class="line">                .sorted()</span><br><span class="line">                .forEach(System.out::print); &#x2F;&#x2F; abcdef</span><br></pre></td></tr></table></figure>
</li>
<li><p>limit(long)    截断至所提供长度的流元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Random().ints().limit(10).forEach(System.out::println); &#x2F;&#x2F;输出10个随机数</span><br></pre></td></tr></table></figure>
</li>
<li><p>skip(long)    丢弃了前 N 个元素的流元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(1, e -&gt; e * 2).limit(10).skip(5).forEach(System.out::println); &#x2F;&#x2F; 2^0 - 2^9 然后丢弃前5，即2^5 - 2^9</span><br></pre></td></tr></table></figure>
</li>
<li><p>peek() 主要为debug使用，给出流操作结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)</span><br><span class="line">                .filter(e -&gt; e.length() &gt; 3)</span><br><span class="line">                .peek(e -&gt; System.out.println(&quot;Filtered value: &quot; + e))</span><br><span class="line">                .map(String::toUpperCase)</span><br><span class="line">                .peek(e -&gt; System.out.println(&quot;Mapped value: &quot; + e))</span><br><span class="line">                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="终结操作-terminal-operation"><a href="#终结操作-terminal-operation" class="headerlink" title="终结操作(terminal operation)"></a>终结操作(terminal operation)</h6><p>一个流只能有一个终结操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。终结操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个side effect。</p>
<ul>
<li><p>forEach(Consumer&lt;? extends T&gt; action) / forEachOrdered(Consumer&lt;? super T&gt; action)    将提供的操作应用于流的每个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Random().ints().limit(10).forEach(System.out::println); &#x2F;&#x2F;输出10个随机数</span><br></pre></td></tr></table></figure>
</li>
<li><p>toArray()    使用流的元素创建一个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Random().ints().limit(10).toArray();</span><br></pre></td></tr></table></figure>
</li>
<li><p>reduce(…) 将流的元素聚合为一个汇总值。</p>
<ul>
<li>Optional&lt; T&gt; reduce(BinaryOperator&lt; T&gt; accumulator);  未定义初始值，从而第一次执行的时候第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素。</li>
<li>T reduce( T identity, BinaryOperator&lt; T&gt; accumulator); 定义了初始值，从而第一次执行的时候第一个参数的值是初始值，第二个参数是Stream的第一个元素。</li>
<li>&lt; U&gt; U reduce(U identity,BiFunction&lt; U, ? super T, U&gt; accumulator,BinaryOperator&lt; U&gt; combiner); combiner的作用在于合并每个线程的result得到最终结果。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;10个随机数之和：&quot;</span><br><span class="line">                + new Random().ints()</span><br><span class="line">                .limit(10)</span><br><span class="line">                .reduce((acc, item) -&gt; acc + item)</span><br><span class="line">                .getAsInt());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>collect(…)    将流的元素聚合到一个汇总结果容器中。</p>
<ul>
<li><p>&lt; R&gt; R collect(Supplier&lt; R&gt; supplier,BiConsumer&lt; R, ? super T&gt; accumulator,BiConsumer&lt; R, R&gt; combiner);</p>
</li>
<li><p>&lt; R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList &#x3D; Stream.of(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;)</span><br><span class="line">                .filter(e -&gt; e.length() &gt; 3)</span><br><span class="line">                .map(String::toUpperCase)</span><br><span class="line">                .collect(ArrayList::new, List::add, (left, right) -&gt; left.addAll(right)); &#x2F;&#x2F;同collect(Collectors.toList())</span><br></pre></td></tr></table></figure>

<ul>
<li><p>min(Comparator&lt;? super T&gt;)    通过比较符返回流的最小元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] words &#x3D; new String[]&#123;&quot;cbad&quot;,&quot;def&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.stream(words)</span><br><span class="line">        .map(word -&gt; word.split(&quot;&quot;))</span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        .distinct()</span><br><span class="line">        .min((e1, e2) -&gt; e2.compareTo(e1)).get()); &#x2F;&#x2F; 这里逆序，返回f</span><br></pre></td></tr></table></figure>
</li>
<li><p>max(Comparator&lt;? super T&gt;)    通过比较符返回流的最大元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] words &#x3D; new String[]&#123;&quot;cbad&quot;,&quot;def&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.stream(words)</span><br><span class="line">        .map(word -&gt; word.split(&quot;&quot;))</span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        .distinct()</span><br><span class="line">        .max((e1, e2) -&gt; e2.compareTo(e1)).get()); &#x2F;&#x2F; 这里逆序，返回a</span><br></pre></td></tr></table></figure>
</li>
<li><p>count() 返回流的大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] words &#x3D; new String[]&#123;&quot;cbad&quot;,&quot;def&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.stream(words)</span><br><span class="line">        .map(word -&gt; word.split(&quot;&quot;))</span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        .distinct()</span><br><span class="line">        .count()); &#x2F;&#x2F; 输出6</span><br></pre></td></tr></table></figure>
</li>
<li><p>anyMatch(Predicate&lt;? super T&gt;) / allMatch(Predicate&lt;? super T&gt;) / noneMatch(Predicate&lt;? super T&gt;) 返回流的任何/所有元素是否与提供的预期相匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] words &#x3D; new String[]&#123;&quot;cbad&quot;,&quot;def&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.stream(words).allMatch(string -&gt; string.contains(&quot;d&quot;))); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
</li>
<li><p>findFirst() 返回流的第一个元素（如果有）。保证是第一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createStream_whenFindFirstResultIsPresent_thenCorrect() &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;);</span><br><span class="line"></span><br><span class="line">    Optional&lt;String&gt; result &#x3D; list.stream().findFirst();</span><br><span class="line"></span><br><span class="line">    assertTrue(result.isPresent());</span><br><span class="line">    assertThat(result.get(), is(&quot;A&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>findAny() 返回流的任何元素（如果有）。不保证是第一个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void createStream_whenFindAnyResultIsPresent_thenCorrect() &#123;</span><br><span class="line">    List&lt;String&gt; list &#x3D; Arrays.asList(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;);</span><br><span class="line"> </span><br><span class="line">    Optional&lt;String&gt; result &#x3D; list.stream().findAny();</span><br><span class="line"> </span><br><span class="line">    assertTrue(result.isPresent());</span><br><span class="line">    assertThat(result.get(), anyOf(is(&quot;A&quot;), is(&quot;B&quot;), is(&quot;C&quot;), is(&quot;D&quot;)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h6><p>终结操作中 collect 方法有两种入参，一是接收三个方法参数，二是接收一个Collector方法。而Collectors类中则内置了常用Collector。</p>
<ul>
<li>toCollection(Supplier&lt; C&gt; collectionFactory) 自定义集合类收集元素</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; linkedListResult &#x3D; Arrays.asList(&quot;cbad&quot;,&quot;def&quot;).stream().collect(Collectors.toCollection(LinkedList::new));</span><br></pre></td></tr></table></figure>

<ul>
<li>toList() 转ArrayList</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayListResult &#x3D; Arrays.asList(&quot;cbad&quot;,&quot;def&quot;).stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>toSet() 转hashSet</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person.createRoster()</span><br><span class="line">    .stream()</span><br><span class="line">    .map(person -&gt; person.getAge())</span><br><span class="line">    .collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<ul>
<li>joining() / joining(CharSequence delimiter) / joining(CharSequence delimiter,CharSequence prefix,CharSequence suffix) 拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] words &#x3D; new String[]&#123;&quot;cbad&quot;,&quot;def&quot;&#125;;</span><br><span class="line">System.out.println(Arrays.stream(words).collect(Collectors.joining())); &#x2F;&#x2F; cbaddef</span><br><span class="line">System.out.println(Arrays.stream(words).collect(Collectors.joining(&quot;-&quot;))); &#x2F;&#x2F; cbad-def</span><br><span class="line">System.out.println(Arrays.stream(words).collect(Collectors.joining(&quot;-&quot;, &quot;START[&quot;, &quot;]END&quot;))); &#x2F;&#x2F; START[cbad-def]END</span><br></pre></td></tr></table></figure>

<ul>
<li>mapping(Function&lt;? super T, ? extends U&gt; mapper, Collector&lt;? super U, A, R&gt; downstream) 在聚合前先对元素进行操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(&quot;cbad&quot;,&quot;def&quot;).collect(Collectors.mapping(x -&gt; x.toUpperCase(), Collectors.joining(&quot;,&quot;))); &#x2F;&#x2F;CBAD,DEF</span><br></pre></td></tr></table></figure>

<ul>
<li>collectingAndThen(Collector&lt; T,A,R&gt; downstream, Function&lt; R,RR&gt; finisher) 对聚合后的数据进行处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, Person&gt; oldestPeople &#x3D;  Person.createRoster().stream()</span><br><span class="line">                .collect(</span><br><span class="line">                        Collectors.groupingBy(</span><br><span class="line">                                Person::getGender,    &#x2F;&#x2F; 根据性别分类</span><br><span class="line">                                Collectors.collectingAndThen(</span><br><span class="line">                                        Collectors.maxBy(Comparator.comparingInt(Person::getAge)), &#x2F;&#x2F; 分别获取最大年龄</span><br><span class="line">                                        Optional::get) &#x2F;&#x2F; 对聚合结果（最大年龄）进行get</span><br><span class="line">                                        ));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>counting() 统计输入元素数量</p>
</li>
<li><p>minBy(Comparator&lt;? super T&gt; comparator) maxBy(Comparator&lt;? super T&gt; comparator) 获取最小/大元素</p>
</li>
<li><p>summingInt(ToIntFunction&lt;? super T&gt; mapper) / summingLong / summingDouble 求和</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.createRoster().stream().collect(Collectors.summingInt(Person::getAge));</span><br></pre></td></tr></table></figure>

<ul>
<li>averagingInt(ToIntFunction&lt;? super T&gt; mapper) / averagingLong / averagingDouble 求平均</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.createRoster().stream().collect(Collectors.averagingInt(Person::getAge));</span><br></pre></td></tr></table></figure>

<ul>
<li>reducing(…)  将流的元素聚合为一个汇总值。<ul>
<li>Collector&lt; T, ?, Optional&lt; T&gt;&gt; reducing(BinaryOperator&lt; T&gt; op)</li>
<li>Collector&lt; T, ?, T&gt; reducing(T identity, BinaryOperator&lt; T&gt; op)</li>
<li>Collector&lt; T, ?, U&gt; reducing(U identity,Function&lt;? super T, ? extends U&gt; mapper,BinaryOperator&lt; U&gt; op)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(</span><br><span class="line">                Stream.of(1, 2, 3, 4).collect(</span><br><span class="line">                        Collectors.reducing(0, (acc, item) -&gt; acc + item)));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>groupingBy(…) / groupingByConcurrent(…)  分组聚合</p>
<ul>
<li><p>Collector&lt; T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</p>
</li>
<li><p>Collector&lt; T, ?, Map&lt; K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream)</p>
</li>
<li><p>&lt; T, K, D, A, M extends Map&lt; K, D&gt;&gt; Collector&lt; T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt; M&gt; mapFactory,Collector&lt;? super T, A, D&gt; downstream)</p>
</li>
<li><p>Collector&lt; T, ?, ConcurrentMap&lt; K, List&lt; T&gt;&gt;&gt; groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier)</p>
</li>
<li><p>Collector&lt; T, ?, ConcurrentMap&lt; K, D&gt;&gt; groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream)</p>
</li>
<li><p>&lt; T, K, A, D, M extends ConcurrentMap&lt; K, D&gt;&gt;<br>Collector&lt; T, ?, M&gt; groupingByConcurrent(Function&lt;? super T, ? extends K&gt; classifier,Supplier&lt; M&gt; mapFactory,Collector&lt;? super T, A, D&gt; downstream) </p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, List&lt;Person&gt;&gt; peopleGroupBySex &#x3D;  Person.createRoster().stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Person::getGender));</span><br></pre></td></tr></table></figure>

<ul>
<li>partitioningBy(…) 分类为是否符合给定条件的两类<ul>
<li>Collector&lt; T, ?, Map&lt; Boolean, List&lt; T&gt;&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate)</li>
<li>Collector&lt; T, ?, Map&lt; Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? super T&gt; predicate, Collector&lt;? super T, A, D&gt; downstream)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Person&gt;&gt; peopleGroupBySex &#x3D;  Person.createRoster().stream()</span><br><span class="line">        .collect(</span><br><span class="line">                Collectors.partitioningBy(</span><br><span class="line">                        person -&gt; person.getAge() &gt;&#x3D; 18</span><br><span class="line">                                &amp;&amp; person.getGender() &#x3D;&#x3D; Person.Sex.MALE)</span><br><span class="line">                );</span><br></pre></td></tr></table></figure>

<ul>
<li><p>toMap(…) / toConcurrentMap(…)</p>
<ul>
<li><p>Collector&lt; T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper)</p>
</li>
<li><p>Collector&lt; T, ?, Map&lt;K,U&gt;&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper,BinaryOperator&lt; U&gt; mergeFunction)</p>
</li>
<li><p>Collector&lt; T, ?, M&gt; toMap(Function&lt;? super T, ? extends K&gt; keyMapper,Function&lt;? super T, ? extends U&gt; valueMapper,BinaryOperator&lt; U&gt; mergeFunction,Supplier&lt; M&gt; mapSupplier)</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Person&gt; people &#x3D;  Person.createRoster().stream()</span><br><span class="line">                .collect(</span><br><span class="line">                        Collectors.toMap(Person::getAge,</span><br><span class="line">                                Function.identity(), (oldValue, item) -&gt; item)  &#x2F;&#x2F; 这里使用了hashmap.merge，默认两参数会抛出异常，这里定义了冲突时的操作</span><br><span class="line">                        );</span><br></pre></td></tr></table></figure>

<ul>
<li>Collector&lt; T, ?, IntSummaryStatistics&gt; summarizingInt(ToIntFunction&lt;? super T&gt; mapper) / summarizingLong / summarizingDouble<br>获得统计信息 最大值，最小值，平均数，总数，总和<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional.ofNullable(</span><br><span class="line">                roster.stream().</span><br><span class="line">                        collect(Collectors.summarizingInt(Person::getAge)))</span><br><span class="line">                .ifPresent(System.out::println); &#x2F;&#x2F;IntSummaryStatistics&#123;count&#x3D;20, sum&#x3D;107, min&#x3D;0, average&#x3D;5.350000, max&#x3D;9&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><p><a href="https://www.cnblogs.com/xingzc/p/6002873.html" target="_blank" rel="noopener">JAVA8 十大新特性详解</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda Expressions</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">Stream Oracle文档</a></p>
</li>
<li><p><a href="https://www.baeldung.com/java-stream-findfirst-vs-findany" target="_blank" rel="noopener">java-stream-findfirst-vs-findany</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyyljs.site/2019/05/04/jdk8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" data-id="ckbrzm3gn000m2rld0es16bil" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/13/Stream-%E7%BC%96%E7%A8%8B%E8%83%8C%E5%90%8E/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Stream实现原理
        
      </div>
    </a>
  
  
    <a href="/2019/04/27/OWASP%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">OWASP第三方依赖检查插件使用</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring-webflux/">spring webflux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/couchbase/" rel="tag">couchbase</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elastic-search/" rel="tag">elastic search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/elk/" rel="tag">elk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%91%BD%E4%BB%A4/" rel="tag">java命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java%E5%9F%BA%E7%A1%80/" rel="tag">java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/" rel="tag">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reactive/" rel="tag">reactive</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud/" rel="tag">spring cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stream/" rel="tag">stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/couchbase/" style="font-size: 10px;">couchbase</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/dubbo/" style="font-size: 15px;">dubbo</a> <a href="/tags/elastic-search/" style="font-size: 10px;">elastic search</a> <a href="/tags/elk/" style="font-size: 10px;">elk</a> <a href="/tags/java/" style="font-size: 12.5px;">java</a> <a href="/tags/java%E5%91%BD%E4%BB%A4/" style="font-size: 17.5px;">java命令</a> <a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">java基础</a> <a href="/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/tags/reactive/" style="font-size: 10px;">reactive</a> <a href="/tags/spring-cloud/" style="font-size: 20px;">spring cloud</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/22/Spring-Reactive-Data-With-Multi-Couchbase-Buckets/">Spring Reactive Data With Multi Couchbase Buckets</a>
          </li>
        
          <li>
            <a href="/2019/06/05/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%9A%E5%8A%A1%E5%9F%9F%E5%90%8D%E9%99%90%E5%88%B6%E9%97%AE%E9%A2%98/">反向代理解决微信小程序业务域名限制问题</a>
          </li>
        
          <li>
            <a href="/2019/05/13/Stream-%E7%BC%96%E7%A8%8B%E8%83%8C%E5%90%8E/">Stream实现原理</a>
          </li>
        
          <li>
            <a href="/2019/05/04/jdk8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">jdk8函数式编程</a>
          </li>
        
          <li>
            <a href="/2019/04/27/OWASP%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BE%9D%E8%B5%96%E6%A3%80%E6%9F%A5%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/">OWASP第三方依赖检查插件使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 lyyljs<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>